<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>TiledArray: TiledArray::Tensor&lt; T, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TiledArray
   &#160;<span id="projectnumber">0.5.0-alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_tiled_array_1_1_tensor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_tiled_array_1_1_tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray::Tensor&lt; T, A &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An N-dimensional tensor object.  
 <a href="class_tiled_array_1_1_tensor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="foreach_8h_source.html">foreach.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5608ebaf867dc02438adf9475a5ed719"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a></td></tr>
<tr class="memdesc:a5608ebaf867dc02438adf9475a5ed719"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class type.  <a href="#a5608ebaf867dc02438adf9475a5ed719">More...</a><br /></td></tr>
<tr class="separator:a5608ebaf867dc02438adf9475a5ed719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6953592a083f07bc6132a571a9d767"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a></td></tr>
<tr class="memdesc:a9a6953592a083f07bc6132a571a9d767"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> range type.  <a href="#a9a6953592a083f07bc6132a571a9d767">More...</a><br /></td></tr>
<tr class="separator:a9a6953592a083f07bc6132a571a9d767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f44171ea91af2bb2a393ca06d5af662"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_range.html#a8763d983047391957211be4b8b319649">range_type::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a></td></tr>
<tr class="memdesc:a4f44171ea91af2bb2a393ca06d5af662"><td class="mdescLeft">&#160;</td><td class="mdescRight">size type  <a href="#a4f44171ea91af2bb2a393ca06d5af662">More...</a><br /></td></tr>
<tr class="separator:a4f44171ea91af2bb2a393ca06d5af662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99586ecbed993b0a7dc33ca231131d15"><td class="memItemLeft" align="right" valign="top">typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a99586ecbed993b0a7dc33ca231131d15">allocator_type</a></td></tr>
<tr class="memdesc:a99586ecbed993b0a7dc33ca231131d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type.  <a href="#a99586ecbed993b0a7dc33ca231131d15">More...</a><br /></td></tr>
<tr class="separator:a99586ecbed993b0a7dc33ca231131d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64c1efaee17c30ac1559f18e1eb0e88"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab64c1efaee17c30ac1559f18e1eb0e88">value_type</a></td></tr>
<tr class="memdesc:ab64c1efaee17c30ac1559f18e1eb0e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array element type.  <a href="#ab64c1efaee17c30ac1559f18e1eb0e88">More...</a><br /></td></tr>
<tr class="separator:ab64c1efaee17c30ac1559f18e1eb0e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dc24eca41c8655a8871e838183e24b"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a></td></tr>
<tr class="memdesc:ac8dc24eca41c8655a8871e838183e24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element reference type.  <a href="#ac8dc24eca41c8655a8871e838183e24b">More...</a><br /></td></tr>
<tr class="separator:ac8dc24eca41c8655a8871e838183e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b80372c9a8886e30106219eca40b66c"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a></td></tr>
<tr class="memdesc:a8b80372c9a8886e30106219eca40b66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element reference type.  <a href="#a8b80372c9a8886e30106219eca40b66c">More...</a><br /></td></tr>
<tr class="separator:a8b80372c9a8886e30106219eca40b66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0c51fc37253afe287423fe5971da8c"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a></td></tr>
<tr class="memdesc:ace0c51fc37253afe287423fe5971da8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element pointer type.  <a href="#ace0c51fc37253afe287423fe5971da8c">More...</a><br /></td></tr>
<tr class="separator:ace0c51fc37253afe287423fe5971da8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3ca56e0bf2b27a8632d1598c1d526"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a></td></tr>
<tr class="memdesc:a13b3ca56e0bf2b27a8632d1598c1d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element const pointer type.  <a href="#a13b3ca56e0bf2b27a8632d1598c1d526">More...</a><br /></td></tr>
<tr class="separator:a13b3ca56e0bf2b27a8632d1598c1d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104deacaf44eb9d0fa97b32c59d53cc5"><td class="memItemLeft" align="right" valign="top">typedef allocator_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a104deacaf44eb9d0fa97b32c59d53cc5">difference_type</a></td></tr>
<tr class="memdesc:a104deacaf44eb9d0fa97b32c59d53cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type.  <a href="#a104deacaf44eb9d0fa97b32c59d53cc5">More...</a><br /></td></tr>
<tr class="separator:a104deacaf44eb9d0fa97b32c59d53cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a6bcdbeae5dec3343d6ae28df8284"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a></td></tr>
<tr class="memdesc:a7c3a6bcdbeae5dec3343d6ae28df8284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element iterator type.  <a href="#a7c3a6bcdbeae5dec3343d6ae28df8284">More...</a><br /></td></tr>
<tr class="separator:a7c3a6bcdbeae5dec3343d6ae28df8284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a4203b62aa1e370d6995aad071f40"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a></td></tr>
<tr class="memdesc:a643a4203b62aa1e370d6995aad071f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element const iterator type.  <a href="#a643a4203b62aa1e370d6995aad071f40">More...</a><br /></td></tr>
<tr class="separator:a643a4203b62aa1e370d6995aad071f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2e1a62ce018f90f552510d29fd9ed2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a></td></tr>
<tr class="memdesc:abc2e1a62ce018f90f552510d29fd9ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the numeric type that supports T  <a href="#abc2e1a62ce018f90f552510d29fd9ed2">More...</a><br /></td></tr>
<tr class="separator:abc2e1a62ce018f90f552510d29fd9ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3ff935ffdd12ded18a1041a0a18faf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a></td></tr>
<tr class="memdesc:a9a3ff935ffdd12ded18a1041a0a18faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">the scalar type that supports T  <a href="#a9a3ff935ffdd12ded18a1041a0a18faf">More...</a><br /></td></tr>
<tr class="separator:a9a3ff935ffdd12ded18a1041a0a18faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a52053224a88d9d8478805d7c5f89ec59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a52053224a88d9d8478805d7c5f89ec59">Tensor</a> ()</td></tr>
<tr class="separator:a52053224a88d9d8478805d7c5f89ec59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414d8ebf6c834c5500ca5b5408708f58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a414d8ebf6c834c5500ca5b5408708f58">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;other)</td></tr>
<tr class="separator:a414d8ebf6c834c5500ca5b5408708f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437e6fa337043142c4be807cd46bf5d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a437e6fa337043142c4be807cd46bf5d1">Tensor</a> (<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;other)</td></tr>
<tr class="separator:a437e6fa337043142c4be807cd46bf5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709fe578d55e8ee8c1e187d6f1a1ad4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a709fe578d55e8ee8c1e187d6f1a1ad4e">~Tensor</a> ()</td></tr>
<tr class="separator:a709fe578d55e8ee8c1e187d6f1a1ad4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb641cc67d36bf3e87b59eaf10a2dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5bb641cc67d36bf3e87b59eaf10a2dff">operator=</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;other)</td></tr>
<tr class="separator:a5bb641cc67d36bf3e87b59eaf10a2dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375a995714597079b944907eb89245bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a375a995714597079b944907eb89245bc">operator=</a> (<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;other)</td></tr>
<tr class="separator:a375a995714597079b944907eb89245bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff000b8850b2992ff765eb3f8f116632"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aff000b8850b2992ff765eb3f8f116632">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#a6521f4ce917ca6a41bb3ada9ef3b4d1c">range</a>)</td></tr>
<tr class="memdesc:aff000b8850b2992ff765eb3f8f116632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct tensor.  <a href="#aff000b8850b2992ff765eb3f8f116632">More...</a><br /></td></tr>
<tr class="separator:aff000b8850b2992ff765eb3f8f116632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename std::enable_if&lt; std::is_same&lt; Value, value_type &gt;::value &amp;&amp;                       detail::is_tensor&lt; Value &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#a6521f4ce917ca6a41bb3ada9ef3b4d1c">range</a>, const Value &amp;value)</td></tr>
<tr class="memdesc:ad06d56e445f36d572109abbafc1a32e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tensor with a fill value.  <a href="#ad06d56e445f36d572109abbafc1a32e5">More...</a><br /></td></tr>
<tr class="separator:ad06d56e445f36d572109abbafc1a32e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename std::enable_if&lt; detail::is_numeric&lt; Value &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad06d56e445f36d572109abbafc1a32e5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#a6521f4ce917ca6a41bb3ada9ef3b4d1c">range</a>, const Value &amp;value)</td></tr>
<tr class="memdesc:ad06d56e445f36d572109abbafc1a32e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tensor with a fill value.  <a href="#ad06d56e445f36d572109abbafc1a32e5">More...</a><br /></td></tr>
<tr class="separator:ad06d56e445f36d572109abbafc1a32e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a04249ef7d49a620988dec54b296f1a"><td class="memTemplParams" colspan="2">template&lt;typename InIter , typename std::enable_if&lt; TiledArray::detail::is_input_iterator&lt; InIter &gt;::value &amp;&amp;                                       !std::is_pointer&lt; InIter &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7a04249ef7d49a620988dec54b296f1a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7a04249ef7d49a620988dec54b296f1a">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#a6521f4ce917ca6a41bb3ada9ef3b4d1c">range</a>, InIter it)</td></tr>
<tr class="memdesc:a7a04249ef7d49a620988dec54b296f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an evaluated tensor.  <a href="#a7a04249ef7d49a620988dec54b296f1a">More...</a><br /></td></tr>
<tr class="separator:a7a04249ef7d49a620988dec54b296f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46913eeb18eceebf619a6d73698704a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ad46913eeb18eceebf619a6d73698704a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad46913eeb18eceebf619a6d73698704a">Tensor</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;<a class="el" href="class_tiled_array_1_1_tensor.html#a6521f4ce917ca6a41bb3ada9ef3b4d1c">range</a>, const U *u)</td></tr>
<tr class="separator:ad46913eeb18eceebf619a6d73698704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8514a8061acfd51b3551dd42fd54c0a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;                                       !std::is_same&lt; T1, Tensor_ &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8514a8061acfd51b3551dd42fd54c0a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aa8514a8061acfd51b3551dd42fd54c0a">Tensor</a> (const T1 &amp;other)</td></tr>
<tr class="memdesc:aa8514a8061acfd51b3551dd42fd54c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of a tensor interface object.  <a href="#aa8514a8061acfd51b3551dd42fd54c0a">More...</a><br /></td></tr>
<tr class="separator:aa8514a8061acfd51b3551dd42fd54c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa7eb63040aed24a687003d36ebe23e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aefa7eb63040aed24a687003d36ebe23e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aefa7eb63040aed24a687003d36ebe23e">Tensor</a> (const T1 &amp;other, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aefa7eb63040aed24a687003d36ebe23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a permuted tensor copy.  <a href="#aefa7eb63040aed24a687003d36ebe23e">More...</a><br /></td></tr>
<tr class="separator:aefa7eb63040aed24a687003d36ebe23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af833692ef1ebff1764c2cabbebd1e2f9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value                                                           &amp;&amp;!std::is_same&lt; typename std::decay&lt; Op &gt;::type,                                                           Permutation &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af833692ef1ebff1764c2cabbebd1e2f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af833692ef1ebff1764c2cabbebd1e2f9">Tensor</a> (const T1 &amp;other, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:af833692ef1ebff1764c2cabbebd1e2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and modify the data from <code>other</code>.  <a href="#af833692ef1ebff1764c2cabbebd1e2f9">More...</a><br /></td></tr>
<tr class="separator:af833692ef1ebff1764c2cabbebd1e2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1669d83e4b46727bebe493178cdefd2a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1669d83e4b46727bebe493178cdefd2a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a1669d83e4b46727bebe493178cdefd2a">Tensor</a> (const T1 &amp;other, Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a1669d83e4b46727bebe493178cdefd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy, modify, and permute the data from <code>other</code>.  <a href="#a1669d83e4b46727bebe493178cdefd2a">More...</a><br /></td></tr>
<tr class="separator:a1669d83e4b46727bebe493178cdefd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4212439f4e33716dabdf6ecafb626991"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4212439f4e33716dabdf6ecafb626991"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a4212439f4e33716dabdf6ecafb626991">Tensor</a> (const T1 &amp;left, const T2 &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a4212439f4e33716dabdf6ecafb626991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and modify the data from <code>left</code>, and <code>right</code>.  <a href="#a4212439f4e33716dabdf6ecafb626991">More...</a><br /></td></tr>
<tr class="separator:a4212439f4e33716dabdf6ecafb626991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50dacb073f515e83be7e11d0b063a9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7a50dacb073f515e83be7e11d0b063a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7a50dacb073f515e83be7e11d0b063a9">Tensor</a> (const T1 &amp;left, const T2 &amp;right, Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a7a50dacb073f515e83be7e11d0b063a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy, modify, and permute the data from <code>left</code>, and <code>right</code>.  <a href="#a7a50dacb073f515e83be7e11d0b063a9">More...</a><br /></td></tr>
<tr class="separator:a7a50dacb073f515e83be7e11d0b063a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9add7b831aa08fadab92ce9188edbb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ae9add7b831aa08fadab92ce9188edbb6">clone</a> () const </td></tr>
<tr class="separator:ae9add7b831aa08fadab92ce9188edbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d3eed3caa265526a36b1e042aaeb9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a864d3eed3caa265526a36b1e042aaeb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9">operator=</a> (const T1 &amp;other)</td></tr>
<tr class="separator:a864d3eed3caa265526a36b1e042aaeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6521f4ce917ca6a41bb3ada9ef3b4d1c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a6521f4ce917ca6a41bb3ada9ef3b4d1c">range</a> () const </td></tr>
<tr class="memdesc:a6521f4ce917ca6a41bb3ada9ef3b4d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> range object accessor.  <a href="#a6521f4ce917ca6a41bb3ada9ef3b4d1c">More...</a><br /></td></tr>
<tr class="separator:a6521f4ce917ca6a41bb3ada9ef3b4d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae424ed4ba8d09a72a8ffa824e603b081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ae424ed4ba8d09a72a8ffa824e603b081">size</a> () const </td></tr>
<tr class="memdesc:ae424ed4ba8d09a72a8ffa824e603b081"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> dimension size accessor.  <a href="#ae424ed4ba8d09a72a8ffa824e603b081">More...</a><br /></td></tr>
<tr class="separator:ae424ed4ba8d09a72a8ffa824e603b081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8839f1a20dcca6301f1f2b93ddfdb6fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8839f1a20dcca6301f1f2b93ddfdb6fc">operator[]</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> i) const </td></tr>
<tr class="memdesc:a8839f1a20dcca6301f1f2b93ddfdb6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="#a8839f1a20dcca6301f1f2b93ddfdb6fc">More...</a><br /></td></tr>
<tr class="separator:a8839f1a20dcca6301f1f2b93ddfdb6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c83be5dd7fcb13e57d0030452371ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a63c83be5dd7fcb13e57d0030452371ff">operator[]</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> i)</td></tr>
<tr class="memdesc:a63c83be5dd7fcb13e57d0030452371ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="#a63c83be5dd7fcb13e57d0030452371ff">More...</a><br /></td></tr>
<tr class="separator:a63c83be5dd7fcb13e57d0030452371ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9313a1040cdac7d200e1c57c2ec7b34"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename std::enable_if&lt;                                          !std::is_integral&lt; Index &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa9313a1040cdac7d200e1c57c2ec7b34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aa9313a1040cdac7d200e1c57c2ec7b34">operator[]</a> (const Index &amp;i) const </td></tr>
<tr class="memdesc:aa9313a1040cdac7d200e1c57c2ec7b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="#aa9313a1040cdac7d200e1c57c2ec7b34">More...</a><br /></td></tr>
<tr class="separator:aa9313a1040cdac7d200e1c57c2ec7b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f15590536ef934aadcf7ca3e81c39"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename std::enable_if&lt;                                  !std::is_integral&lt; Index &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a369f15590536ef934aadcf7ca3e81c39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a369f15590536ef934aadcf7ca3e81c39">operator[]</a> (const Index &amp;i)</td></tr>
<tr class="memdesc:a369f15590536ef934aadcf7ca3e81c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="#a369f15590536ef934aadcf7ca3e81c39">More...</a><br /></td></tr>
<tr class="separator:a369f15590536ef934aadcf7ca3e81c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1769b4826601efae3635a37829c369"><td class="memTemplParams" colspan="2">template&lt;typename... Index&gt; </td></tr>
<tr class="memitem:a5a1769b4826601efae3635a37829c369"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5a1769b4826601efae3635a37829c369">operator()</a> (const Index &amp;...idx)</td></tr>
<tr class="memdesc:a5a1769b4826601efae3635a37829c369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="#a5a1769b4826601efae3635a37829c369">More...</a><br /></td></tr>
<tr class="separator:a5a1769b4826601efae3635a37829c369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f5644bd071526859633f0a6e3db525"><td class="memTemplParams" colspan="2">template&lt;typename... Index&gt; </td></tr>
<tr class="memitem:ae9f5644bd071526859633f0a6e3db525"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ae9f5644bd071526859633f0a6e3db525">operator()</a> (const Index &amp;...idx) const </td></tr>
<tr class="memdesc:ae9f5644bd071526859633f0a6e3db525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element accessor.  <a href="#ae9f5644bd071526859633f0a6e3db525">More...</a><br /></td></tr>
<tr class="separator:ae9f5644bd071526859633f0a6e3db525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa403b68eb3e307d65aab0da3900478d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aa403b68eb3e307d65aab0da3900478d9">begin</a> () const </td></tr>
<tr class="memdesc:aa403b68eb3e307d65aab0da3900478d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="#aa403b68eb3e307d65aab0da3900478d9">More...</a><br /></td></tr>
<tr class="separator:aa403b68eb3e307d65aab0da3900478d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb2732327b1e80aae0f82e590824642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a6cb2732327b1e80aae0f82e590824642">begin</a> ()</td></tr>
<tr class="memdesc:a6cb2732327b1e80aae0f82e590824642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="#a6cb2732327b1e80aae0f82e590824642">More...</a><br /></td></tr>
<tr class="separator:a6cb2732327b1e80aae0f82e590824642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e7557a4c1b87b7405dcf0374bca34a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a79e7557a4c1b87b7405dcf0374bca34a">end</a> () const </td></tr>
<tr class="memdesc:a79e7557a4c1b87b7405dcf0374bca34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="#a79e7557a4c1b87b7405dcf0374bca34a">More...</a><br /></td></tr>
<tr class="separator:a79e7557a4c1b87b7405dcf0374bca34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388e96f2343d855abff091534612abbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a388e96f2343d855abff091534612abbd">end</a> ()</td></tr>
<tr class="memdesc:a388e96f2343d855abff091534612abbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator factory.  <a href="#a388e96f2343d855abff091534612abbd">More...</a><br /></td></tr>
<tr class="separator:a388e96f2343d855abff091534612abbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4598d2ea75c448d596533476acee21f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a4598d2ea75c448d596533476acee21f7">data</a> () const </td></tr>
<tr class="memdesc:a4598d2ea75c448d596533476acee21f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data direct access.  <a href="#a4598d2ea75c448d596533476acee21f7">More...</a><br /></td></tr>
<tr class="separator:a4598d2ea75c448d596533476acee21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372ad5542cb41792eb72a6e1da63b6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a372ad5542cb41792eb72a6e1da63b6b0">data</a> ()</td></tr>
<tr class="memdesc:a372ad5542cb41792eb72a6e1da63b6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data direct access.  <a href="#a372ad5542cb41792eb72a6e1da63b6b0">More...</a><br /></td></tr>
<tr class="separator:a372ad5542cb41792eb72a6e1da63b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c81ab595b2582f7542b9a24f722d0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a26c81ab595b2582f7542b9a24f722d0e">empty</a> () const </td></tr>
<tr class="memdesc:a26c81ab595b2582f7542b9a24f722d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the tensor is empty.  <a href="#a26c81ab595b2582f7542b9a24f722d0e">More...</a><br /></td></tr>
<tr class="separator:a26c81ab595b2582f7542b9a24f722d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename std::enable_if&lt;                                  madness::archive::is_output_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a18da463545a06f07288ea5c8439c63a8">serialize</a> (Archive &amp;ar)</td></tr>
<tr class="memdesc:a18da463545a06f07288ea5c8439c63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output serialization function.  <a href="#a18da463545a06f07288ea5c8439c63a8">More...</a><br /></td></tr>
<tr class="separator:a18da463545a06f07288ea5c8439c63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename std::enable_if&lt;                                  madness::archive::is_input_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a18da463545a06f07288ea5c8439c63a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a18da463545a06f07288ea5c8439c63a8">serialize</a> (Archive &amp;ar)</td></tr>
<tr class="memdesc:a18da463545a06f07288ea5c8439c63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input serialization function.  <a href="#a18da463545a06f07288ea5c8439c63a8">More...</a><br /></td></tr>
<tr class="separator:a18da463545a06f07288ea5c8439c63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f33f8afac53cb621c12cac5e1d256a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ab7f33f8afac53cb621c12cac5e1d256a">swap</a> (<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;other)</td></tr>
<tr class="memdesc:ab7f33f8afac53cb621c12cac5e1d256a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap tensor data.  <a href="#ab7f33f8afac53cb621c12cac5e1d256a">More...</a><br /></td></tr>
<tr class="separator:ab7f33f8afac53cb621c12cac5e1d256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e3d0ee7069ad9541881621b9208d5"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a977e3d0ee7069ad9541881621b9208d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a977e3d0ee7069ad9541881621b9208d5">block</a> (const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a977e3d0ee7069ad9541881621b9208d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea400289d232690060434021d47c2ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aea400289d232690060434021d47c2ea7">block</a> (const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;lower_bound, const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;upper_bound)</td></tr>
<tr class="separator:aea400289d232690060434021d47c2ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e9accdb3e2f47848566305d4c8848"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a058e9accdb3e2f47848566305d4c8848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a058e9accdb3e2f47848566305d4c8848">block</a> (const Index &amp;lower_bound, const Index &amp;upper_bound) const </td></tr>
<tr class="separator:a058e9accdb3e2f47848566305d4c8848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac8b290992aa2d73700a46bd793cbe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a1ac8b290992aa2d73700a46bd793cbe0">block</a> (const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;lower_bound, const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;upper_bound) const </td></tr>
<tr class="separator:a1ac8b290992aa2d73700a46bd793cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa975640407d4460e99f85ca41398f4d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aa975640407d4460e99f85ca41398f4d1">permute</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:aa975640407d4460e99f85ca41398f4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of this tensor.  <a href="#aa975640407d4460e99f85ca41398f4d1">More...</a><br /></td></tr>
<tr class="separator:aa975640407d4460e99f85ca41398f4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf08314a6ce26804634a40a5c6a3d67"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a0cf08314a6ce26804634a40a5c6a3d67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a0cf08314a6ce26804634a40a5c6a3d67">shift_to</a> (const Index &amp;bound_shift)</td></tr>
<tr class="memdesc:a0cf08314a6ce26804634a40a5c6a3d67"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the lower and upper bound of this tensor.  <a href="#a0cf08314a6ce26804634a40a5c6a3d67">More...</a><br /></td></tr>
<tr class="separator:a0cf08314a6ce26804634a40a5c6a3d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef47b114ae4c0964c08c90e227a37f1"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:afef47b114ae4c0964c08c90e227a37f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#afef47b114ae4c0964c08c90e227a37f1">shift</a> (const Index &amp;bound_shift) const </td></tr>
<tr class="memdesc:afef47b114ae4c0964c08c90e227a37f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the lower and upper bound of this range.  <a href="#afef47b114ae4c0964c08c90e227a37f1">More...</a><br /></td></tr>
<tr class="separator:afef47b114ae4c0964c08c90e227a37f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8005d292051062ad3892265e28010a4b"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a8005d292051062ad3892265e28010a4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8005d292051062ad3892265e28010a4b">binary</a> (const Right &amp;right, Op &amp;&amp;op) const </td></tr>
<tr class="memdesc:a8005d292051062ad3892265e28010a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a binary, element wise operation to construct a new tensor.  <a href="#a8005d292051062ad3892265e28010a4b">More...</a><br /></td></tr>
<tr class="separator:a8005d292051062ad3892265e28010a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e141a35f0d8a7cc57c009b6b524411c"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1e141a35f0d8a7cc57c009b6b524411c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a1e141a35f0d8a7cc57c009b6b524411c">binary</a> (const Right &amp;right, Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a1e141a35f0d8a7cc57c009b6b524411c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a binary, element wise operation to construct a new, permuted tensor.  <a href="#a1e141a35f0d8a7cc57c009b6b524411c">More...</a><br /></td></tr>
<tr class="separator:a1e141a35f0d8a7cc57c009b6b524411c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272585651b1233bb8f90d23c88a12c61"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a272585651b1233bb8f90d23c88a12c61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61">inplace_binary</a> (const Right &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a272585651b1233bb8f90d23c88a12c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a binary, element wise operation to modify this tensor.  <a href="#a272585651b1233bb8f90d23c88a12c61">More...</a><br /></td></tr>
<tr class="separator:a272585651b1233bb8f90d23c88a12c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e6422efc9c251ed076b6602b484e97"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a69e6422efc9c251ed076b6602b484e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a69e6422efc9c251ed076b6602b484e97">unary</a> (Op &amp;&amp;op) const </td></tr>
<tr class="memdesc:a69e6422efc9c251ed076b6602b484e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a unary, element wise operation to construct a new tensor.  <a href="#a69e6422efc9c251ed076b6602b484e97">More...</a><br /></td></tr>
<tr class="separator:a69e6422efc9c251ed076b6602b484e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207755b3eca04e865587f72ecbdd6477"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a207755b3eca04e865587f72ecbdd6477"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a207755b3eca04e865587f72ecbdd6477">unary</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a207755b3eca04e865587f72ecbdd6477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a unary, element wise operation to construct a new, permuted tensor.  <a href="#a207755b3eca04e865587f72ecbdd6477">More...</a><br /></td></tr>
<tr class="separator:a207755b3eca04e865587f72ecbdd6477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23df0d855cd33e6e977bd39e780ca9a"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af23df0d855cd33e6e977bd39e780ca9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a> (Op &amp;&amp;op)</td></tr>
<tr class="memdesc:af23df0d855cd33e6e977bd39e780ca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a unary, element wise operation to modify this tensor.  <a href="#af23df0d855cd33e6e977bd39e780ca9a">More...</a><br /></td></tr>
<tr class="separator:af23df0d855cd33e6e977bd39e780ca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a3f4ca9ea64d150d9501acec762090"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a39a3f4ca9ea64d150d9501acec762090"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a39a3f4ca9ea64d150d9501acec762090">scale</a> (const Scalar factor) const </td></tr>
<tr class="memdesc:a39a3f4ca9ea64d150d9501acec762090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a scaled copy of this tensor.  <a href="#a39a3f4ca9ea64d150d9501acec762090">More...</a><br /></td></tr>
<tr class="separator:a39a3f4ca9ea64d150d9501acec762090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb2b4d1f49ea064a738f0ab8410cbd1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5eb2b4d1f49ea064a738f0ab8410cbd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5eb2b4d1f49ea064a738f0ab8410cbd1">scale</a> (const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a5eb2b4d1f49ea064a738f0ab8410cbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a scaled and permuted copy of this tensor.  <a href="#a5eb2b4d1f49ea064a738f0ab8410cbd1">More...</a><br /></td></tr>
<tr class="separator:a5eb2b4d1f49ea064a738f0ab8410cbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ee5e211e0a606f194bde6699b9d373"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a19ee5e211e0a606f194bde6699b9d373"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a19ee5e211e0a606f194bde6699b9d373">scale_to</a> (const Scalar factor)</td></tr>
<tr class="memdesc:a19ee5e211e0a606f194bde6699b9d373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale this tensor.  <a href="#a19ee5e211e0a606f194bde6699b9d373">More...</a><br /></td></tr>
<tr class="separator:a19ee5e211e0a606f194bde6699b9d373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1907f43fcdcc43e0ae4f9c143767bfb1"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1907f43fcdcc43e0ae4f9c143767bfb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a1907f43fcdcc43e0ae4f9c143767bfb1">add</a> (const Right &amp;right) const </td></tr>
<tr class="memdesc:a1907f43fcdcc43e0ae4f9c143767bfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> this and <code>other</code> to construct a new tensors.  <a href="#a1907f43fcdcc43e0ae4f9c143767bfb1">More...</a><br /></td></tr>
<tr class="separator:a1907f43fcdcc43e0ae4f9c143767bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa67535e35bbda4182bcec15a876967"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:adfa67535e35bbda4182bcec15a876967"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#adfa67535e35bbda4182bcec15a876967">add</a> (const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:adfa67535e35bbda4182bcec15a876967"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> this and <code>other</code> to construct a new, permuted tensor.  <a href="#adfa67535e35bbda4182bcec15a876967">More...</a><br /></td></tr>
<tr class="separator:adfa67535e35bbda4182bcec15a876967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8e32d8aa56a477dba7bf52b38b66b"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a8bf8e32d8aa56a477dba7bf52b38b66b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8bf8e32d8aa56a477dba7bf52b38b66b">add</a> (const Right &amp;right, const Scalar factor) const </td></tr>
<tr class="memdesc:a8bf8e32d8aa56a477dba7bf52b38b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and add this and <code>other</code> to construct a new tensor.  <a href="#a8bf8e32d8aa56a477dba7bf52b38b66b">More...</a><br /></td></tr>
<tr class="separator:a8bf8e32d8aa56a477dba7bf52b38b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa977f933291df14c39009736c59a8b0c"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa977f933291df14c39009736c59a8b0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aa977f933291df14c39009736c59a8b0c">add</a> (const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:aa977f933291df14c39009736c59a8b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and add this and <code>other</code> to construct a new, permuted tensor.  <a href="#aa977f933291df14c39009736c59a8b0c">More...</a><br /></td></tr>
<tr class="separator:aa977f933291df14c39009736c59a8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39b998b0ce99a03924f257eb103e2dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af39b998b0ce99a03924f257eb103e2dd">add</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value) const </td></tr>
<tr class="memdesc:af39b998b0ce99a03924f257eb103e2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant to a copy of this tensor.  <a href="#af39b998b0ce99a03924f257eb103e2dd">More...</a><br /></td></tr>
<tr class="separator:af39b998b0ce99a03924f257eb103e2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d32834339f136a79ab7072aeab09b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad5d32834339f136a79ab7072aeab09b4">add</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:ad5d32834339f136a79ab7072aeab09b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant to a permuted copy of this tensor.  <a href="#ad5d32834339f136a79ab7072aeab09b4">More...</a><br /></td></tr>
<tr class="separator:ad5d32834339f136a79ab7072aeab09b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfff2aa620117307ba085091693a768"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3dfff2aa620117307ba085091693a768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a3dfff2aa620117307ba085091693a768">add_to</a> (const Right &amp;right)</td></tr>
<tr class="memdesc:a3dfff2aa620117307ba085091693a768"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> <code>other</code> to this tensor.  <a href="#a3dfff2aa620117307ba085091693a768">More...</a><br /></td></tr>
<tr class="separator:a3dfff2aa620117307ba085091693a768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c2a4263360a58dbaba16cb434e2794"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a91c2a4263360a58dbaba16cb434e2794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a91c2a4263360a58dbaba16cb434e2794">add_to</a> (const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:a91c2a4263360a58dbaba16cb434e2794"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> <code>other</code> to this tensor, and scale the result.  <a href="#a91c2a4263360a58dbaba16cb434e2794">More...</a><br /></td></tr>
<tr class="separator:a91c2a4263360a58dbaba16cb434e2794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad959a4848795f8352fd9dfd25631948a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad959a4848795f8352fd9dfd25631948a">add_to</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value)</td></tr>
<tr class="memdesc:ad959a4848795f8352fd9dfd25631948a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant to this tensor.  <a href="#ad959a4848795f8352fd9dfd25631948a">More...</a><br /></td></tr>
<tr class="separator:ad959a4848795f8352fd9dfd25631948a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d59e8758cac8cb6501246bff199c5"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c6d59e8758cac8cb6501246bff199c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a4c6d59e8758cac8cb6501246bff199c5">subt</a> (const Right &amp;right) const </td></tr>
<tr class="memdesc:a4c6d59e8758cac8cb6501246bff199c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract this and <code>right</code> to construct a new tensor.  <a href="#a4c6d59e8758cac8cb6501246bff199c5">More...</a><br /></td></tr>
<tr class="separator:a4c6d59e8758cac8cb6501246bff199c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142a97cab79143c6928611266b9b6a05"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a142a97cab79143c6928611266b9b6a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a142a97cab79143c6928611266b9b6a05">subt</a> (const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a142a97cab79143c6928611266b9b6a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract this and <code>right</code> to construct a new, permuted tensor.  <a href="#a142a97cab79143c6928611266b9b6a05">More...</a><br /></td></tr>
<tr class="separator:a142a97cab79143c6928611266b9b6a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac158b1622dbc171580ed8531f7d36986"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac158b1622dbc171580ed8531f7d36986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ac158b1622dbc171580ed8531f7d36986">subt</a> (const Right &amp;right, const Scalar factor) const </td></tr>
<tr class="memdesc:ac158b1622dbc171580ed8531f7d36986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and subtract this and <code>right</code> to construct a new tensor.  <a href="#ac158b1622dbc171580ed8531f7d36986">More...</a><br /></td></tr>
<tr class="separator:ac158b1622dbc171580ed8531f7d36986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5c10ac9ab93b55610638901ac58ac8"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c5c10ac9ab93b55610638901ac58ac8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a1c5c10ac9ab93b55610638901ac58ac8">subt</a> (const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a1c5c10ac9ab93b55610638901ac58ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and subtract this and <code>right</code> to construct a new, permuted tensor.  <a href="#a1c5c10ac9ab93b55610638901ac58ac8">More...</a><br /></td></tr>
<tr class="separator:a1c5c10ac9ab93b55610638901ac58ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b4d88e87f80f0cd72724ce1738ef97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af8b4d88e87f80f0cd72724ce1738ef97">subt</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value) const </td></tr>
<tr class="memdesc:af8b4d88e87f80f0cd72724ce1738ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant from a copy of this tensor.  <a href="#af8b4d88e87f80f0cd72724ce1738ef97">More...</a><br /></td></tr>
<tr class="separator:af8b4d88e87f80f0cd72724ce1738ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9d052179f9441987e184d0082ed75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a70f9d052179f9441987e184d0082ed75">subt</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a70f9d052179f9441987e184d0082ed75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant from a permuted copy of this tensor.  <a href="#a70f9d052179f9441987e184d0082ed75">More...</a><br /></td></tr>
<tr class="separator:a70f9d052179f9441987e184d0082ed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a6732b912c2ce09fcf078d814f0ca8cb9">subt_to</a> (const Right &amp;right)</td></tr>
<tr class="memdesc:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <code>right</code> from this tensor.  <a href="#a6732b912c2ce09fcf078d814f0ca8cb9">More...</a><br /></td></tr>
<tr class="separator:a6732b912c2ce09fcf078d814f0ca8cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a421cd397418787307aac0d453a3d7"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af9a421cd397418787307aac0d453a3d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af9a421cd397418787307aac0d453a3d7">subt_to</a> (const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:af9a421cd397418787307aac0d453a3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract <code>right</code> from and scale this tensor.  <a href="#af9a421cd397418787307aac0d453a3d7">More...</a><br /></td></tr>
<tr class="separator:af9a421cd397418787307aac0d453a3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e44d414e05fe2fe09648ad9856ade68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a8e44d414e05fe2fe09648ad9856ade68">subt_to</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> value)</td></tr>
<tr class="memdesc:a8e44d414e05fe2fe09648ad9856ade68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant from this tensor.  <a href="#a8e44d414e05fe2fe09648ad9856ade68">More...</a><br /></td></tr>
<tr class="separator:a8e44d414e05fe2fe09648ad9856ade68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21e15e1549187df9ea498ec3c6f0d9"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aee21e15e1549187df9ea498ec3c6f0d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aee21e15e1549187df9ea498ec3c6f0d9">mult</a> (const Right &amp;right) const </td></tr>
<tr class="memdesc:aee21e15e1549187df9ea498ec3c6f0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this by <code>right</code> to create a new tensor.  <a href="#aee21e15e1549187df9ea498ec3c6f0d9">More...</a><br /></td></tr>
<tr class="separator:aee21e15e1549187df9ea498ec3c6f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef8642cb0177287cd37eca0df785f3b"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:adef8642cb0177287cd37eca0df785f3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#adef8642cb0177287cd37eca0df785f3b">mult</a> (const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:adef8642cb0177287cd37eca0df785f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this by <code>right</code> to create a new, permuted tensor.  <a href="#adef8642cb0177287cd37eca0df785f3b">More...</a><br /></td></tr>
<tr class="separator:adef8642cb0177287cd37eca0df785f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfa298ee50c84dc91f82ce289f9ca1"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a90cfa298ee50c84dc91f82ce289f9ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a90cfa298ee50c84dc91f82ce289f9ca1">mult</a> (const Right &amp;right, const Scalar factor) const </td></tr>
<tr class="memdesc:a90cfa298ee50c84dc91f82ce289f9ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and multiply this by <code>right</code> to create a new tensor.  <a href="#a90cfa298ee50c84dc91f82ce289f9ca1">More...</a><br /></td></tr>
<tr class="separator:a90cfa298ee50c84dc91f82ce289f9ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53baa0d37122a78b4610f621aa55b53"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae53baa0d37122a78b4610f621aa55b53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ae53baa0d37122a78b4610f621aa55b53">mult</a> (const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:ae53baa0d37122a78b4610f621aa55b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and multiply this by <code>right</code> to create a new, permuted tensor.  <a href="#ae53baa0d37122a78b4610f621aa55b53">More...</a><br /></td></tr>
<tr class="separator:ae53baa0d37122a78b4610f621aa55b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdd5ac100129cb2858243e3d6e301d1"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aebdd5ac100129cb2858243e3d6e301d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aebdd5ac100129cb2858243e3d6e301d1">mult_to</a> (const Right &amp;right)</td></tr>
<tr class="memdesc:aebdd5ac100129cb2858243e3d6e301d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply this tensor by <code>right</code>.  <a href="#aebdd5ac100129cb2858243e3d6e301d1">More...</a><br /></td></tr>
<tr class="separator:aebdd5ac100129cb2858243e3d6e301d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aa389491689d55c015492e5b2f139e"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a18aa389491689d55c015492e5b2f139e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a18aa389491689d55c015492e5b2f139e">mult_to</a> (const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:a18aa389491689d55c015492e5b2f139e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and multiply this tensor by <code>right</code>.  <a href="#a18aa389491689d55c015492e5b2f139e">More...</a><br /></td></tr>
<tr class="separator:a18aa389491689d55c015492e5b2f139e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab926f3ab44af8a4bd78bdc67b94495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aeab926f3ab44af8a4bd78bdc67b94495">neg</a> () const </td></tr>
<tr class="memdesc:aeab926f3ab44af8a4bd78bdc67b94495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negated copy of this tensor.  <a href="#aeab926f3ab44af8a4bd78bdc67b94495">More...</a><br /></td></tr>
<tr class="separator:aeab926f3ab44af8a4bd78bdc67b94495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed59e3cfabb7ad80486e28d2f6d77a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a5ed59e3cfabb7ad80486e28d2f6d77a6">neg</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a5ed59e3cfabb7ad80486e28d2f6d77a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negated and permuted copy of this tensor.  <a href="#a5ed59e3cfabb7ad80486e28d2f6d77a6">More...</a><br /></td></tr>
<tr class="separator:a5ed59e3cfabb7ad80486e28d2f6d77a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f298b826efdc604b419d2da13d4a862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a0f298b826efdc604b419d2da13d4a862">neg_to</a> ()</td></tr>
<tr class="memdesc:a0f298b826efdc604b419d2da13d4a862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate elements of this tensor.  <a href="#a0f298b826efdc604b419d2da13d4a862">More...</a><br /></td></tr>
<tr class="separator:a0f298b826efdc604b419d2da13d4a862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a87ec615071d970a3d449207d5dfe2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7a87ec615071d970a3d449207d5dfe2d">conj</a> () const </td></tr>
<tr class="memdesc:a7a87ec615071d970a3d449207d5dfe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of this tensor.  <a href="#a7a87ec615071d970a3d449207d5dfe2d">More...</a><br /></td></tr>
<tr class="separator:a7a87ec615071d970a3d449207d5dfe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7b1d9d929ece6c2f0c2db33c1a9497"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9a7b1d9d929ece6c2f0c2db33c1a9497"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a7b1d9d929ece6c2f0c2db33c1a9497">conj</a> (const Scalar factor) const </td></tr>
<tr class="memdesc:a9a7b1d9d929ece6c2f0c2db33c1a9497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of this tensor.  <a href="#a9a7b1d9d929ece6c2f0c2db33c1a9497">More...</a><br /></td></tr>
<tr class="separator:a9a7b1d9d929ece6c2f0c2db33c1a9497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d7b24611c413f71ad800501cbdd402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad1d7b24611c413f71ad800501cbdd402">conj</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:ad1d7b24611c413f71ad800501cbdd402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of this tensor.  <a href="#ad1d7b24611c413f71ad800501cbdd402">More...</a><br /></td></tr>
<tr class="separator:ad1d7b24611c413f71ad800501cbdd402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517e4fec7443d48d2dbb38e0849bc6fd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a517e4fec7443d48d2dbb38e0849bc6fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a517e4fec7443d48d2dbb38e0849bc6fd">conj</a> (const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) const </td></tr>
<tr class="memdesc:a517e4fec7443d48d2dbb38e0849bc6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of this tensor.  <a href="#a517e4fec7443d48d2dbb38e0849bc6fd">More...</a><br /></td></tr>
<tr class="separator:a517e4fec7443d48d2dbb38e0849bc6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ada2b7db72107f273a04394bdccac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#af3ada2b7db72107f273a04394bdccac5">conj_to</a> ()</td></tr>
<tr class="memdesc:af3ada2b7db72107f273a04394bdccac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate this tensor.  <a href="#af3ada2b7db72107f273a04394bdccac5">More...</a><br /></td></tr>
<tr class="separator:af3ada2b7db72107f273a04394bdccac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184678a6a02973c2a2de3ee08354855e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a184678a6a02973c2a2de3ee08354855e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a184678a6a02973c2a2de3ee08354855e">conj_to</a> (const Scalar factor)</td></tr>
<tr class="memdesc:a184678a6a02973c2a2de3ee08354855e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex conjugate and scale this tensor.  <a href="#a184678a6a02973c2a2de3ee08354855e">More...</a><br /></td></tr>
<tr class="separator:a184678a6a02973c2a2de3ee08354855e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4469d294904c2fbe99d4a8e5ab1b990"><td class="memTemplParams" colspan="2">template&lt;typename U , typename AU &gt; </td></tr>
<tr class="memitem:ad4469d294904c2fbe99d4a8e5ab1b990"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#ad4469d294904c2fbe99d4a8e5ab1b990">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;other, const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_helper) const </td></tr>
<tr class="memdesc:ad4469d294904c2fbe99d4a8e5ab1b990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract this tensor with <code>other</code>.  <a href="#ad4469d294904c2fbe99d4a8e5ab1b990">More...</a><br /></td></tr>
<tr class="separator:ad4469d294904c2fbe99d4a8e5ab1b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23842cadbb7bc0cb031c3f16312cba"><td class="memTemplParams" colspan="2">template&lt;typename U , typename AU , typename V , typename AV &gt; </td></tr>
<tr class="memitem:a4f23842cadbb7bc0cb031c3f16312cba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a4f23842cadbb7bc0cb031c3f16312cba">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; V, AV &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_helper)</td></tr>
<tr class="memdesc:a4f23842cadbb7bc0cb031c3f16312cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract two tensors and store the result in this tensor.  <a href="#a4f23842cadbb7bc0cb031c3f16312cba">More...</a><br /></td></tr>
<tr class="separator:a4f23842cadbb7bc0cb031c3f16312cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0531455387af89e2c96fa7c9d539c2dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#ab64c1efaee17c30ac1559f18e1eb0e88">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a0531455387af89e2c96fa7c9d539c2dc">trace</a> () const </td></tr>
<tr class="memdesc:a0531455387af89e2c96fa7c9d539c2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized tensor trace.  <a href="#a0531455387af89e2c96fa7c9d539c2dc">More...</a><br /></td></tr>
<tr class="separator:a0531455387af89e2c96fa7c9d539c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f7f71edfbba58b81f9549e79d686f3"><td class="memTemplParams" colspan="2">template&lt;typename ReduceOp , typename JoinOp &gt; </td></tr>
<tr class="memitem:a79f7f71edfbba58b81f9549e79d686f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a79f7f71edfbba58b81f9549e79d686f3">reduce</a> (ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;join_op, const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> identity) const </td></tr>
<tr class="memdesc:a79f7f71edfbba58b81f9549e79d686f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary reduction operation.  <a href="#a79f7f71edfbba58b81f9549e79d686f3">More...</a><br /></td></tr>
<tr class="separator:a79f7f71edfbba58b81f9549e79d686f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac0318ff1b4cfa52c97fea8fc624ce"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename ReduceOp , typename JoinOp , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0cac0318ff1b4cfa52c97fea8fc624ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a0cac0318ff1b4cfa52c97fea8fc624ce">reduce</a> (const Right &amp;other, ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;join_op, const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> identity) const </td></tr>
<tr class="memdesc:a0cac0318ff1b4cfa52c97fea8fc624ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary reduction operation.  <a href="#a0cac0318ff1b4cfa52c97fea8fc624ce">More...</a><br /></td></tr>
<tr class="separator:a0cac0318ff1b4cfa52c97fea8fc624ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f31a873c870ef15b51f0b84fd88e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a11f31a873c870ef15b51f0b84fd88e57">sum</a> () const </td></tr>
<tr class="memdesc:a11f31a873c870ef15b51f0b84fd88e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of elements.  <a href="#a11f31a873c870ef15b51f0b84fd88e57">More...</a><br /></td></tr>
<tr class="separator:a11f31a873c870ef15b51f0b84fd88e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822b996880ecb2364f86d37054b5a6d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a822b996880ecb2364f86d37054b5a6d9">product</a> () const </td></tr>
<tr class="memdesc:a822b996880ecb2364f86d37054b5a6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of elements.  <a href="#a822b996880ecb2364f86d37054b5a6d9">More...</a><br /></td></tr>
<tr class="separator:a822b996880ecb2364f86d37054b5a6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa56a7afa750fc69a3dd3080b1f82880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#aaa56a7afa750fc69a3dd3080b1f82880">squared_norm</a> () const </td></tr>
<tr class="memdesc:aaa56a7afa750fc69a3dd3080b1f82880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of vector 2-norm.  <a href="#aaa56a7afa750fc69a3dd3080b1f82880">More...</a><br /></td></tr>
<tr class="separator:aaa56a7afa750fc69a3dd3080b1f82880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ca135b8db345c20bb54f470ee59747"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a43ca135b8db345c20bb54f470ee59747">norm</a> () const </td></tr>
<tr class="memdesc:a43ca135b8db345c20bb54f470ee59747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm.  <a href="#a43ca135b8db345c20bb54f470ee59747">More...</a><br /></td></tr>
<tr class="separator:a43ca135b8db345c20bb54f470ee59747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501443876637e48d240c928ebe1ff8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7501443876637e48d240c928ebe1ff8a">min</a> () const </td></tr>
<tr class="memdesc:a7501443876637e48d240c928ebe1ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element.  <a href="#a7501443876637e48d240c928ebe1ff8a">More...</a><br /></td></tr>
<tr class="separator:a7501443876637e48d240c928ebe1ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6c9a21709defa9e613881f86cbafe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a7a6c9a21709defa9e613881f86cbafe5">max</a> () const </td></tr>
<tr class="memdesc:a7a6c9a21709defa9e613881f86cbafe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element.  <a href="#a7a6c9a21709defa9e613881f86cbafe5">More...</a><br /></td></tr>
<tr class="separator:a7a6c9a21709defa9e613881f86cbafe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a35b92da2f518aed92c6f7d15454d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a137a35b92da2f518aed92c6f7d15454d">abs_min</a> () const </td></tr>
<tr class="memdesc:a137a35b92da2f518aed92c6f7d15454d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute minimum element.  <a href="#a137a35b92da2f518aed92c6f7d15454d">More...</a><br /></td></tr>
<tr class="separator:a137a35b92da2f518aed92c6f7d15454d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40984346a8bc0c1a3da458bb9fa09137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a40984346a8bc0c1a3da458bb9fa09137">abs_max</a> () const </td></tr>
<tr class="memdesc:a40984346a8bc0c1a3da458bb9fa09137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element.  <a href="#a40984346a8bc0c1a3da458bb9fa09137">More...</a><br /></td></tr>
<tr class="separator:a40984346a8bc0c1a3da458bb9fa09137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53759a4be0ec7b9df37339228b3b8aee"><td class="memTemplParams" colspan="2">template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a53759a4be0ec7b9df37339228b3b8aee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html#a53759a4be0ec7b9df37339228b3b8aee">dot</a> (const Right &amp;other) const </td></tr>
<tr class="memdesc:a53759a4be0ec7b9df37339228b3b8aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product.  <a href="#a53759a4be0ec7b9df37339228b3b8aee">More...</a><br /></td></tr>
<tr class="separator:a53759a4be0ec7b9df37339228b3b8aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt;<br />
class TiledArray::Tensor&lt; T, A &gt;</h3>

<p>An N-dimensional tensor object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the value type of this tensor </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type for the data </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="foreach_8h_source.html#l00040">40</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a99586ecbed993b0a7dc33ca231131d15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a99586ecbed993b0a7dc33ca231131d15">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00040">40</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a643a4203b62aa1e370d6995aad071f40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element const iterator type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00048">48</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13b3ca56e0bf2b27a8632d1598c1d526"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::const_pointer <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element const pointer type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00045">45</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8b80372c9a8886e30106219eca40b66c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::const_reference <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element reference type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00043">43</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a104deacaf44eb9d0fa97b32c59d53cc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::difference_type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a104deacaf44eb9d0fa97b32c59d53cc5">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00046">46</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c3a6bcdbeae5dec3343d6ae28df8284"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element iterator type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00047">47</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc2e1a62ce018f90f552510d29fd9ed2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt;T&gt;::type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the numeric type that supports T </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00050">50</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ace0c51fc37253afe287423fe5971da8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::pointer <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element pointer type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00044">44</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a6953592a083f07bc6132a571a9d767"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_range.html">Range</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> range type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00038">38</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac8dc24eca41c8655a8871e838183e24b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::reference <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element reference type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00042">42</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a3ff935ffdd12ded18a1041a0a18faf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt;T&gt;::type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the scalar type that supports T </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00052">52</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4f44171ea91af2bb2a393ca06d5af662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_range.html#a8763d983047391957211be4b8b319649">range_type::size_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size type </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00039">39</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5608ebaf867dc02438adf9475a5ed719"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, A&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00037">37</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab64c1efaee17c30ac1559f18e1eb0e88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::value_type <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html#ab64c1efaee17c30ac1559f18e1eb0e88">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array element type. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00041">41</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a52053224a88d9d8478805d7c5f89ec59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00109">109</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a414d8ebf6c834c5500ca5b5408708f58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00110">110</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a437e6fa337043142c4be807cd46bf5d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00111">111</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a709fe578d55e8ee8c1e187d6f1a1ad4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::~<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00112">112</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff000b8850b2992ff765eb3f8f116632"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct tensor. </p>
<p>Construct a tensor with a range equal to <code>range</code>. The data is uninitialized. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range of the tensor </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00127">127</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad06d56e445f36d572109abbafc1a32e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Value , typename std::enable_if&lt; std::is_same&lt; Value, value_type &gt;::value &amp;&amp;                       detail::is_tensor&lt; Value &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a tensor with a fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>An array with the size of of each dimension </td></tr>
    <tr><td class="paramname">value</td><td>The value of the tensor elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00141">141</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad06d56e445f36d572109abbafc1a32e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Value , typename std::enable_if&lt; detail::is_numeric&lt; Value &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a tensor with a fill value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>An array with the size of of each dimension </td></tr>
    <tr><td class="paramname">value</td><td>The value of the tensor elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00156">156</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a04249ef7d49a620988dec54b296f1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InIter , typename std::enable_if&lt; TiledArray::detail::is_input_iterator&lt; InIter &gt;::value &amp;&amp;                                       !std::is_pointer&lt; InIter &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an evaluated tensor. </p>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00166">166</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad46913eeb18eceebf619a6d73698704a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00176">176</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8514a8061acfd51b3551dd42fd54c0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &amp;&amp;                                       !std::is_same&lt; T1, Tensor_ &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a copy of a tensor interface object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to be copied </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00189">189</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aefa7eb63040aed24a687003d36ebe23e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a permuted tensor copy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to be copied </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the copy </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00206">206</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af833692ef1ebff1764c2cabbebd1e2f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value                                                           &amp;&amp;!std::is_same&lt; typename std::decay&lt; Op &gt;::type,                                                           Permutation &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and modify the data from <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00226">226</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1669d83e4b46727bebe493178cdefd2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy, modify, and permute the data from <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00240">240</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4212439f4e33716dabdf6ecafb626991"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy and modify the data from <code>left</code>, and <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00256">256</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a50dacb073f515e83be7e11d0b063a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename Op , typename std::enable_if&lt; is_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy, modify, and permute the data from <code>left</code>, and <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>A tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>A tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>An element-wise operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
    <tr><td class="paramname">op</td><td>The element-wise operation </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the arguments </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00273">273</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a40984346a8bc0c1a3da458bb9fa09137"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::abs_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute maximum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum elements of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01403">1403</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a137a35b92da2f518aed92c6f7d15454d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::abs_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute minimum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum elements of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01392">1392</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1907f43fcdcc43e0ae4f9c143767bfb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> this and <code>other</code> to construct a new tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00679">679</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="adfa67535e35bbda4182bcec15a876967"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> this and <code>other</code> to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00694">694</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8bf8e32d8aa56a477dba7bf52b38b66b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and add this and <code>other</code> to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code>, scaled by <code>factor</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00711">711</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa977f933291df14c39009736c59a8b0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and add this and <code>other</code> to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>other</code>, scaled by <code>factor</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00729">729</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af39b998b0ce99a03924f257eb103e2dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant to a copy of this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be added to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>value</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00742">742</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad5d32834339f136a79ab7072aeab09b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant to a permuted copy of this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be added to this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the sum of the elements of <code>this</code> and <code>value</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00753">753</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3dfff2aa620117307ba085091693a768"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> <code>other</code> to this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00765">765</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91c2a4263360a58dbaba16cb434e2794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> <code>other</code> to this tensor, and scale the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be added to this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00780">780</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad959a4848795f8352fd9dfd25631948a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::add_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant to this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00790">790</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa403b68eb3e307d65aab0da3900478d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first data element </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00383">383</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6cb2732327b1e80aae0f82e590824642"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the first data element </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00388">388</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8005d292051062ad3892265e28010a4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a binary, element wise operation to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right-hand argument in the binary operation </td></tr>
    <tr><td class="paramname">op</td><td>The binary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> of the new tensor is equal to <code>op(*this[i],other[i])</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00553">553</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1e141a35f0d8a7cc57c009b6b524411c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a binary, element wise operation to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right-hand argument in the binary operation </td></tr>
    <tr><td class="paramname">op</td><td>The binary, element-wise operation </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> of the new tensor is equal to <code>op(*this[i],other[i])</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00568">568</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a977e3d0ee7069ad9541881621b9208d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00475">475</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea400289d232690060434021d47c2ea7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00482">482</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a058e9accdb3e2f47848566305d4c8848"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00492">492</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ac8b290992aa2d73700a46bd793cbe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;const T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00499">499</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae9add7b831aa08fadab92ce9188edbb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00279">279</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a87ec615071d970a3d449207d5dfe2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated copy of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of this tensor that contains the complex conjugate the values </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01043">1043</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a7b1d9d929ece6c2f0c2db33c1a9497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated and scaled copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of this tensor that contains the scaled complex conjugate the values </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01056">1056</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad1d7b24611c413f71ad800501cbdd402"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated and permuted copy of this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of this tensor that contains the complex conjugate values </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01066">1066</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a517e4fec7443d48d2dbb38e0849bc6fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a complex conjugated, scaled, and permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of this tensor that contains the complex conjugate values </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01080">1080</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3ada2b7db72107f273a04394bdccac5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj_to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex conjugate this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01088">1088</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a184678a6a02973c2a2de3ee08354855e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::conj_to </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complex conjugate and scale this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01100">1100</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4598d2ea75c448d596533476acee21f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a13b3ca56e0bf2b27a8632d1598c1d526">const_pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data direct access. </p>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the tensor data </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00407">407</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a372ad5542cb41792eb72a6e1da63b6b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ace0c51fc37253afe287423fe5971da8c">pointer</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data direct access. </p>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the tensor data </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00412">412</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53759a4be0ec7b9df37339228b3b8aee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector dot product. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The right-hand tensor to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product of the this and <code>other</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01418">1418</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a26c81ab595b2582f7542b9a24f722d0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the tensor is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this tensor was default constructed (contains no data), otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00418">418</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79e7557a4c1b87b7405dcf0374bca34a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a643a4203b62aa1e370d6995aad071f40">const_iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the last data element </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00393">393</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a388e96f2343d855abff091534612abbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a7c3a6bcdbeae5dec3343d6ae28df8284">iterator</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator factory. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the last data element </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00400">400</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad4469d294904c2fbe99d4a8e5ab1b990"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename AU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::gemm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;&#160;</td>
          <td class="paramname"><em>gemm_helper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contract this tensor with <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The other tensor element type </td></tr>
    <tr><td class="paramname">AU</td><td>The other tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor that will be contracted with this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">gemm_helper</td><td>The *GEMM operation meta data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor which is the result of contracting this tensor with <code>other</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>other</code> is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01119">1119</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4f23842cadbb7bc0cb031c3f16312cba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename AU , typename V , typename AV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::gemm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; U, AU &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; V, AV &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;&#160;</td>
          <td class="paramname"><em>gemm_helper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contract two tensors and store the result in this tensor. </p>
<p>Gemm is limited to matrix like contractions. For example, the following contractions are supported: </p><div class="fragment"><div class="line">C[a,b] = A[a,i,j] * B[i,j,b]</div>
<div class="line">C[a,b] = A[a,i,j] * B[b,i,j]</div>
<div class="line">C[a,b] = A[i,j,a] * B[i,j,b]</div>
<div class="line">C[a,b] = A[i,j,a] * B[b,i,j]</div>
<div class="line"></div>
<div class="line">C[a,b,c,d] = A[a,b,i,j] * B[i,j,c,d]</div>
<div class="line">C[a,b,c,d] = A[a,b,i,j] * B[c,d,i,j]</div>
<div class="line">C[a,b,c,d] = A[i,j,a,b] * B[i,j,c,d]</div>
<div class="line">C[a,b,c,d] = A[i,j,a,b] * B[c,d,i,j]</div>
</div><!-- fragment --><p> Notice that in the above contractions, the inner and outer indices of the arguments for exactly two contiguous groups in each tensor and that each group is in the same order in all tensors. That is, the indices of the tensors must fit the one of the following patterns: </p><div class="fragment"><div class="line">C[M...,N...] = A[M...,K...] * B[K...,N...]</div>
<div class="line">C[M...,N...] = A[M...,K...] * B[N...,K...]</div>
<div class="line">C[M...,N...] = A[K...,M...] * B[K...,N...]</div>
<div class="line">C[M...,N...] = A[K...,M...] * B[N...,K...]</div>
</div><!-- fragment --><p> This allows use of optimized BLAS functions to evaluate tensor contractions. <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> contractions that do not fit this pattern require one or more tensor permutation so that the tensors fit the required pattern. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The left-hand tensor element type </td></tr>
    <tr><td class="paramname">AU</td><td>The left-hand tensor allocator type </td></tr>
    <tr><td class="paramname">V</td><td>The right-hand tensor element type </td></tr>
    <tr><td class="paramname">AV</td><td>The right-hand tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor that will be contracted </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor that will be contracted </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">gemm_helper</td><td>The *GEMM operation meta data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor which is the result of contracting this tensor with other </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01194">1194</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a272585651b1233bb8f90d23c88a12c61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Op , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::inplace_binary </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a binary, element wise operation to modify this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The right-hand argument in the binary operation </td></tr>
    <tr><td class="paramname">op</td><td>The binary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>other</code> is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of this tensor is not equal to the range of <code>other</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this and <code>other</code> are the same. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00586">586</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af23df0d855cd33e6e977bd39e780ca9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::inplace_unary </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a unary, element wise operation to modify this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The unary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The unary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00624">624</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a6c9a21709defa9e613881f86cbafe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum elements of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01383">1383</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7501443876637e48d240c928ebe1ff8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum element. </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum elements of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01374">1374</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee21e15e1549187df9ea498ec3c6f0d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply this by <code>right</code> to create a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00926">926</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="adef8642cb0177287cd37eca0df785f3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply this by <code>right</code> to create a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00941">941</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90cfa298ee50c84dc91f82ce289f9ca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and multiply this by <code>right</code> to create a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00958">958</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae53baa0d37122a78b4610f621aa55b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and multiply this by <code>right</code> to create a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the product of the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00976">976</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aebdd5ac100129cb2858243e3d6e301d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply this tensor by <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00991">991</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18aa389491689d55c015492e5b2f139e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::mult_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and multiply this tensor by <code>right</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be multiplied by this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01007">1007</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeab926f3ab44af8a4bd78bdc67b94495"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::neg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a negated copy of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A new tensor that contains the negative values of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01018">1018</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5ed59e3cfabb7ad80486e28d2f6d77a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::neg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a negated and permuted copy of this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor that contains the negative values of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01026">1026</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0f298b826efdc604b419d2da13d4a862"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::neg_to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negate elements of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01034">1034</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43ca135b8db345c20bb54f470ee59747"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector 2-norm. </p>
<dl class="section return"><dt>Returns</dt><dd>The vector norm of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01367">1367</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5a1769b4826601efae3635a37829c369"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;...&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>index type pack </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index pack </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00363">363</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae9f5644bd071526859633f0a6e3db525"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;...&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>index type pack </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index pack </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00374">374</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5bb641cc67d36bf3e87b59eaf10a2dff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00113">113</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a375a995714597079b944907eb89245bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00117">117</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a864d3eed3caa265526a36b1e042aaeb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1 , typename std::enable_if&lt; is_tensor&lt; T1 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00291">291</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8839f1a20dcca6301f1f2b93ddfdb6fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The element at the <code>i</code> position. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00315">315</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a63c83be5dd7fcb13e57d0030452371ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The element at the <code>i</code> position. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00325">325</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9313a1040cdac7d200e1c57c2ec7b34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Index , typename std::enable_if&lt;                                          !std::is_integral&lt; Index &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a8b80372c9a8886e30106219eca40b66c">const_reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The element at the <code>i</code> position. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00339">339</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a369f15590536ef934aadcf7ca3e81c39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Index , typename std::enable_if&lt;                                  !std::is_integral&lt; Index &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ac8dc24eca41c8655a8871e838183e24b">reference</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Element accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The element at the <code>i</code> position. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00352">352</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa975640407d4460e99f85ca41398f4d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::permute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00511">511</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a822b996880ecb2364f86d37054b5a6d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::product </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Product of elements. </p>
<dl class="section return"><dt>Returns</dt><dd>The product of all elements of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01347">1347</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6521f4ce917ca6a41bb3ada9ef3b4d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tiled_array_1_1_tensor.html#a9a6953592a083f07bc6132a571a9d767">range_type</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> range object accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The tensor range object </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00301">301</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a79f7f71edfbba58b81f9549e79d686f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ReduceOp , typename JoinOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>identity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary reduction operation. </p>
<p>Perform an element-wise reduction of the tile data. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The join operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The join result operation </td></tr>
    <tr><td class="paramname">identity</td><td>The identity value of the reduction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01310">1310</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cac0318ff1b4cfa52c97fea8fc624ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename ReduceOp , typename JoinOp , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::reduce </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>identity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary reduction operation. </p>
<p>Perform an element-wise reduction of the tile data. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand argument tensor type </td></tr>
    <tr><td class="paramname">ReduceOp</td><td>The reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The join operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The right-hand argument of the binary reduction </td></tr>
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The join result operation </td></tr>
    <tr><td class="paramname">identity</td><td>The identity value of the reduction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01329">1329</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a39a3f4ca9ea64d150d9501acec762090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a scaled copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements of this tensor are scaled by <code>factor</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00639">639</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5eb2b4d1f49ea064a738f0ab8410cbd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a scaled and permuted copy of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements of this tensor are scaled by <code>factor</code> and permuted </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00653">653</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19ee5e211e0a606f194bde6699b9d373"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::scale_to </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00665">665</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18da463545a06f07288ea5c8439c63a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Archive , typename std::enable_if&lt;                                  madness::archive::is_output_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output serialization function. </p>
<p>This function enables serialization within MADNESS </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The output archive type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ar</td><td>The output archive </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00428">428</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a18da463545a06f07288ea5c8439c63a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Archive , typename std::enable_if&lt;                                  madness::archive::is_input_archive&lt; Archive &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input serialization function. </p>
<p>This function enables serialization within MADNESS </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Archive</td><td>The input archive type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ar</td><td>The input archive </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00446">446</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="afef47b114ae4c0964c08c90e227a37f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>bound_shift</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the lower and upper bound of this range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The shift array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound_shift</td><td>The shift to be applied to the tensor range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted copy of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00534">534</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf08314a6ce26804634a40a5c6a3d67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::shift_to </td>
          <td>(</td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>bound_shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the lower and upper bound of this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>The shift array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound_shift</td><td>The shift to be applied to the tensor range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00522">522</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae424ed4ba8d09a72a8ffa824e603b081"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a4f44171ea91af2bb2a393ca06d5af662">size_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> dimension size accessor. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00308">308</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaa56a7afa750fc69a3dd3080b1f82880"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a9a3ff935ffdd12ded18a1041a0a18faf">scalar_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::squared_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square of vector 2-norm. </p>
<dl class="section return"><dt>Returns</dt><dd>The vector norm of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01356">1356</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4c6d59e8758cac8cb6501246bff199c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract this and <code>right</code> to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00804">804</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a142a97cab79143c6928611266b9b6a05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract this and <code>right</code> to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00819">819</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac158b1622dbc171580ed8531f7d36986"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and subtract this and <code>right</code> to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00836">836</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5c10ac9ab93b55610638901ac58ac8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and subtract this and <code>right</code> to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>right</code>, scaled by <code>factor</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00854">854</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8b4d88e87f80f0cd72724ce1738ef97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a constant from a copy of this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>value</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00866">866</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a70f9d052179f9441987e184d0082ed75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a constant from a permuted copy of this tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The constant to be subtracted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tensor where the elements are the different between the elements of <code>this</code> and <code>value</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00876">876</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6732b912c2ce09fcf078d814f0ca8cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract <code>right</code> from this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00887">887</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9a421cd397418787307aac0d453a3d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Right , typename Scalar , typename std::enable_if&lt; is_tensor&lt; Right &gt;::value &amp;&amp;                       detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt_to </td>
          <td>(</td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract <code>right</code> from and scale this tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The tensor that will be subtracted from this tensor </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00903">903</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e44d414e05fe2fe09648ad9856ade68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a>&amp; <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::subt_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract a constant from this tensor. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00912">912</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a11f31a873c870ef15b51f0b84fd88e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#abc2e1a62ce018f90f552510d29fd9ed2">numeric_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of elements. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements of this tensor </dd></dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01338">1338</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7f33f8afac53cb621c12cac5e1d256a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap tensor data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The tensor to swap with this </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00469">469</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0531455387af89e2c96fa7c9d539c2dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#ab64c1efaee17c30ac1559f18e1eb0e88">value_type</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generalized tensor trace. </p>
<p>This function will compute the sum of the hyper diagonal elements of tensor. </p><dl class="section return"><dt>Returns</dt><dd>The trace of this tensor </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01257">1257</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a69e6422efc9c251ed076b6602b484e97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::unary </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a unary, element wise operation to construct a new tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The unary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The unary, element-wise operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> of the new tensor is equal to <code>op(*this[i])</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00599">599</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a207755b3eca04e865587f72ecbdd6477"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A = Eigen::aligned_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html#a5608ebaf867dc02438adf9475a5ed719">Tensor_</a> <a class="el" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor</a>&lt; T, A &gt;::unary </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a unary, element wise operation to construct a new, permuted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The unary operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The unary operation </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to this tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted tensor with elements that have been modified by <code>op</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When this tensor is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>The dimension of <code>perm</code> does not match that of this tensor. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l00613">613</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>TiledArray/conversions/<a class="el" href="foreach_8h_source.html">foreach.h</a></li>
<li>TiledArray/tensor/<a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li><li class="navelem"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a></li>
    <li class="footer">Generated on Fri Apr 29 2016 12:03:07 for TiledArray by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
