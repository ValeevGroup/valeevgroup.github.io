<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>TiledArray: TiledArray Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TiledArray
   &#160;<span id="projectnumber">0.5.0-alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_tiled_array.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_tiled_array_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1expressions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1expressions.html">expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1symmetry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1symmetry.html">symmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_abs_max_reduction.html">AbsMaxReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maxabs tile reduction.  <a href="class_tiled_array_1_1_abs_max_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_abs_min_reduction.html">AbsMinReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minabs tile reduction.  <a href="class_tiled_array_1_1_abs_min_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> addition operation.  <a href="class_tiled_array_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> that references a subblock of another range.  <a href="class_tiled_array_1_1_block_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_conjugate_gradient_solver.html">ConjugateGradientSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_contract_reduce.html">ContractReduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and reduce operation.  <a href="class_tiled_array_1_1_contract_reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_contract_reduce_3_01_left_00_01_right_00_01_tiled_array_1_1detail_1_1_compae1caba9c10fe0eedf8f44f9a1b46f64.html">ContractReduce&lt; Left, Right, TiledArray::detail::ComplexConjugate&lt; Scalar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and reduce operation.  <a href="class_tiled_array_1_1_contract_reduce_3_01_left_00_01_right_00_01_tiled_array_1_1detail_1_1_compae1caba9c10fe0eedf8f44f9a1b46f64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_contract_reduce_3_01_left_00_01_right_00_01_tiled_array_1_1detail_1_1_comp0c4473f6e5cad36f249fe9ac8ed5134f.html">ContractReduce&lt; Left, Right, TiledArray::detail::ComplexConjugate&lt; void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and reduce operation.  <a href="class_tiled_array_1_1_contract_reduce_3_01_left_00_01_right_00_01_tiled_array_1_1detail_1_1_comp0c4473f6e5cad36f249fe9ac8ed5134f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_contract_reduce_base.html">ContractReduceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and reduce base.  <a href="class_tiled_array_1_1_contract_reduce_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense shape of an array.  <a href="class_tiled_array_1_1_dense_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_d_i_i_s.html">DIIS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_d_i_i_s.html" title="DIIS (``direct inversion of iterative subspace&#39;&#39;) extrapolation. ">DIIS</a> (``direct inversion of iterative subspace'') extrapolation.  <a href="class_tiled_array_1_1_d_i_i_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declarations.  <a href="class_tiled_array_1_1_dist_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dot_reduction.html">DotReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product tile reduction.  <a href="class_tiled_array_1_1_dot_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1eval__trait.html">eval_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the object type used in the evaluation of tensor expressions.  <a href="struct_tiled_array_1_1eval__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1eval__trait_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__typc182ea334e8bb9605ae2787a9eece667.html">eval_trait&lt; T, typename std::enable_if&lt; detail::is_type&lt; typename T::eval_type &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the object type used in the evaluation of tensor expressions.  <a href="struct_tiled_array_1_1eval__trait_3_01_t_00_01typename_01std_1_1enable__if_3_01detail_1_1is__typc182ea334e8bb9605ae2787a9eece667.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_irrep.html">Irrep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_irrep.html" title="Irrep of an  symmetric group. ">Irrep</a> of an <img class="formulaInl" alt="$ S_n $" src="form_66.png"/> symmetric group.  <a href="class_tiled_array_1_1_irrep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__consumable__tile.html">is_consumable_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumable tile type trait.  <a href="struct_tiled_array_1_1is__consumable__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__consumable__tile_3_01_zero_tensor_01_4.html">is_consumable_tile&lt; ZeroTensor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense.html">is_dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect dense shape types.  <a href="struct_tiled_array_1_1is__dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense_3_01_dense_shape_01_4.html">is_dense&lt; DenseShape &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense_3_01_dist_array_3_01_tile_00_01_policy_01_4_01_4.html">is_dense&lt; DistArray&lt; Tile, Policy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__lazy__tile.html">is_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect lazy evaluation tiles.  <a href="struct_tiled_array_1_1is__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__lazy__tile_3_01_dist_array_3_01_tile_00_01_policy_01_4_01_4.html">is_lazy_tile&lt; DistArray&lt; Tile, Policy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_max_reduction.html">MaxReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum tile reduction.  <a href="class_tiled_array_1_1_max_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_min_reduction.html">MinReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum tile reduction.  <a href="class_tiled_array_1_1_min_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_mult.html">Mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> multiplication operation.  <a href="class_tiled_array_1_1_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_neg.html">Neg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> negation operation.  <a href="class_tiled_array_1_1_neg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_noop.html">Noop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> no operation (noop)  <a href="class_tiled_array_1_1_noop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> of a sequence of objects indexed by base-0 indices.  <a href="class_tiled_array_1_1_permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_pmap.html">Pmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process map.  <a href="class_tiled_array_1_1_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_product_reduction.html">ProductReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> product reduction.  <a href="class_tiled_array_1_1_product_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (hyperrectangular) interval on <img class="formulaInl" alt="$ Z^n $" src="form_56.png"/>, space of integer n-indices.  <a href="class_tiled_array_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal.html">Scal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scaling operation.  <a href="class_tiled_array_1_1_scal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_add.html">ScalAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scale-addition operation.  <a href="class_tiled_array_1_1_scal_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_mult.html">ScalMult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scale-multiplication operation.  <a href="class_tiled_array_1_1_scal_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_shift.html">ScalShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> shift operation.  <a href="class_tiled_array_1_1_scal_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_subt.html">ScalSubt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scale-subtraction operation.  <a href="class_tiled_array_1_1_scal_subt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_shift.html">Shift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> shift operation.  <a href="class_tiled_array_1_1_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary sparse shape.  <a href="class_tiled_array_1_1_sparse_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_squared_norm_reduction.html">SquaredNormReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared norm tile reduction.  <a href="class_tiled_array_1_1_squared_norm_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_subt.html">Subt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> subtraction operation.  <a href="class_tiled_array_1_1_subt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sum_reduction.html">SumReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> sum reduction.  <a href="class_tiled_array_1_1_sum_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional tensor object.  <a href="class_tiled_array_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional shallow copy wrapper for tile objects.  <a href="class_tiled_array_1_1_tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> data of an N-dimensional, tiled tensor.  <a href="class_tiled_array_1_1_tiled_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_trace_reduction.html">TraceReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> trace reduction.  <a href="class_tiled_array_1_1_trace_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_zero_tensor.html">ZeroTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place-holder object for a zero tensor.  <a href="struct_tiled_array_1_1_zero_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac5db88c965b8d32f1f72d37d3dc3561c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac5db88c965b8d32f1f72d37d3dc3561c">EigenMatrixXd</a></td></tr>
<tr class="separator:ac5db88c965b8d32f1f72d37d3dc3561c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf44d8771941244661bf77cf07069e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aacdf44d8771941244661bf77cf07069e">EigenMatrixXf</a></td></tr>
<tr class="separator:aacdf44d8771941244661bf77cf07069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598c53efb66f9c18b8a6b5bcfbeaf8f3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a598c53efb66f9c18b8a6b5bcfbeaf8f3">EigenMatrixXcd</a></td></tr>
<tr class="separator:a598c53efb66f9c18b8a6b5bcfbeaf8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde89f3f1e4ba23ddf9ce7b6e2db088f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; float &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adde89f3f1e4ba23ddf9ce7b6e2db088f">EigenMatrixXcf</a></td></tr>
<tr class="separator:adde89f3f1e4ba23ddf9ce7b6e2db088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d1d4be6c1d3cef049c42490778da56"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae5d1d4be6c1d3cef049c42490778da56">EigenMatrixXi</a></td></tr>
<tr class="separator:ae5d1d4be6c1d3cef049c42490778da56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa83a358322961f1da1b50d5e28ae0ea"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afa83a358322961f1da1b50d5e28ae0ea">EigenMatrixXl</a></td></tr>
<tr class="separator:afa83a358322961f1da1b50d5e28ae0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa783ea4f581c1c1bb75f647d68c65a68"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa783ea4f581c1c1bb75f647d68c65a68">EigenVectorXd</a></td></tr>
<tr class="separator:aa783ea4f581c1c1bb75f647d68c65a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54f8e9145825b6155cf5389a9ee03a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; float, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0c54f8e9145825b6155cf5389a9ee03a">EigenVectorXf</a></td></tr>
<tr class="separator:a0c54f8e9145825b6155cf5389a9ee03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c2ebf917a509ec12deca6a13dd1904"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; double &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a19c2ebf917a509ec12deca6a13dd1904">EigenVectorXcd</a></td></tr>
<tr class="separator:a19c2ebf917a509ec12deca6a13dd1904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe17eddb0710849aa9af552f4f85098"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; float &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abfe17eddb0710849aa9af552f4f85098">EigenVectorXcf</a></td></tr>
<tr class="separator:abfe17eddb0710849aa9af552f4f85098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb38a6b56111826e5b451528b939eb60"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; int, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acb38a6b56111826e5b451528b939eb60">EigenVectorXi</a></td></tr>
<tr class="separator:acb38a6b56111826e5b451528b939eb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5f429338b7707830ce0339ebaf6274"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; long, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aec5f429338b7707830ce0339ebaf6274">EigenVectorXl</a></td></tr>
<tr class="separator:aec5f429338b7707830ce0339ebaf6274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87417c27b1375ed3dacce12f7430a73c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87417c27b1375ed3dacce12f7430a73c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt;</td></tr>
<tr class="separator:a87417c27b1375ed3dacce12f7430a73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a976c8f2da26f51732e5ce811f54ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73a976c8f2da26f51732e5ce811f54ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; typename std::add_const&lt; T &gt;::type, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt;</td></tr>
<tr class="separator:a73a976c8f2da26f51732e5ce811f54ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d2edc4ec73d986edc524386dab1f9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59d2edc4ec73d986edc524386dab1f9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a59d2edc4ec73d986edc524386dab1f9c">TensorView</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;</td></tr>
<tr class="separator:a59d2edc4ec73d986edc524386dab1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1950fa935cff5cb1415b58d822057f23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1950fa935cff5cb1415b58d822057f23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1950fa935cff5cb1415b58d822057f23">TensorConstView</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; typename std::add_const&lt; T &gt;::type, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;</td></tr>
<tr class="separator:a1950fa935cff5cb1415b58d822057f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a673c87e7624e63f641318f610a297"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; double, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac1a673c87e7624e63f641318f610a297">TensorD</a></td></tr>
<tr class="separator:ac1a673c87e7624e63f641318f610a297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58ff1caa878600bc482e36acb64060"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; int, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7f58ff1caa878600bc482e36acb64060">TensorI</a></td></tr>
<tr class="separator:a7f58ff1caa878600bc482e36acb64060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b4522d34881253139d842d7345dcbc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; float, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a43b4522d34881253139d842d7345dcbc">TensorF</a></td></tr>
<tr class="separator:a43b4522d34881253139d842d7345dcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940148a41f1a9b47fabd83511d0ad11f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; long, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a940148a41f1a9b47fabd83511d0ad11f">TensorL</a></td></tr>
<tr class="separator:a940148a41f1a9b47fabd83511d0ad11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4438e1e4fac9c7ed76af5bae4a6aff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; std::complex&lt; double &gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; std::complex&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abe4438e1e4fac9c7ed76af5bae4a6aff">TensorZ</a></td></tr>
<tr class="separator:abe4438e1e4fac9c7ed76af5bae4a6aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac685ca67ab67879d908e57681834604c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; std::complex&lt; float &gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; std::complex&lt; float &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac685ca67ab67879d908e57681834604c">TensorC</a></td></tr>
<tr class="separator:ac685ca67ab67879d908e57681834604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14381436074bbf8eff68427766e395a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14381436074bbf8eff68427766e395a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; T &gt; &gt;, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;</td></tr>
<tr class="separator:a14381436074bbf8eff68427766e395a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25748e8f1dd4d7421925264bbe4905"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0b25748e8f1dd4d7421925264bbe4905">TArrayD</a></td></tr>
<tr class="separator:a0b25748e8f1dd4d7421925264bbe4905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6a345559008046e6785aee9d35f11d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2d6a345559008046e6785aee9d35f11d">TArrayI</a></td></tr>
<tr class="separator:a2d6a345559008046e6785aee9d35f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec85e445a8f0330f135292858a3cb4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aaeec85e445a8f0330f135292858a3cb4">TArrayF</a></td></tr>
<tr class="separator:aaeec85e445a8f0330f135292858a3cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99743650f2570e83f35a0ba1958c9569"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a99743650f2570e83f35a0ba1958c9569">TArrayL</a></td></tr>
<tr class="separator:a99743650f2570e83f35a0ba1958c9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa010edfe058bd83377e3790741e14dee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa010edfe058bd83377e3790741e14dee">TArrayZ</a></td></tr>
<tr class="separator:aa010edfe058bd83377e3790741e14dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea17c71440d5a58110b7ade911cf1102"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; std::complex&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aea17c71440d5a58110b7ade911cf1102">TArrayC</a></td></tr>
<tr class="separator:aea17c71440d5a58110b7ade911cf1102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; T &gt; &gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;</td></tr>
<tr class="separator:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c4ccd3689f4dafb20c6d238690705"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TSpArrayD</a></td></tr>
<tr class="separator:abb0c4ccd3689f4dafb20c6d238690705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd7da1c48d18d477b9d0366e94d9b10"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4dd7da1c48d18d477b9d0366e94d9b10">TSpArrayI</a></td></tr>
<tr class="separator:a4dd7da1c48d18d477b9d0366e94d9b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd8165f08a44cf5a27efca786bee5ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a6bd8165f08a44cf5a27efca786bee5ac">TSpArrayF</a></td></tr>
<tr class="separator:a6bd8165f08a44cf5a27efca786bee5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e13a617d7cc592f38124462d5a853d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a51e13a617d7cc592f38124462d5a853d">TSpArrayL</a></td></tr>
<tr class="separator:a51e13a617d7cc592f38124462d5a853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa157a11e4eb462e70e5fec1411acab8c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa157a11e4eb462e70e5fec1411acab8c">TSpArrayZ</a></td></tr>
<tr class="separator:aa157a11e4eb462e70e5fec1411acab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9caaa3d2c9f944690670df6a1a08ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; std::complex&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#add9caaa3d2c9f944690670df6a1a08ed">TSpArrayC</a></td></tr>
<tr class="separator:add9caaa3d2c9f944690670df6a1a08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf28ccfd580f62de5342a9a1510e22e9"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int, typename Tile  = Tensor&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;, typename Policy  = DensePolicy&gt; </td></tr>
<tr class="memitem:adf28ccfd580f62de5342a9a1510e22e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;</td></tr>
<tr class="separator:adf28ccfd580f62de5342a9a1510e22e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc51ed34e98a417052d745d91994de70"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:afc51ed34e98a417052d745d91994de70"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">size</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:afc51ed34e98a417052d745d91994de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b52c74197023a357e41e93efd8cf0a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a44b52c74197023a357e41e93efd8cf0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a44b52c74197023a357e41e93efd8cf0a">copy</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a44b52c74197023a357e41e93efd8cf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3558ec56f9d00590c35846d8f13c1b76"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a3558ec56f9d00590c35846d8f13c1b76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3558ec56f9d00590c35846d8f13c1b76">zero</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a3558ec56f9d00590c35846d8f13c1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4078d3b132757efef1b74e42575149"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:afc4078d3b132757efef1b74e42575149"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afc4078d3b132757efef1b74e42575149">minabs_value</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:afc4078d3b132757efef1b74e42575149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8553a88a5735149954d4d04e491e7358"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a8553a88a5735149954d4d04e491e7358"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8553a88a5735149954d4d04e491e7358">maxabs_value</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a8553a88a5735149954d4d04e491e7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297fc199c0e4a33cd3d6122b7c71f514"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a297fc199c0e4a33cd3d6122b7c71f514"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a297fc199c0e4a33cd3d6122b7c71f514">vec_multiply</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a1, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a2)</td></tr>
<tr class="separator:a297fc199c0e4a33cd3d6122b7c71f514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0b1ca917df616d05128c35276462fd"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:abc0b1ca917df616d05128c35276462fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc0b1ca917df616d05128c35276462fd">dot_product</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a1, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a2)</td></tr>
<tr class="separator:abc0b1ca917df616d05128c35276462fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4ffd2673648a15c05d1380f0be0079"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:a1e4ffd2673648a15c05d1380f0be0079"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait</a>&lt; Left &gt;::scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1e4ffd2673648a15c05d1380f0be0079">dot</a> (const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Left &gt; &amp;a1, const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Right &gt; &amp;a2)</td></tr>
<tr class="separator:a1e4ffd2673648a15c05d1380f0be0079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e2f4b420375c45a2c21049e27377aa"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a90e2f4b420375c45a2c21049e27377aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a90e2f4b420375c45a2c21049e27377aa">scale</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a, typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type scaling_factor)</td></tr>
<tr class="separator:a90e2f4b420375c45a2c21049e27377aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299983d3798619c4de88f351bbe369ae"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a299983d3798619c4de88f351bbe369ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a299983d3798619c4de88f351bbe369ae">axpy</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;y, typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type a, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;x)</td></tr>
<tr class="separator:a299983d3798619c4de88f351bbe369ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f28503ce59e167667a4d8259619bf0"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a59f28503ce59e167667a4d8259619bf0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a59f28503ce59e167667a4d8259619bf0">assign</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;m1, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;m2)</td></tr>
<tr class="separator:a59f28503ce59e167667a4d8259619bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b49b5f0f1d0448133635e42a4989137"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a1b49b5f0f1d0448133635e42a4989137"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1b49b5f0f1d0448133635e42a4989137">norm2</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a1b49b5f0f1d0448133635e42a4989137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfd4a5d0073f766aeca78185b841a30"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:aadfd4a5d0073f766aeca78185b841a30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aadfd4a5d0073f766aeca78185b841a30">print</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a, const char *label)</td></tr>
<tr class="separator:aadfd4a5d0073f766aeca78185b841a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7c9fa503cbbd6e5627b1e1878cf51141">clone</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;arg)</td></tr>
<tr class="memdesc:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of an array.  <a href="#a7c9fa503cbbd6e5627b1e1878cf51141">More...</a><br /></td></tr>
<tr class="separator:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe2d157bfac3a81e84b52461e754c96"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a3fe2d157bfac3a81e84b52461e754c96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3fe2d157bfac3a81e84b52461e754c96">to_sparse</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;dense_array)</td></tr>
<tr class="memdesc:a3fe2d157bfac3a81e84b52461e754c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert a dense array into a block sparse array.  <a href="#a3fe2d157bfac3a81e84b52461e754c96">More...</a><br /></td></tr>
<tr class="separator:a3fe2d157bfac3a81e84b52461e754c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f448baf0d9da33c2112d366334c744a"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a9f448baf0d9da33c2112d366334c744a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f448baf0d9da33c2112d366334c744a">to_sparse</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;sparse_array)</td></tr>
<tr class="memdesc:a9f448baf0d9da33c2112d366334c744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the array is already sparse return a copy of the array.  <a href="#a9f448baf0d9da33c2112d366334c744a">More...</a><br /></td></tr>
<tr class="separator:a9f448baf0d9da33c2112d366334c744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af872c21673f2fd74250d0257fb80f2bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:af872c21673f2fd74250d0257fb80f2bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb">eigen_map</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t m, const std::size_t n)</td></tr>
<tr class="memdesc:af872c21673f2fd74250d0257fb80f2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#af872c21673f2fd74250d0257fb80f2bb">More...</a><br /></td></tr>
<tr class="separator:af872c21673f2fd74250d0257fb80f2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88684d17566e9778f88a27bb35f06a2a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a88684d17566e9778f88a27bb35f06a2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a88684d17566e9778f88a27bb35f06a2a">eigen_map</a> (<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t m, const std::size_t n)</td></tr>
<tr class="memdesc:a88684d17566e9778f88a27bb35f06a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#a88684d17566e9778f88a27bb35f06a2a">More...</a><br /></td></tr>
<tr class="separator:a88684d17566e9778f88a27bb35f06a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0362f265187dbcbec382fff3b76ccc2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a0362f265187dbcbec382fff3b76ccc2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, 1 &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0362f265187dbcbec382fff3b76ccc2d">eigen_map</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t n)</td></tr>
<tr class="memdesc:a0362f265187dbcbec382fff3b76ccc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#a0362f265187dbcbec382fff3b76ccc2d">More...</a><br /></td></tr>
<tr class="separator:a0362f265187dbcbec382fff3b76ccc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d234491688847706a6e1a1bd0c86319"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a0d234491688847706a6e1a1bd0c86319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, 1 &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0d234491688847706a6e1a1bd0c86319">eigen_map</a> (<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t n)</td></tr>
<tr class="memdesc:a0d234491688847706a6e1a1bd0c86319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#a0d234491688847706a6e1a1bd0c86319">More...</a><br /></td></tr>
<tr class="separator:a0d234491688847706a6e1a1bd0c86319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adfc30c5c9b3f17a6ab4d8b7a4b2a84b9">eigen_map</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor)</td></tr>
<tr class="memdesc:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#adfc30c5c9b3f17a6ab4d8b7a4b2a84b9">More...</a><br /></td></tr>
<tr class="separator:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa6c8c7926367c10aaae6f056307b9d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:aeaa6c8c7926367c10aaae6f056307b9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aeaa6c8c7926367c10aaae6f056307b9d">eigen_map</a> (<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor)</td></tr>
<tr class="memdesc:aeaa6c8c7926367c10aaae6f056307b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#aeaa6c8c7926367c10aaae6f056307b9d">More...</a><br /></td></tr>
<tr class="separator:aeaa6c8c7926367c10aaae6f056307b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add789e43efcee8db349c7ec5c6218664"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename Derived &gt; </td></tr>
<tr class="memitem:add789e43efcee8db349c7ec5c6218664"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#add789e43efcee8db349c7ec5c6218664">eigen_submatrix_to_tensor</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor)</td></tr>
<tr class="memdesc:add789e43efcee8db349c7ec5c6218664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into a tensor.  <a href="#add789e43efcee8db349c7ec5c6218664">More...</a><br /></td></tr>
<tr class="separator:add789e43efcee8db349c7ec5c6218664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename Derived &gt; </td></tr>
<tr class="memitem:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a6a1e016346f447dcd7b5b4d7f29246b6">tensor_to_eigen_submatrix</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the content of a tensor into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix block.  <a href="#a6a1e016346f447dcd7b5b4d7f29246b6">More...</a><br /></td></tr>
<tr class="separator:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc20cb6cde49d2af9af3312a0309f540"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Derived &gt; </td></tr>
<tr class="memitem:acc20cb6cde49d2af9af3312a0309f540"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acc20cb6cde49d2af9af3312a0309f540">eigen_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, bool replicated=false)</td></tr>
<tr class="memdesc:acc20cb6cde49d2af9af3312a0309f540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into an Array object.  <a href="#acc20cb6cde49d2af9af3312a0309f540">More...</a><br /></td></tr>
<tr class="separator:acc20cb6cde49d2af9af3312a0309f540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfeed8031f6509bdfb6dd1a4d456ffd"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a2dfeed8031f6509bdfb6dd1a4d456ffd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; typename Tile::value_type, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2dfeed8031f6509bdfb6dd1a4d456ffd">array_to_eigen</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;array)</td></tr>
<tr class="memdesc:a2dfeed8031f6509bdfb6dd1a4d456ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Array object into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix object.  <a href="#a2dfeed8031f6509bdfb6dd1a4d456ffd">More...</a><br /></td></tr>
<tr class="separator:a2dfeed8031f6509bdfb6dd1a4d456ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfba97f8c60f13c48f7adfcabc677b95"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:adfba97f8c60f13c48f7adfcabc677b95"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adfba97f8c60f13c48f7adfcabc677b95">row_major_buffer_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const typename A::value_type::value_type *buffer, const std::size_t m, const std::size_t n, const bool replicated=false)</td></tr>
<tr class="memdesc:adfba97f8c60f13c48f7adfcabc677b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a row-major matrix buffer into an Array object.  <a href="#adfba97f8c60f13c48f7adfcabc677b95">More...</a><br /></td></tr>
<tr class="separator:adfba97f8c60f13c48f7adfcabc677b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272240d40c483f779f8affc3c12c3285"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a272240d40c483f779f8affc3c12c3285"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a272240d40c483f779f8affc3c12c3285">column_major_buffer_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const typename A::value_type::value_type *buffer, const std::size_t m, const std::size_t n, const bool replicated=false)</td></tr>
<tr class="memdesc:a272240d40c483f779f8affc3c12c3285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a column-major matrix buffer into an Array object.  <a href="#a272240d40c483f779f8affc3c12c3285">More...</a><br /></td></tr>
<tr class="separator:a272240d40c483f779f8affc3c12c3285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cf1d21760cdc032308a5045f0f4380"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op &gt; </td></tr>
<tr class="memitem:a33cf1d21760cdc032308a5045f0f4380"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a33cf1d21760cdc032308a5045f0f4380">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a33cf1d21760cdc032308a5045f0f4380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a dense Array.  <a href="#a33cf1d21760cdc032308a5045f0f4380">More...</a><br /></td></tr>
<tr class="separator:a33cf1d21760cdc032308a5045f0f4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68370c5a4f4380edb45a5ef3171d97c8"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op &gt; </td></tr>
<tr class="memitem:a68370c5a4f4380edb45a5ef3171d97c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a68370c5a4f4380edb45a5ef3171d97c8">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;arg, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:a68370c5a4f4380edb45a5ef3171d97c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify each tile of a dense Array.  <a href="#a68370c5a4f4380edb45a5ef3171d97c8">More...</a><br /></td></tr>
<tr class="separator:a68370c5a4f4380edb45a5ef3171d97c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e4429634e6981c0ac9f7ff704f2b1a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op &gt; </td></tr>
<tr class="memitem:aa9e4429634e6981c0ac9f7ff704f2b1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa9e4429634e6981c0ac9f7ff704f2b1a">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:aa9e4429634e6981c0ac9f7ff704f2b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a sparse Array.  <a href="#aa9e4429634e6981c0ac9f7ff704f2b1a">More...</a><br /></td></tr>
<tr class="separator:aa9e4429634e6981c0ac9f7ff704f2b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51965d14e5a05c4bfd18e4daaaa64875"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op &gt; </td></tr>
<tr class="memitem:a51965d14e5a05c4bfd18e4daaaa64875"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a51965d14e5a05c4bfd18e4daaaa64875">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;arg, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:a51965d14e5a05c4bfd18e4daaaa64875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify each tile of a sparse Array.  <a href="#a51965d14e5a05c4bfd18e4daaaa64875">More...</a><br /></td></tr>
<tr class="separator:a51965d14e5a05c4bfd18e4daaaa64875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Op , typename std::enable_if&lt; is_dense&lt; Array &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7cd3d9c18d8f36108c03e6ef9429144f">make_array</a> (World &amp;world, const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;trange, const std::shared_ptr&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">detail::pmap_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &gt; &amp;pmap, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dense Array.  <a href="#a7cd3d9c18d8f36108c03e6ef9429144f">More...</a><br /></td></tr>
<tr class="separator:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Op &gt; </td></tr>
<tr class="memitem:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad73ea2d1e2e1b222f741f94a3f949e1c">make_array</a> (World &amp;world, const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;trange, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array.  <a href="#ad73ea2d1e2e1b222f741f94a3f949e1c">More...</a><br /></td></tr>
<tr class="separator:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9380eed8edcb28bcde6b05f2a2e85f2"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:aa9380eed8edcb28bcde6b05f2a2e85f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa9380eed8edcb28bcde6b05f2a2e85f2">to_dense</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;sparse_array)</td></tr>
<tr class="separator:aa9380eed8edcb28bcde6b05f2a2e85f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d73428d629118ac2c9ab7f08b6ca180"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a3d73428d629118ac2c9ab7f08b6ca180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3d73428d629118ac2c9ab7f08b6ca180">to_dense</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;other)</td></tr>
<tr class="separator:a3d73428d629118ac2c9ab7f08b6ca180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c1ea27ad85cca7df258e71c7d9739"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:a177c1ea27ad85cca7df258e71c7d9739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; typename std::result_of&lt; Op(<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>)&gt;::type, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a177c1ea27ad85cca7df258e71c7d9739">to_new_tile_type</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;old_array, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a177c1ea27ad85cca7df258e71c7d9739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert an array to a new array with a different tile type.  <a href="#a177c1ea27ad85cca7df258e71c7d9739">More...</a><br /></td></tr>
<tr class="separator:a177c1ea27ad85cca7df258e71c7d9739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc763468b96a704d6b4efb628909485f"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:abc763468b96a704d6b4efb628909485f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc763468b96a704d6b4efb628909485f">truncate</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;array)</td></tr>
<tr class="memdesc:abc763468b96a704d6b4efb628909485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a dense Array.  <a href="#abc763468b96a704d6b4efb628909485f">More...</a><br /></td></tr>
<tr class="separator:abc763468b96a704d6b4efb628909485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f42ee8853ef4f42c260f1a22ffc1eef">truncate</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;array)</td></tr>
<tr class="memdesc:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a sparse Array.  <a href="#a9f42ee8853ef4f42c260f1a22ffc1eef">More...</a><br /></td></tr>
<tr class="separator:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8044f7d779135e7bc782943d785a0fc5"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a8044f7d779135e7bc782943d785a0fc5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8044f7d779135e7bc782943d785a0fc5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="memdesc:a8044f7d779135e7bc782943d785a0fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> the tensor to an output stream.  <a href="#a8044f7d779135e7bc782943d785a0fc5">More...</a><br /></td></tr>
<tr class="separator:a8044f7d779135e7bc782943d785a0fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad641711c98c1b64bdf7ad28cccfae69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aad641711c98c1b64bdf7ad28cccfae69">exception_break</a> ()</td></tr>
<tr class="memdesc:aad641711c98c1b64bdf7ad28cccfae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a break point on this function to stop before <a class="el" href="namespace_tiled_array.html">TiledArray</a> exceptions are thrown.  <a href="#aad641711c98c1b64bdf7ad28cccfae69">More...</a><br /></td></tr>
<tr class="separator:aad641711c98c1b64bdf7ad28cccfae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d81ab8db19341b018ee44dd5721d28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga82d81ab8db19341b018ee44dd5721d28">operator==</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:ga82d81ab8db19341b018ee44dd5721d28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> equality operator.  <a href="group__symmetry.html#ga82d81ab8db19341b018ee44dd5721d28">More...</a><br /></td></tr>
<tr class="separator:ga82d81ab8db19341b018ee44dd5721d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga64f168b5f03c8c2548c1b67a6509e9a4">operator&lt;&lt;</a> (std::ostream &amp;output, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p)</td></tr>
<tr class="memdesc:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> permutation to an output stream.  <a href="group__symmetry.html#ga64f168b5f03c8c2548c1b67a6509e9a4">More...</a><br /></td></tr>
<tr class="separator:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586be997af3bd421583c8fd36c4e95f2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a586be997af3bd421583c8fd36c4e95f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a586be997af3bd421583c8fd36c4e95f2">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a586be997af3bd421583c8fd36c4e95f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute a <code>std::array</code>.  <a href="#a586be997af3bd421583c8fd36c4e95f2">More...</a><br /></td></tr>
<tr class="separator:a586be997af3bd421583c8fd36c4e95f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84ce21d711a462da4a1b44a811a5a94"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae84ce21d711a462da4a1b44a811a5a94"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae84ce21d711a462da4a1b44a811a5a94">operator*=</a> (std::array&lt; T, N &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ae84ce21d711a462da4a1b44a811a5a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place permute a <code>std::array</code>.  <a href="#ae84ce21d711a462da4a1b44a811a5a94">More...</a><br /></td></tr>
<tr class="separator:ae84ce21d711a462da4a1b44a811a5a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db915cc9b57726c63e876d1260c50dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a3db915cc9b57726c63e876d1260c50dc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3db915cc9b57726c63e876d1260c50dc">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const std::vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a3db915cc9b57726c63e876d1260c50dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute a <code>std::vector&lt;T&gt;</code>  <a href="#a3db915cc9b57726c63e876d1260c50dc">More...</a><br /></td></tr>
<tr class="separator:a3db915cc9b57726c63e876d1260c50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beab363e9a6e97343bc39965e548f95"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a4beab363e9a6e97343bc39965e548f95"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4beab363e9a6e97343bc39965e548f95">operator*=</a> (std::vector&lt; T, A &gt; &amp;v, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a4beab363e9a6e97343bc39965e548f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place permute a <code>std::array</code>.  <a href="#a4beab363e9a6e97343bc39965e548f95">More...</a><br /></td></tr>
<tr class="separator:a4beab363e9a6e97343bc39965e548f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696e0fb9934a65b840e1b4b682d9b7da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a696e0fb9934a65b840e1b4b682d9b7da"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a696e0fb9934a65b840e1b4b682d9b7da">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T *restrict const ptr)</td></tr>
<tr class="memdesc:a696e0fb9934a65b840e1b4b682d9b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute a memory buffer.  <a href="#a696e0fb9934a65b840e1b4b682d9b7da">More...</a><br /></td></tr>
<tr class="separator:a696e0fb9934a65b840e1b4b682d9b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38342dbdaa26d0f24c1633f77c6555d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gab38342dbdaa26d0f24c1633f77c6555d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> inequality operator.  <a href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d">More...</a><br /></td></tr>
<tr class="separator:gab38342dbdaa26d0f24c1633f77c6555d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63845f58c204f812d564fa36d02103c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga63845f58c204f812d564fa36d02103c6">operator&lt;</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:ga63845f58c204f812d564fa36d02103c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> less-than operator.  <a href="group__symmetry.html#ga63845f58c204f812d564fa36d02103c6">More...</a><br /></td></tr>
<tr class="separator:ga63845f58c204f812d564fa36d02103c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gaeb2fae98580d4113b53ee2f7385c22fc">operator-</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse permutation operator.  <a href="group__symmetry.html#gaeb2fae98580d4113b53ee2f7385c22fc">More...</a><br /></td></tr>
<tr class="separator:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35ad610b547911850e7ac729a08a917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gac35ad610b547911850e7ac729a08a917">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gac35ad610b547911850e7ac729a08a917"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> multiplication operator.  <a href="group__symmetry.html#gac35ad610b547911850e7ac729a08a917">More...</a><br /></td></tr>
<tr class="separator:gac35ad610b547911850e7ac729a08a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab001d09984e0b7c2bca406ea43b08078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gab001d09984e0b7c2bca406ea43b08078">operator*=</a> (<a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gab001d09984e0b7c2bca406ea43b08078"><td class="mdescLeft">&#160;</td><td class="mdescRight">return *this ^ other  <a href="group__symmetry.html#gab001d09984e0b7c2bca406ea43b08078">More...</a><br /></td></tr>
<tr class="separator:gab001d09984e0b7c2bca406ea43b08078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gaf1f4db587fe34281a4ffab0ca581d2b1">operator^</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, int n)</td></tr>
<tr class="memdesc:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>perm</code> to the n-th power.  <a href="group__symmetry.html#gaf1f4db587fe34281a4ffab0ca581d2b1">More...</a><br /></td></tr>
<tr class="separator:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a705b350b2dbf336a9cc24fb1d0f78fca">swap</a> (<a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1)</td></tr>
<tr class="memdesc:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the values of the give two ranges.  <a href="#a705b350b2dbf336a9cc24fb1d0f78fca">More...</a><br /></td></tr>
<tr class="separator:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f80db611a7af38027953b96bc8f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a678f80db611a7af38027953b96bc8f0d">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r)</td></tr>
<tr class="memdesc:a678f80db611a7af38027953b96bc8f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted range.  <a href="#a678f80db611a7af38027953b96bc8f0d">More...</a><br /></td></tr>
<tr class="separator:a678f80db611a7af38027953b96bc8f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac25a0fb0ad765d6c6a383c67d403fc57">operator==</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> equality comparison.  <a href="#ac25a0fb0ad765d6c6a383c67d403fc57">More...</a><br /></td></tr>
<tr class="separator:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc410382ebb92ab3373034a9b54a9a78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc410382ebb92ab3373034a9b54a9a78">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:abc410382ebb92ab3373034a9b54a9a78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> inequality comparison.  <a href="#abc410382ebb92ab3373034a9b54a9a78">More...</a><br /></td></tr>
<tr class="separator:abc410382ebb92ab3373034a9b54a9a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a00568c34aef7e5f9b2802cbdd4382ea5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r)</td></tr>
<tr class="memdesc:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> output operator.  <a href="#a00568c34aef7e5f9b2802cbdd4382ea5">More...</a><br /></td></tr>
<tr class="separator:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a59b3c5e05d4511f501d0d583bc6ca"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a91a59b3c5e05d4511f501d0d583bc6ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a91a59b3c5e05d4511f501d0d583bc6ca">operator+</a> (const T1 &amp;left, const T2 &amp;right) -&gt; decltype(left.add(right))</td></tr>
<tr class="memdesc:a91a59b3c5e05d4511f501d0d583bc6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator.  <a href="#a91a59b3c5e05d4511f501d0d583bc6ca">More...</a><br /></td></tr>
<tr class="separator:a91a59b3c5e05d4511f501d0d583bc6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8991a55c5789853a510f20a134ca4f85"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a8991a55c5789853a510f20a134ca4f85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8991a55c5789853a510f20a134ca4f85">operator-</a> (const T1 &amp;left, const T2 &amp;right) -&gt; decltype(left.subt(right))</td></tr>
<tr class="memdesc:a8991a55c5789853a510f20a134ca4f85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator.  <a href="#a8991a55c5789853a510f20a134ca4f85">More...</a><br /></td></tr>
<tr class="separator:a8991a55c5789853a510f20a134ca4f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7536fceedf51ab22cfffa370ccc537d1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7536fceedf51ab22cfffa370ccc537d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7536fceedf51ab22cfffa370ccc537d1">operator*</a> (const T1 &amp;left, const T2 &amp;right) -&gt; decltype(left.mult(right))</td></tr>
<tr class="memdesc:a7536fceedf51ab22cfffa370ccc537d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> multiplication operator.  <a href="#a7536fceedf51ab22cfffa370ccc537d1">More...</a><br /></td></tr>
<tr class="separator:a7536fceedf51ab22cfffa370ccc537d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf93d3d11d940c8e031f50828fd2059"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:adaf93d3d11d940c8e031f50828fd2059"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adaf93d3d11d940c8e031f50828fd2059">operator*</a> (const T &amp;left, N right) -&gt; decltype(left.scale(right))</td></tr>
<tr class="memdesc:adaf93d3d11d940c8e031f50828fd2059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>left</code> that is scaled by <code>right</code>.  <a href="#adaf93d3d11d940c8e031f50828fd2059">More...</a><br /></td></tr>
<tr class="separator:adaf93d3d11d940c8e031f50828fd2059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56598114f338270d1a1e1d04049d61e0"><td class="memTemplParams" colspan="2">template&lt;typename N , typename T , typename std::enable_if&lt;                                  detail::is_numeric&lt; N &gt;::value &amp;&amp;                               (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a56598114f338270d1a1e1d04049d61e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a56598114f338270d1a1e1d04049d61e0">operator*</a> (N left, const T &amp;right) -&gt; decltype(right.scale(left))</td></tr>
<tr class="memdesc:a56598114f338270d1a1e1d04049d61e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>right</code> that is scaled by <code>left</code>.  <a href="#a56598114f338270d1a1e1d04049d61e0">More...</a><br /></td></tr>
<tr class="separator:a56598114f338270d1a1e1d04049d61e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;                                  detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac90b5d6c5aae4293d2b9d3456477aeba">operator-</a> (const T &amp;arg) -&gt; decltype(arg.neg())</td></tr>
<tr class="memdesc:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negated copy of <code>arg</code>.  <a href="#ac90b5d6c5aae4293d2b9d3456477aeba">More...</a><br /></td></tr>
<tr class="separator:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eb9cd81ceddc9a6d03f4b122d37c79"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;                                  detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a94eb9cd81ceddc9a6d03f4b122d37c79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a94eb9cd81ceddc9a6d03f4b122d37c79">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T &amp;arg) -&gt; decltype(arg.permute(perm))</td></tr>
<tr class="memdesc:a94eb9cd81ceddc9a6d03f4b122d37c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="#a94eb9cd81ceddc9a6d03f4b122d37c79">More...</a><br /></td></tr>
<tr class="separator:a94eb9cd81ceddc9a6d03f4b122d37c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9688412f951f29a193bab6e8659cc0f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9688412f951f29a193bab6e8659cc0f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9688412f951f29a193bab6e8659cc0f0">operator+=</a> (T1 &amp;left, const T2 &amp;right) -&gt; decltype(left.add_to(right))</td></tr>
<tr class="memdesc:a9688412f951f29a193bab6e8659cc0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator.  <a href="#a9688412f951f29a193bab6e8659cc0f0">More...</a><br /></td></tr>
<tr class="separator:a9688412f951f29a193bab6e8659cc0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2392a7f20731da96a682b95aafd19559"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2392a7f20731da96a682b95aafd19559"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2392a7f20731da96a682b95aafd19559">operator-=</a> (T1 &amp;left, const T2 &amp;right) -&gt; decltype(left.subt_to(right))</td></tr>
<tr class="memdesc:a2392a7f20731da96a682b95aafd19559"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator.  <a href="#a2392a7f20731da96a682b95aafd19559">More...</a><br /></td></tr>
<tr class="separator:a2392a7f20731da96a682b95aafd19559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116f5e2ecfb93c7163f2059bd52c3f89"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a116f5e2ecfb93c7163f2059bd52c3f89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a116f5e2ecfb93c7163f2059bd52c3f89">operator*=</a> (T1 &amp;left, const T2 &amp;right) -&gt; decltype(left.mult_to(right))</td></tr>
<tr class="memdesc:a116f5e2ecfb93c7163f2059bd52c3f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor multiplication.  <a href="#a116f5e2ecfb93c7163f2059bd52c3f89">More...</a><br /></td></tr>
<tr class="separator:a116f5e2ecfb93c7163f2059bd52c3f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034cc7b6df60ee6292bdff4daf87ad42"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a034cc7b6df60ee6292bdff4daf87ad42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a034cc7b6df60ee6292bdff4daf87ad42">operator+=</a> (T &amp;left, N right) -&gt; decltype(left.add_to(right))</td></tr>
<tr class="memdesc:a034cc7b6df60ee6292bdff4daf87ad42"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor add constant.  <a href="#a034cc7b6df60ee6292bdff4daf87ad42">More...</a><br /></td></tr>
<tr class="separator:a034cc7b6df60ee6292bdff4daf87ad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3e09d58de106a8665496a8f4adbf51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aed3e09d58de106a8665496a8f4adbf51"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aed3e09d58de106a8665496a8f4adbf51">operator-=</a> (T &amp;left, N right) -&gt; decltype(left.subt_to(right))</td></tr>
<tr class="memdesc:aed3e09d58de106a8665496a8f4adbf51"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor subtract constant.  <a href="#aed3e09d58de106a8665496a8f4adbf51">More...</a><br /></td></tr>
<tr class="separator:aed3e09d58de106a8665496a8f4adbf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fc80968c1111be5a7be74a5fa5e807"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a29fc80968c1111be5a7be74a5fa5e807"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a29fc80968c1111be5a7be74a5fa5e807">operator*=</a> (T &amp;left, N right) -&gt; decltype(left.scale_to(right))</td></tr>
<tr class="memdesc:a29fc80968c1111be5a7be74a5fa5e807"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor scale.  <a href="#a29fc80968c1111be5a7be74a5fa5e807">More...</a><br /></td></tr>
<tr class="separator:a29fc80968c1111be5a7be74a5fa5e807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3ed423a0b023a4a5aadfb5012d968a4a">shift</a> (T &amp;tensor)</td></tr>
<tr class="memdesc:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> a tensor from one range to another.  <a href="#a3ed423a0b023a4a5aadfb5012d968a4a">More...</a><br /></td></tr>
<tr class="separator:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a62b1b3fec016be7c5ed4230f72e5b29d">shift</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> a tensor from one range to another.  <a href="#a62b1b3fec016be7c5ed4230f72e5b29d">More...</a><br /></td></tr>
<tr class="separator:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a59d75845f7586427931c3d854e70e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:ac6a59d75845f7586427931c3d854e70e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac6a59d75845f7586427931c3d854e70e">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;, T *const, const Index &amp;, const Index &amp;)</td></tr>
<tr class="separator:ac6a59d75845f7586427931c3d854e70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d05db90b5aba567b8653f980ab3310"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34d05db90b5aba567b8653f980ab3310"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a34d05db90b5aba567b8653f980ab3310">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;, T *const, const std::initializer_list&lt; std::size_t &gt; &amp;, const std::initializer_list&lt; std::size_t &gt; &amp;)</td></tr>
<tr class="separator:a34d05db90b5aba567b8653f980ab3310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3f6231b75b996d3fa766849f952eef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:a4b3f6231b75b996d3fa766849f952eef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4b3f6231b75b996d3fa766849f952eef">make_map</a> (T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a4b3f6231b75b996d3fa766849f952eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550c8b83d887c20998b7a696d3ee8111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a550c8b83d887c20998b7a696d3ee8111"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a550c8b83d887c20998b7a696d3ee8111">make_map</a> (T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a550c8b83d887c20998b7a696d3ee8111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbe8d8ad0930df042711f7a4712f5fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbbe8d8ad0930df042711f7a4712f5fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acbbe8d8ad0930df042711f7a4712f5fb">make_map</a> (T *const data, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:acbbe8d8ad0930df042711f7a4712f5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e69e843e127604a961c87e9c987cce6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:a9e69e843e127604a961c87e9c987cce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9e69e843e127604a961c87e9c987cce6">make_map</a> (const T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a9e69e843e127604a961c87e9c987cce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cce5a1ed8ed29fc23faee418274512"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78cce5a1ed8ed29fc23faee418274512"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a78cce5a1ed8ed29fc23faee418274512">make_map</a> (const T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a78cce5a1ed8ed29fc23faee418274512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c319275bd48061cbd38e7171bef453"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91c319275bd48061cbd38e7171bef453"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a91c319275bd48061cbd38e7171bef453">make_map</a> (const T *const data, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:a91c319275bd48061cbd38e7171bef453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3e7bc14ca6d99904ada555922fc391"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:ada3e7bc14ca6d99904ada555922fc391"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ada3e7bc14ca6d99904ada555922fc391">make_const_map</a> (const T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:ada3e7bc14ca6d99904ada555922fc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46acafb5a0d0468803cf0136997b0343"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46acafb5a0d0468803cf0136997b0343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a46acafb5a0d0468803cf0136997b0343">make_const_map</a> (const T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a46acafb5a0d0468803cf0136997b0343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caf83be84a92371f88fa53b8e100317"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7caf83be84a92371f88fa53b8e100317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7caf83be84a92371f88fa53b8e100317">make_const_map</a> (const T *const data, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:a7caf83be84a92371f88fa53b8e100317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b5cbaea4986ba92424520ae4a83f8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:aa9b5cbaea4986ba92424520ae4a83f8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa9b5cbaea4986ba92424520ae4a83f8d">remap</a> (<a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt; T &gt; &amp;map, T *data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="memdesc:aa9b5cbaea4986ba92424520ae4a83f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For reusing map without allocating new ranges . . . maybe.  <a href="#aa9b5cbaea4986ba92424520ae4a83f8d">More...</a><br /></td></tr>
<tr class="separator:aa9b5cbaea4986ba92424520ae4a83f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac227696cd22877cfb9af3b37523345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acac227696cd22877cfb9af3b37523345"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acac227696cd22877cfb9af3b37523345">remap</a> (<a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt; T &gt; &amp;map, T *data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:acac227696cd22877cfb9af3b37523345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d07017bf139b8ea4e344216443b372"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;                                  detail::is_tensor&lt; T &gt;::value &amp;&amp;                               detail::is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a67d07017bf139b8ea4e344216443b372"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a67d07017bf139b8ea4e344216443b372">operator&lt;&lt;</a> (std::ostream &amp;os, const T &amp;t)</td></tr>
<tr class="memdesc:a67d07017bf139b8ea4e344216443b372"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> output operator.  <a href="#a67d07017bf139b8ea4e344216443b372">More...</a><br /></td></tr>
<tr class="separator:a67d07017bf139b8ea4e344216443b372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1">clone</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gaec378f0f4b197546fb0b69f16748bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>arg</code>.  <a href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1">More...</a><br /></td></tr>
<tr class="separator:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gacd7e8d783c93f6a965a52cfc7124b6d0">empty</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that <code>arg</code> is empty (no data)  <a href="group___tile_interface.html#gacd7e8d783c93f6a965a52cfc7124b6d0">More...</a><br /></td></tr>
<tr class="separator:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga040f23a684e2cfec50be13936d603709"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga040f23a684e2cfec50be13936d603709"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga040f23a684e2cfec50be13936d603709">permute</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(permute(arg.tensor(), perm))&gt;</td></tr>
<tr class="memdesc:ga040f23a684e2cfec50be13936d603709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="group___tile_interface.html#ga040f23a684e2cfec50be13936d603709">More...</a><br /></td></tr>
<tr class="separator:ga040f23a684e2cfec50be13936d603709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1428654d9053accf03684ba5d57e4b0"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:gab1428654d9053accf03684ba5d57e4b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab1428654d9053accf03684ba5d57e4b0">shift</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Index &amp;range_shift) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(shift(arg.tensor(), range_shift))&gt;</td></tr>
<tr class="memdesc:gab1428654d9053accf03684ba5d57e4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the range of <code>arg</code>.  <a href="group___tile_interface.html#gab1428654d9053accf03684ba5d57e4b0">More...</a><br /></td></tr>
<tr class="separator:gab1428654d9053accf03684ba5d57e4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2ead9e3d38c6a824d4dfe0beffddbcdf">shift_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the range of <code>arg</code> in place.  <a href="group___tile_interface.html#ga2ead9e3d38c6a824d4dfe0beffddbcdf">More...</a><br /></td></tr>
<tr class="separator:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94ec03e0af35cc7da26e8fbbf4a6be3"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gaa94ec03e0af35cc7da26e8fbbf4a6be3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaa94ec03e0af35cc7da26e8fbbf4a6be3">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(add(left.tensor(), right.tensor()))&gt;</td></tr>
<tr class="memdesc:gaa94ec03e0af35cc7da26e8fbbf4a6be3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> tile arguments.  <a href="group___tile_interface.html#gaa94ec03e0af35cc7da26e8fbbf4a6be3">More...</a><br /></td></tr>
<tr class="separator:gaa94ec03e0af35cc7da26e8fbbf4a6be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab34e9c983c957d03d780e6ac32555738"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gab34e9c983c957d03d780e6ac32555738"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab34e9c983c957d03d780e6ac32555738">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(add(left.tensor(), right.tensor(), factor))&gt;</td></tr>
<tr class="memdesc:gab34e9c983c957d03d780e6ac32555738"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> and scale tile arguments.  <a href="group___tile_interface.html#gab34e9c983c957d03d780e6ac32555738">More...</a><br /></td></tr>
<tr class="separator:gab34e9c983c957d03d780e6ac32555738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51557c926f10a9406d056c903ad3b279"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga51557c926f10a9406d056c903ad3b279"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga51557c926f10a9406d056c903ad3b279">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(add(left.tensor(), right.tensor(), perm))&gt;</td></tr>
<tr class="memdesc:ga51557c926f10a9406d056c903ad3b279"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> and permute tile arguments.  <a href="group___tile_interface.html#ga51557c926f10a9406d056c903ad3b279">More...</a><br /></td></tr>
<tr class="separator:ga51557c926f10a9406d056c903ad3b279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcd1a751061a1aab818618e2475b246"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4bcd1a751061a1aab818618e2475b246"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4bcd1a751061a1aab818618e2475b246">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(add(left.tensor(), right.tensor(), factor, perm))&gt;</td></tr>
<tr class="memdesc:ga4bcd1a751061a1aab818618e2475b246"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a>, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga4bcd1a751061a1aab818618e2475b246">More...</a><br /></td></tr>
<tr class="separator:ga4bcd1a751061a1aab818618e2475b246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82119d9a563ead840c9e16c2a729cf82"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga82119d9a563ead840c9e16c2a729cf82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga82119d9a563ead840c9e16c2a729cf82">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(add(arg.tensor(), value))&gt;</td></tr>
<tr class="memdesc:ga82119d9a563ead840c9e16c2a729cf82"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant scalar to tile argument.  <a href="group___tile_interface.html#ga82119d9a563ead840c9e16c2a729cf82">More...</a><br /></td></tr>
<tr class="separator:ga82119d9a563ead840c9e16c2a729cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c17a335bfefef81ad3d25b2814f6eb1"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2c17a335bfefef81ad3d25b2814f6eb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2c17a335bfefef81ad3d25b2814f6eb1">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(add(arg.tensor(), value, perm))&gt;</td></tr>
<tr class="memdesc:ga2c17a335bfefef81ad3d25b2814f6eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant scalar and permute tile argument.  <a href="group___tile_interface.html#ga2c17a335bfefef81ad3d25b2814f6eb1">More...</a><br /></td></tr>
<tr class="separator:ga2c17a335bfefef81ad3d25b2814f6eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> to the result tile.  <a href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e">More...</a><br /></td></tr>
<tr class="separator:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dabb8dd35f758019c80da238cf50196"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6dabb8dd35f758019c80da238cf50196"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6dabb8dd35f758019c80da238cf50196">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga6dabb8dd35f758019c80da238cf50196"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> and scale to the result tile.  <a href="group___tile_interface.html#ga6dabb8dd35f758019c80da238cf50196">More...</a><br /></td></tr>
<tr class="separator:ga6dabb8dd35f758019c80da238cf50196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0887904f4fbb716dec1467ff37bcdef6">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:ga0887904f4fbb716dec1467ff37bcdef6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> constant scalar to the result tile.  <a href="group___tile_interface.html#ga0887904f4fbb716dec1467ff37bcdef6">More...</a><br /></td></tr>
<tr class="separator:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e009bc78f47589f3ff1a609b6fc99f0"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga0e009bc78f47589f3ff1a609b6fc99f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0e009bc78f47589f3ff1a609b6fc99f0">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(sub(left.tensor(), right.tensor()))&gt;</td></tr>
<tr class="memdesc:ga0e009bc78f47589f3ff1a609b6fc99f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tile arguments.  <a href="group___tile_interface.html#ga0e009bc78f47589f3ff1a609b6fc99f0">More...</a><br /></td></tr>
<tr class="separator:ga0e009bc78f47589f3ff1a609b6fc99f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59a235e1218625016be17635a913d4b9"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga59a235e1218625016be17635a913d4b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga59a235e1218625016be17635a913d4b9">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(subt(left.tensor(), right.tensor(), factor))&gt;</td></tr>
<tr class="memdesc:ga59a235e1218625016be17635a913d4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale tile arguments.  <a href="group___tile_interface.html#ga59a235e1218625016be17635a913d4b9">More...</a><br /></td></tr>
<tr class="separator:ga59a235e1218625016be17635a913d4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab363f140188911f648522a3560d0b314"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gab363f140188911f648522a3560d0b314"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab363f140188911f648522a3560d0b314">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(subt(left.tensor(), right.tensor(), perm))&gt;</td></tr>
<tr class="memdesc:gab363f140188911f648522a3560d0b314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and permute tile arguments.  <a href="group___tile_interface.html#gab363f140188911f648522a3560d0b314">More...</a><br /></td></tr>
<tr class="separator:gab363f140188911f648522a3560d0b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9420b1a47a9fbe3ab296c9f93c04f0ec"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9420b1a47a9fbe3ab296c9f93c04f0ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga9420b1a47a9fbe3ab296c9f93c04f0ec">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(subt(left.tensor(), right.tensor(), factor, perm))&gt;</td></tr>
<tr class="memdesc:ga9420b1a47a9fbe3ab296c9f93c04f0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga9420b1a47a9fbe3ab296c9f93c04f0ec">More...</a><br /></td></tr>
<tr class="separator:ga9420b1a47a9fbe3ab296c9f93c04f0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8654cfc20343b3eadf76a809d3ec5c4a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8654cfc20343b3eadf76a809d3ec5c4a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga8654cfc20343b3eadf76a809d3ec5c4a">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(subt(arg.tensor(), value))&gt;</td></tr>
<tr class="memdesc:ga8654cfc20343b3eadf76a809d3ec5c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar constant from the tile argument.  <a href="group___tile_interface.html#ga8654cfc20343b3eadf76a809d3ec5c4a">More...</a><br /></td></tr>
<tr class="separator:ga8654cfc20343b3eadf76a809d3ec5c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a010a9078ab717f28b7a2bf8bd6bd42"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6a010a9078ab717f28b7a2bf8bd6bd42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6a010a9078ab717f28b7a2bf8bd6bd42">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(subt(arg.tensor(), value, perm))&gt;</td></tr>
<tr class="memdesc:ga6a010a9078ab717f28b7a2bf8bd6bd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant scalar and permute tile argument.  <a href="group___tile_interface.html#ga6a010a9078ab717f28b7a2bf8bd6bd42">More...</a><br /></td></tr>
<tr class="separator:ga6a010a9078ab717f28b7a2bf8bd6bd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b0fd498d81c2a5898673bcb0152934"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga67b0fd498d81c2a5898673bcb0152934"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga67b0fd498d81c2a5898673bcb0152934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from the result tile.  <a href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">More...</a><br /></td></tr>
<tr class="separator:ga67b0fd498d81c2a5898673bcb0152934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3857edf071769c169d08af65690063eb"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3857edf071769c169d08af65690063eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga3857edf071769c169d08af65690063eb">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga3857edf071769c169d08af65690063eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale from the result tile.  <a href="group___tile_interface.html#ga3857edf071769c169d08af65690063eb">More...</a><br /></td></tr>
<tr class="separator:ga3857edf071769c169d08af65690063eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7653e81aa69141646e7c93b916fadb"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gafc7653e81aa69141646e7c93b916fadb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gafc7653e81aa69141646e7c93b916fadb">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:gafc7653e81aa69141646e7c93b916fadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract constant scalar from the result tile.  <a href="group___tile_interface.html#gafc7653e81aa69141646e7c93b916fadb">More...</a><br /></td></tr>
<tr class="separator:gafc7653e81aa69141646e7c93b916fadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf680dc2cab0353728f84f07a4fbd9e"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga4cf680dc2cab0353728f84f07a4fbd9e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4cf680dc2cab0353728f84f07a4fbd9e">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(mult(left.tensor(), right.tensor()))&gt;</td></tr>
<tr class="memdesc:ga4cf680dc2cab0353728f84f07a4fbd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication tile arguments.  <a href="group___tile_interface.html#ga4cf680dc2cab0353728f84f07a4fbd9e">More...</a><br /></td></tr>
<tr class="separator:ga4cf680dc2cab0353728f84f07a4fbd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga836d02d00a32db1a53ead357bcc26fa5"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga836d02d00a32db1a53ead357bcc26fa5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga836d02d00a32db1a53ead357bcc26fa5">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(mult(left.tensor(), right.tensor(), factor))&gt;</td></tr>
<tr class="memdesc:ga836d02d00a32db1a53ead357bcc26fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and scale tile arguments.  <a href="group___tile_interface.html#ga836d02d00a32db1a53ead357bcc26fa5">More...</a><br /></td></tr>
<tr class="separator:ga836d02d00a32db1a53ead357bcc26fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1493cb12db29b45c45e42a6b71f0fb"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga1f1493cb12db29b45c45e42a6b71f0fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga1f1493cb12db29b45c45e42a6b71f0fb">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(mult(left.tensor(), right.tensor(), perm))&gt;</td></tr>
<tr class="memdesc:ga1f1493cb12db29b45c45e42a6b71f0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and permute tile arguments.  <a href="group___tile_interface.html#ga1f1493cb12db29b45c45e42a6b71f0fb">More...</a><br /></td></tr>
<tr class="separator:ga1f1493cb12db29b45c45e42a6b71f0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb2603da627b88b647e1716dfbbc940"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7cb2603da627b88b647e1716dfbbc940"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga7cb2603da627b88b647e1716dfbbc940">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(mult(left.tensor(), right.tensor(), factor, perm))&gt;</td></tr>
<tr class="memdesc:ga7cb2603da627b88b647e1716dfbbc940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga7cb2603da627b88b647e1716dfbbc940">More...</a><br /></td></tr>
<tr class="separator:ga7cb2603da627b88b647e1716dfbbc940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37039529fef4c507e5e5ecf379edf38"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:gad37039529fef4c507e5e5ecf379edf38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">mult_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gad37039529fef4c507e5e5ecf379edf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply to the result tile.  <a href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">More...</a><br /></td></tr>
<tr class="separator:gad37039529fef4c507e5e5ecf379edf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaff6e36fcc141764f788ab1eb59965a8c">mult_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gaff6e36fcc141764f788ab1eb59965a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and scale to the result tile.  <a href="group___tile_interface.html#gaff6e36fcc141764f788ab1eb59965a8c">More...</a><br /></td></tr>
<tr class="separator:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3037d44db8544dbd27cab783972bc20"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gab3037d44db8544dbd27cab783972bc20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab3037d44db8544dbd27cab783972bc20">scale</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(scale(arg.tensor(), factor))&gt;</td></tr>
<tr class="memdesc:gab3037d44db8544dbd27cab783972bc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar the tile argument.  <a href="group___tile_interface.html#gab3037d44db8544dbd27cab783972bc20">More...</a><br /></td></tr>
<tr class="separator:gab3037d44db8544dbd27cab783972bc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05d1f121d76e4a5126ae521c8e60be8"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gab05d1f121d76e4a5126ae521c8e60be8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab05d1f121d76e4a5126ae521c8e60be8">scale</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(scale(arg.tensor(), factor, perm))&gt;</td></tr>
<tr class="memdesc:gab05d1f121d76e4a5126ae521c8e60be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and permute tile argument.  <a href="group___tile_interface.html#gab05d1f121d76e4a5126ae521c8e60be8">More...</a><br /></td></tr>
<tr class="separator:gab05d1f121d76e4a5126ae521c8e60be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga381f8c925fdcfdee5cfef07f66c4da25">scale_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale to the result tile.  <a href="group___tile_interface.html#ga381f8c925fdcfdee5cfef07f66c4da25">More...</a><br /></td></tr>
<tr class="separator:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d7119054012d41b27804b6c37e8cb0"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gab5d7119054012d41b27804b6c37e8cb0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab5d7119054012d41b27804b6c37e8cb0">neg</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(neg(arg.tensor()))&gt;</td></tr>
<tr class="memdesc:gab5d7119054012d41b27804b6c37e8cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the tile argument.  <a href="group___tile_interface.html#gab5d7119054012d41b27804b6c37e8cb0">More...</a><br /></td></tr>
<tr class="separator:gab5d7119054012d41b27804b6c37e8cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7626f4de725a05e293ef8d67046ba365"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga7626f4de725a05e293ef8d67046ba365"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga7626f4de725a05e293ef8d67046ba365">neg</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(neg(arg.tensor(), perm))&gt;</td></tr>
<tr class="memdesc:ga7626f4de725a05e293ef8d67046ba365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate and permute tile argument.  <a href="group___tile_interface.html#ga7626f4de725a05e293ef8d67046ba365">More...</a><br /></td></tr>
<tr class="separator:ga7626f4de725a05e293ef8d67046ba365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">neg_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result)</td></tr>
<tr class="memdesc:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication constant scalar to a tile.  <a href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">More...</a><br /></td></tr>
<tr class="separator:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga790a672539c1eef4a6dae07be7b072b8"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga790a672539c1eef4a6dae07be7b072b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga790a672539c1eef4a6dae07be7b072b8">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(conj(arg.tensor()))&gt;</td></tr>
<tr class="memdesc:ga790a672539c1eef4a6dae07be7b072b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of a tile.  <a href="group___tile_interface.html#ga790a672539c1eef4a6dae07be7b072b8">More...</a><br /></td></tr>
<tr class="separator:ga790a672539c1eef4a6dae07be7b072b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b20ca3bbb1390f94e310f0b690a7b49"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt;                                  TiledArray::detail::is_numeric&lt; Scalar &gt;::value               &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6b20ca3bbb1390f94e310f0b690a7b49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6b20ca3bbb1390f94e310f0b690a7b49">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(conj(arg.tensor(), factor))&gt;</td></tr>
<tr class="memdesc:ga6b20ca3bbb1390f94e310f0b690a7b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of a tile.  <a href="group___tile_interface.html#ga6b20ca3bbb1390f94e310f0b690a7b49">More...</a><br /></td></tr>
<tr class="separator:ga6b20ca3bbb1390f94e310f0b690a7b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264a048d3211c5178a85b64a97325689"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga264a048d3211c5178a85b64a97325689"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga264a048d3211c5178a85b64a97325689">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(conj(arg.tensor(), perm))&gt;</td></tr>
<tr class="memdesc:ga264a048d3211c5178a85b64a97325689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of a tile.  <a href="group___tile_interface.html#ga264a048d3211c5178a85b64a97325689">More...</a><br /></td></tr>
<tr class="separator:ga264a048d3211c5178a85b64a97325689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d308da63361867599b880a936299837"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt;                                  TiledArray::detail::is_numeric&lt; Scalar &gt;::value               &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2d308da63361867599b880a936299837"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2d308da63361867599b880a936299837">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(conj(arg.tensor(), factor, perm))&gt;</td></tr>
<tr class="memdesc:ga2d308da63361867599b880a936299837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of a tile.  <a href="group___tile_interface.html#ga2d308da63361867599b880a936299837">More...</a><br /></td></tr>
<tr class="separator:ga2d308da63361867599b880a936299837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fd187f7e500ab8977032e67537b92a"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:gad2fd187f7e500ab8977032e67537b92a"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad2fd187f7e500ab8977032e67537b92a">conj_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result)</td></tr>
<tr class="memdesc:gad2fd187f7e500ab8977032e67537b92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate a tile.  <a href="group___tile_interface.html#gad2fd187f7e500ab8977032e67537b92a">More...</a><br /></td></tr>
<tr class="separator:gad2fd187f7e500ab8977032e67537b92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt;                                  TiledArray::detail::is_numeric&lt; Scalar &gt;::value               &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf81db8c2648b13dd9ded3b54bcefa4e1">conj_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate and scale a tile.  <a href="group___tile_interface.html#gaf81db8c2648b13dd9ded3b54bcefa4e1">More...</a><br /></td></tr>
<tr class="separator:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f834a16c8290960ac267c29d6c4d3c7"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f834a16c8290960ac267c29d6c4d3c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0f834a16c8290960ac267c29d6c4d3c7">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config) -&gt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; decltype(gemm(left.tensor(), right.tensor(), factor, gemm_config))&gt;</td></tr>
<tr class="memdesc:ga0f834a16c8290960ac267c29d6c4d3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments.  <a href="group___tile_interface.html#ga0f834a16c8290960ac267c29d6c4d3c7">More...</a><br /></td></tr>
<tr class="separator:ga0f834a16c8290960ac267c29d6c4d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5cd5e3e8121313e9684e91cfa6230fd6">gemm</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments to the result tile.  <a href="group___tile_interface.html#ga5cd5e3e8121313e9684e91cfa6230fd6">More...</a><br /></td></tr>
<tr class="separator:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2e1515602acee2ef90cdf5c7379f7e"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga8e2e1515602acee2ef90cdf5c7379f7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga8e2e1515602acee2ef90cdf5c7379f7e">trace</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(trace(arg.tensor()))</td></tr>
<tr class="memdesc:ga8e2e1515602acee2ef90cdf5c7379f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the hyper-diagonal elements a tile.  <a href="group___tile_interface.html#ga8e2e1515602acee2ef90cdf5c7379f7e">More...</a><br /></td></tr>
<tr class="separator:ga8e2e1515602acee2ef90cdf5c7379f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ec8fb09a92b3abe9589be5000f9492"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga04ec8fb09a92b3abe9589be5000f9492"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga04ec8fb09a92b3abe9589be5000f9492">sum</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(sum(arg.tensor()))</td></tr>
<tr class="memdesc:ga04ec8fb09a92b3abe9589be5000f9492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the elements of a tile.  <a href="group___tile_interface.html#ga04ec8fb09a92b3abe9589be5000f9492">More...</a><br /></td></tr>
<tr class="separator:ga04ec8fb09a92b3abe9589be5000f9492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613b5d3ecf44ab93db507f75c29d173a"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga613b5d3ecf44ab93db507f75c29d173a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga613b5d3ecf44ab93db507f75c29d173a">product</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(product(arg.tensor()))</td></tr>
<tr class="memdesc:ga613b5d3ecf44ab93db507f75c29d173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements of a tile.  <a href="group___tile_interface.html#ga613b5d3ecf44ab93db507f75c29d173a">More...</a><br /></td></tr>
<tr class="separator:ga613b5d3ecf44ab93db507f75c29d173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c5417cb4508e40b5fae1d9d04ade3e"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gab1c5417cb4508e40b5fae1d9d04ade3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab1c5417cb4508e40b5fae1d9d04ade3e">squared_norm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(squared_norm(arg.tensor()))</td></tr>
<tr class="memdesc:gab1c5417cb4508e40b5fae1d9d04ade3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared vector 2-norm of the elements of a tile.  <a href="group___tile_interface.html#gab1c5417cb4508e40b5fae1d9d04ade3e">More...</a><br /></td></tr>
<tr class="separator:gab1c5417cb4508e40b5fae1d9d04ade3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9255d1d4a863c9a48f064b84fef91b52"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga9255d1d4a863c9a48f064b84fef91b52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga9255d1d4a863c9a48f064b84fef91b52">norm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(norm(arg.tensor()))</td></tr>
<tr class="memdesc:ga9255d1d4a863c9a48f064b84fef91b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___tile_interface.html#ga9255d1d4a863c9a48f064b84fef91b52">More...</a><br /></td></tr>
<tr class="separator:ga9255d1d4a863c9a48f064b84fef91b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7f8b80529dedefc0e3c66a9d025d4d"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga8c7f8b80529dedefc0e3c66a9d025d4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga8c7f8b80529dedefc0e3c66a9d025d4d">max</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(max(arg.tensor()))</td></tr>
<tr class="memdesc:ga8c7f8b80529dedefc0e3c66a9d025d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element of a tile.  <a href="group___tile_interface.html#ga8c7f8b80529dedefc0e3c66a9d025d4d">More...</a><br /></td></tr>
<tr class="separator:ga8c7f8b80529dedefc0e3c66a9d025d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e7d9a1fc31284c59c4e6fbe291426b"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gab3e7d9a1fc31284c59c4e6fbe291426b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gab3e7d9a1fc31284c59c4e6fbe291426b">min</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(min(arg.tensor()))</td></tr>
<tr class="memdesc:gab3e7d9a1fc31284c59c4e6fbe291426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element of a tile.  <a href="group___tile_interface.html#gab3e7d9a1fc31284c59c4e6fbe291426b">More...</a><br /></td></tr>
<tr class="separator:gab3e7d9a1fc31284c59c4e6fbe291426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a16734fa57b8e70b544d2aeff1ba70"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gad2a16734fa57b8e70b544d2aeff1ba70"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad2a16734fa57b8e70b544d2aeff1ba70">abs_max</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(abs_max(arg.tensor()))</td></tr>
<tr class="memdesc:gad2a16734fa57b8e70b544d2aeff1ba70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element of a tile.  <a href="group___tile_interface.html#gad2a16734fa57b8e70b544d2aeff1ba70">More...</a><br /></td></tr>
<tr class="separator:gad2a16734fa57b8e70b544d2aeff1ba70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04404704f571684e375fea64287be7a2"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga04404704f571684e375fea64287be7a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga04404704f571684e375fea64287be7a2">abs_min</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(abs_min(arg.tensor()))</td></tr>
<tr class="memdesc:ga04404704f571684e375fea64287be7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute mainimum element of a tile.  <a href="group___tile_interface.html#ga04404704f571684e375fea64287be7a2">More...</a><br /></td></tr>
<tr class="separator:ga04404704f571684e375fea64287be7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2becd6ff2cf1762aaacbbab565b18fca"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga2becd6ff2cf1762aaacbbab565b18fca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2becd6ff2cf1762aaacbbab565b18fca">dot</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; decltype(dot(left.tensor(), right.tensor()))</td></tr>
<tr class="memdesc:ga2becd6ff2cf1762aaacbbab565b18fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product of a tile.  <a href="group___tile_interface.html#ga2becd6ff2cf1762aaacbbab565b18fca">More...</a><br /></td></tr>
<tr class="separator:ga2becd6ff2cf1762aaacbbab565b18fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c3b5baf14a350fd02f5b04a46b7e22"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga68c3b5baf14a350fd02f5b04a46b7e22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga68c3b5baf14a350fd02f5b04a46b7e22">operator+</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; decltype(<a class="el" href="group___tile_interface.html#gaa94ec03e0af35cc7da26e8fbbf4a6be3">add</a>(left, right))</td></tr>
<tr class="memdesc:ga68c3b5baf14a350fd02f5b04a46b7e22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> tiles operator.  <a href="group___tile_interface.html#ga68c3b5baf14a350fd02f5b04a46b7e22">More...</a><br /></td></tr>
<tr class="separator:ga68c3b5baf14a350fd02f5b04a46b7e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bcee0014e3c777ff47264fea368e2d"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gae7bcee0014e3c777ff47264fea368e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gae7bcee0014e3c777ff47264fea368e2d">operator+=</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gae7bcee0014e3c777ff47264fea368e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place add tile operator.  <a href="group___tile_interface.html#gae7bcee0014e3c777ff47264fea368e2d">More...</a><br /></td></tr>
<tr class="separator:gae7bcee0014e3c777ff47264fea368e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e159dfcc23e9d617fedc259225f5f09"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga8e159dfcc23e9d617fedc259225f5f09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga8e159dfcc23e9d617fedc259225f5f09">operator-</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; decltype(<a class="el" href="group___tile_interface.html#ga0e009bc78f47589f3ff1a609b6fc99f0">subt</a>(left, right))</td></tr>
<tr class="memdesc:ga8e159dfcc23e9d617fedc259225f5f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tiles operator.  <a href="group___tile_interface.html#ga8e159dfcc23e9d617fedc259225f5f09">More...</a><br /></td></tr>
<tr class="separator:ga8e159dfcc23e9d617fedc259225f5f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4f4e0878d1128d2b692b6a8e60113c28">operator-=</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtract tile operator.  <a href="group___tile_interface.html#ga4f4e0878d1128d2b692b6a8e60113c28">More...</a><br /></td></tr>
<tr class="separator:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537e30e5ed35d241cabca6b1510ba69c"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga537e30e5ed35d241cabca6b1510ba69c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga537e30e5ed35d241cabca6b1510ba69c">operator*</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; decltype(<a class="el" href="group___tile_interface.html#ga4cf680dc2cab0353728f84f07a4fbd9e">mult</a>(left, right))</td></tr>
<tr class="memdesc:ga537e30e5ed35d241cabca6b1510ba69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product tiles operator.  <a href="group___tile_interface.html#ga537e30e5ed35d241cabca6b1510ba69c">More...</a><br /></td></tr>
<tr class="separator:ga537e30e5ed35d241cabca6b1510ba69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c180d6f3370d90259cd7f3b3ce17eba"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename std::enable_if&lt; detail::is_numeric&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0c180d6f3370d90259cd7f3b3ce17eba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0c180d6f3370d90259cd7f3b3ce17eba">operator*</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const Right right) -&gt; decltype(<a class="el" href="namespace_tiled_array.html#a90e2f4b420375c45a2c21049e27377aa">scale</a>(left, right))</td></tr>
<tr class="memdesc:ga0c180d6f3370d90259cd7f3b3ce17eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale tile operator.  <a href="group___tile_interface.html#ga0c180d6f3370d90259cd7f3b3ce17eba">More...</a><br /></td></tr>
<tr class="separator:ga0c180d6f3370d90259cd7f3b3ce17eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c8f19ae675175a2a97b4931197ef3f"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Left &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga31c8f19ae675175a2a97b4931197ef3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga31c8f19ae675175a2a97b4931197ef3f">operator*</a> (const Left left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right) -&gt; decltype(<a class="el" href="namespace_tiled_array.html#a90e2f4b420375c45a2c21049e27377aa">scale</a>(right, left))</td></tr>
<tr class="memdesc:ga31c8f19ae675175a2a97b4931197ef3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale tile operator.  <a href="group___tile_interface.html#ga31c8f19ae675175a2a97b4931197ef3f">More...</a><br /></td></tr>
<tr class="separator:ga31c8f19ae675175a2a97b4931197ef3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40462eb6de7951619ea2f31b310920de"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga40462eb6de7951619ea2f31b310920de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga40462eb6de7951619ea2f31b310920de">operator*=</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga40462eb6de7951619ea2f31b310920de"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place product tile operator.  <a href="group___tile_interface.html#ga40462eb6de7951619ea2f31b310920de">More...</a><br /></td></tr>
<tr class="separator:ga40462eb6de7951619ea2f31b310920de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793c6f07aa3ede5a1a01953d4e51c583"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga793c6f07aa3ede5a1a01953d4e51c583"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga793c6f07aa3ede5a1a01953d4e51c583">operator-</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg) -&gt; decltype(<a class="el" href="group___tile_interface.html#gab5d7119054012d41b27804b6c37e8cb0">neg</a>(arg))</td></tr>
<tr class="memdesc:ga793c6f07aa3ede5a1a01953d4e51c583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate tile operator.  <a href="group___tile_interface.html#ga793c6f07aa3ede5a1a01953d4e51c583">More...</a><br /></td></tr>
<tr class="separator:ga793c6f07aa3ede5a1a01953d4e51c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3f87e710a8a29e189628ac925fb128"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaaa3f87e710a8a29e189628ac925fb128"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaaa3f87e710a8a29e189628ac925fb128">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; const arg) -&gt; decltype(<a class="el" href="group___tile_interface.html#ga040f23a684e2cfec50be13936d603709">permute</a>(arg, perm))</td></tr>
<tr class="memdesc:gaaa3f87e710a8a29e189628ac925fb128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute tile operator.  <a href="group___tile_interface.html#gaaa3f87e710a8a29e189628ac925fb128">More...</a><br /></td></tr>
<tr class="separator:gaaa3f87e710a8a29e189628ac925fb128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07ca3ab32da77765c0546689feb400f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac07ca3ab32da77765c0546689feb400f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac07ca3ab32da77765c0546689feb400f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T &gt; &amp;tile)</td></tr>
<tr class="memdesc:gac07ca3ab32da77765c0546689feb400f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> output stream operator.  <a href="group___tile_interface.html#gac07ca3ab32da77765c0546689feb400f">More...</a><br /></td></tr>
<tr class="separator:gac07ca3ab32da77765c0546689feb400f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866114e8133f9d4d7fcebecd70b2408c"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga866114e8133f9d4d7fcebecd70b2408c"><td class="memTemplItemLeft" align="right" valign="top">Arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga866114e8133f9d4d7fcebecd70b2408c">clone</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga866114e8133f9d4d7fcebecd70b2408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>arg</code>.  <a href="group___non_intrusive_tile_interface.html#ga866114e8133f9d4d7fcebecd70b2408c">More...</a><br /></td></tr>
<tr class="separator:ga866114e8133f9d4d7fcebecd70b2408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e30a38677b11760448ab87f07ff0aed"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga9e30a38677b11760448ab87f07ff0aed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9e30a38677b11760448ab87f07ff0aed">empty</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga9e30a38677b11760448ab87f07ff0aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that <code>arg</code> is empty (no data)  <a href="group___non_intrusive_tile_interface.html#ga9e30a38677b11760448ab87f07ff0aed">More...</a><br /></td></tr>
<tr class="separator:ga9e30a38677b11760448ab87f07ff0aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed996654520b8ea42e5398a3599dc584"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:gaed996654520b8ea42e5398a3599dc584"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaed996654520b8ea42e5398a3599dc584">shift</a> (const Arg &amp;arg, const Index &amp;range_shift) -&gt; decltype(arg.shift(range_shift))</td></tr>
<tr class="memdesc:gaed996654520b8ea42e5398a3599dc584"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the range of <code>arg</code>.  <a href="group___non_intrusive_tile_interface.html#gaed996654520b8ea42e5398a3599dc584">More...</a><br /></td></tr>
<tr class="separator:gaed996654520b8ea42e5398a3599dc584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf2cdfb3fb1485368b8b94d5a5d498a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:ga7bf2cdfb3fb1485368b8b94d5a5d498a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7bf2cdfb3fb1485368b8b94d5a5d498a">shift_to</a> (Arg &amp;arg, const Index &amp;range_shift) -&gt; decltype(arg.shift_to(range_shift))</td></tr>
<tr class="memdesc:ga7bf2cdfb3fb1485368b8b94d5a5d498a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> the range of <code>arg</code> in place.  <a href="group___non_intrusive_tile_interface.html#ga7bf2cdfb3fb1485368b8b94d5a5d498a">More...</a><br /></td></tr>
<tr class="separator:ga7bf2cdfb3fb1485368b8b94d5a5d498a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf23e16f596128d9761cc332dfc91df94"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaf23e16f596128d9761cc332dfc91df94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf23e16f596128d9761cc332dfc91df94">permute</a> (const Arg &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(arg.permute(perm))</td></tr>
<tr class="memdesc:gaf23e16f596128d9761cc332dfc91df94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="group___non_intrusive_tile_interface.html#gaf23e16f596128d9761cc332dfc91df94">More...</a><br /></td></tr>
<tr class="separator:gaf23e16f596128d9761cc332dfc91df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga87ca6bca2735b62e0eaf5cac4a3cba58">add</a> (const Left &amp;left, const Right &amp;right) -&gt; decltype(left.add(right))</td></tr>
<tr class="memdesc:ga87ca6bca2735b62e0eaf5cac4a3cba58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga87ca6bca2735b62e0eaf5cac4a3cba58">More...</a><br /></td></tr>
<tr class="separator:ga87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf14bbb8081e2d6e22289f4cdfd04660"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaaf14bbb8081e2d6e22289f4cdfd04660"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaaf14bbb8081e2d6e22289f4cdfd04660">add</a> (const Left &amp;left, const Right &amp;right, const Scalar factor) -&gt; decltype(left.add(right, factor))</td></tr>
<tr class="memdesc:gaaf14bbb8081e2d6e22289f4cdfd04660"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#gaaf14bbb8081e2d6e22289f4cdfd04660">More...</a><br /></td></tr>
<tr class="separator:gaaf14bbb8081e2d6e22289f4cdfd04660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ab1d92c35796ab1486d23f2db26254"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga31ab1d92c35796ab1486d23f2db26254"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga31ab1d92c35796ab1486d23f2db26254">add</a> (const Left &amp;left, const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(left.add(right, perm))</td></tr>
<tr class="memdesc:ga31ab1d92c35796ab1486d23f2db26254"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga31ab1d92c35796ab1486d23f2db26254">More...</a><br /></td></tr>
<tr class="separator:ga31ab1d92c35796ab1486d23f2db26254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafddf7c5bbd67501e40f06c0765c5be62"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gafddf7c5bbd67501e40f06c0765c5be62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gafddf7c5bbd67501e40f06c0765c5be62">add</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(left.add(right, factor, perm))</td></tr>
<tr class="memdesc:gafddf7c5bbd67501e40f06c0765c5be62"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a>, scale, and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#gafddf7c5bbd67501e40f06c0765c5be62">More...</a><br /></td></tr>
<tr class="separator:gafddf7c5bbd67501e40f06c0765c5be62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92c23d2910dd93d707b147ed5b4b25e9"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga92c23d2910dd93d707b147ed5b4b25e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga92c23d2910dd93d707b147ed5b4b25e9">add</a> (const Arg &amp;arg, const Scalar value) -&gt; decltype(arg.add(value))</td></tr>
<tr class="memdesc:ga92c23d2910dd93d707b147ed5b4b25e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant scalar to tile argument.  <a href="group___non_intrusive_tile_interface.html#ga92c23d2910dd93d707b147ed5b4b25e9">More...</a><br /></td></tr>
<tr class="separator:ga92c23d2910dd93d707b147ed5b4b25e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f733570b627372fca1fd383c1f1ed5"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17f733570b627372fca1fd383c1f1ed5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga17f733570b627372fca1fd383c1f1ed5">add</a> (const Arg &amp;arg, const Scalar value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(arg.add(value, perm))</td></tr>
<tr class="memdesc:ga17f733570b627372fca1fd383c1f1ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> a constant scalar and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#ga17f733570b627372fca1fd383c1f1ed5">More...</a><br /></td></tr>
<tr class="separator:ga17f733570b627372fca1fd383c1f1ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b6f318b11b3abb7986751995a880d0"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:gaf7b6f318b11b3abb7986751995a880d0"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf7b6f318b11b3abb7986751995a880d0">add_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:gaf7b6f318b11b3abb7986751995a880d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> to the result tile.  <a href="group___non_intrusive_tile_interface.html#gaf7b6f318b11b3abb7986751995a880d0">More...</a><br /></td></tr>
<tr class="separator:gaf7b6f318b11b3abb7986751995a880d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ec71822bfc6ea2da939913f8ee8f02"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17ec71822bfc6ea2da939913f8ee8f02"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga17ec71822bfc6ea2da939913f8ee8f02">add_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga17ec71822bfc6ea2da939913f8ee8f02"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> and scale to the result tile.  <a href="group___non_intrusive_tile_interface.html#ga17ec71822bfc6ea2da939913f8ee8f02">More...</a><br /></td></tr>
<tr class="separator:ga17ec71822bfc6ea2da939913f8ee8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26cd89145d26a3ed4f929780cfa5241c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga26cd89145d26a3ed4f929780cfa5241c"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga26cd89145d26a3ed4f929780cfa5241c">add_to</a> (Result &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:ga26cd89145d26a3ed4f929780cfa5241c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> constant scalar to the result tile.  <a href="group___non_intrusive_tile_interface.html#ga26cd89145d26a3ed4f929780cfa5241c">More...</a><br /></td></tr>
<tr class="separator:ga26cd89145d26a3ed4f929780cfa5241c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7611e5d06e9a3fda3310e95648f3cacf"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga7611e5d06e9a3fda3310e95648f3cacf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7611e5d06e9a3fda3310e95648f3cacf">subt</a> (const Left &amp;left, const Right &amp;right) -&gt; decltype(left.subt(right))</td></tr>
<tr class="memdesc:ga7611e5d06e9a3fda3310e95648f3cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga7611e5d06e9a3fda3310e95648f3cacf">More...</a><br /></td></tr>
<tr class="separator:ga7611e5d06e9a3fda3310e95648f3cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7acc05497f9f79b53abda748c4ac2db0"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7acc05497f9f79b53abda748c4ac2db0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7acc05497f9f79b53abda748c4ac2db0">subt</a> (const Left &amp;left, const Right &amp;right, const Scalar factor) -&gt; decltype(left.subt(right, factor))</td></tr>
<tr class="memdesc:ga7acc05497f9f79b53abda748c4ac2db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga7acc05497f9f79b53abda748c4ac2db0">More...</a><br /></td></tr>
<tr class="separator:ga7acc05497f9f79b53abda748c4ac2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854f7914d248e57232f1b0536d0509ff"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga854f7914d248e57232f1b0536d0509ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga854f7914d248e57232f1b0536d0509ff">subt</a> (const Left &amp;left, const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(left.subt(right, perm))</td></tr>
<tr class="memdesc:ga854f7914d248e57232f1b0536d0509ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga854f7914d248e57232f1b0536d0509ff">More...</a><br /></td></tr>
<tr class="separator:ga854f7914d248e57232f1b0536d0509ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d1d7aefddae3ded87c2ec9a8079758"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga53d1d7aefddae3ded87c2ec9a8079758"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga53d1d7aefddae3ded87c2ec9a8079758">subt</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(left.subt(right, factor, perm))</td></tr>
<tr class="memdesc:ga53d1d7aefddae3ded87c2ec9a8079758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract, scale, and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga53d1d7aefddae3ded87c2ec9a8079758">More...</a><br /></td></tr>
<tr class="separator:ga53d1d7aefddae3ded87c2ec9a8079758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b8774079fa1cf7534b045de9e592893"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6b8774079fa1cf7534b045de9e592893"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga6b8774079fa1cf7534b045de9e592893">subt</a> (const Arg &amp;arg, const Scalar value) -&gt; decltype(arg.subt(value))</td></tr>
<tr class="memdesc:ga6b8774079fa1cf7534b045de9e592893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar constant from the tile argument.  <a href="group___non_intrusive_tile_interface.html#ga6b8774079fa1cf7534b045de9e592893">More...</a><br /></td></tr>
<tr class="separator:ga6b8774079fa1cf7534b045de9e592893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8560ae176cc6e2778e27b7eab56d5bc"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gab8560ae176cc6e2778e27b7eab56d5bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab8560ae176cc6e2778e27b7eab56d5bc">subt</a> (const Arg &amp;arg, const Scalar value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(arg.subt(value, perm))</td></tr>
<tr class="memdesc:gab8560ae176cc6e2778e27b7eab56d5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant scalar and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#gab8560ae176cc6e2778e27b7eab56d5bc">More...</a><br /></td></tr>
<tr class="separator:gab8560ae176cc6e2778e27b7eab56d5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga6433ca823a7f563abbb980b72ee6dba3">subt_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga6433ca823a7f563abbb980b72ee6dba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from the result tile.  <a href="group___non_intrusive_tile_interface.html#ga6433ca823a7f563abbb980b72ee6dba3">More...</a><br /></td></tr>
<tr class="separator:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5666748f9fda3e3173eac160328bd5c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gab5666748f9fda3e3173eac160328bd5c"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab5666748f9fda3e3173eac160328bd5c">subt_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gab5666748f9fda3e3173eac160328bd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale from the result tile.  <a href="group___non_intrusive_tile_interface.html#gab5666748f9fda3e3173eac160328bd5c">More...</a><br /></td></tr>
<tr class="separator:gab5666748f9fda3e3173eac160328bd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae3c0183d91fdc7febc0aac4e0f929d97">subt_to</a> (Result &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract constant scalar from the result tile.  <a href="group___non_intrusive_tile_interface.html#gae3c0183d91fdc7febc0aac4e0f929d97">More...</a><br /></td></tr>
<tr class="separator:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ec3c1516a5c57f248cc3ab55340edc"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gae3ec3c1516a5c57f248cc3ab55340edc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae3ec3c1516a5c57f248cc3ab55340edc">mult</a> (const Left &amp;left, const Right &amp;right) -&gt; decltype(left.mult(right))</td></tr>
<tr class="memdesc:gae3ec3c1516a5c57f248cc3ab55340edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication tile arguments.  <a href="group___non_intrusive_tile_interface.html#gae3ec3c1516a5c57f248cc3ab55340edc">More...</a><br /></td></tr>
<tr class="separator:gae3ec3c1516a5c57f248cc3ab55340edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f863b4014e6abd547f521396d49840"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga19f863b4014e6abd547f521396d49840"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga19f863b4014e6abd547f521396d49840">mult</a> (const Left &amp;left, const Right &amp;right, const Scalar factor) -&gt; decltype(left.mult(right, factor))</td></tr>
<tr class="memdesc:ga19f863b4014e6abd547f521396d49840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga19f863b4014e6abd547f521396d49840">More...</a><br /></td></tr>
<tr class="separator:ga19f863b4014e6abd547f521396d49840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8072d55658a83681b276df98e0660513"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga8072d55658a83681b276df98e0660513"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga8072d55658a83681b276df98e0660513">mult</a> (const Left &amp;left, const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(left.mult(right, perm))</td></tr>
<tr class="memdesc:ga8072d55658a83681b276df98e0660513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga8072d55658a83681b276df98e0660513">More...</a><br /></td></tr>
<tr class="separator:ga8072d55658a83681b276df98e0660513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bc7569ae5a9a3598af11e20a243da9"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gad9bc7569ae5a9a3598af11e20a243da9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gad9bc7569ae5a9a3598af11e20a243da9">mult</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(left.mult(right, factor, perm))</td></tr>
<tr class="memdesc:gad9bc7569ae5a9a3598af11e20a243da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication, scale, and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#gad9bc7569ae5a9a3598af11e20a243da9">More...</a><br /></td></tr>
<tr class="separator:gad9bc7569ae5a9a3598af11e20a243da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d5fd9f983b98c143a694fa82166585"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:gaf8d5fd9f983b98c143a694fa82166585"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf8d5fd9f983b98c143a694fa82166585">mult_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:gaf8d5fd9f983b98c143a694fa82166585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply to the result tile.  <a href="group___non_intrusive_tile_interface.html#gaf8d5fd9f983b98c143a694fa82166585">More...</a><br /></td></tr>
<tr class="separator:gaf8d5fd9f983b98c143a694fa82166585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5b9a07027db87b4785e7e9f2f31cc567">mult_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and scale to the result tile.  <a href="group___non_intrusive_tile_interface.html#ga5b9a07027db87b4785e7e9f2f31cc567">More...</a><br /></td></tr>
<tr class="separator:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae120f60269d6f9a0d68bbd452156e512"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae120f60269d6f9a0d68bbd452156e512"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae120f60269d6f9a0d68bbd452156e512">scale</a> (const Arg &amp;arg, const Scalar factor) -&gt; decltype(arg.scale(factor))</td></tr>
<tr class="memdesc:gae120f60269d6f9a0d68bbd452156e512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar the tile argument.  <a href="group___non_intrusive_tile_interface.html#gae120f60269d6f9a0d68bbd452156e512">More...</a><br /></td></tr>
<tr class="separator:gae120f60269d6f9a0d68bbd452156e512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e238a5954c9201a5a232c637850cdc"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa9e238a5954c9201a5a232c637850cdc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaa9e238a5954c9201a5a232c637850cdc">scale</a> (const Arg &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(arg.scale(factor, perm))</td></tr>
<tr class="memdesc:gaa9e238a5954c9201a5a232c637850cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#gaa9e238a5954c9201a5a232c637850cdc">More...</a><br /></td></tr>
<tr class="separator:gaa9e238a5954c9201a5a232c637850cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10222cde45203777a4b3a6dc2d2d72d"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac10222cde45203777a4b3a6dc2d2d72d"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gac10222cde45203777a4b3a6dc2d2d72d">scale_to</a> (Result &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:gac10222cde45203777a4b3a6dc2d2d72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale to the result tile.  <a href="group___non_intrusive_tile_interface.html#gac10222cde45203777a4b3a6dc2d2d72d">More...</a><br /></td></tr>
<tr class="separator:gac10222cde45203777a4b3a6dc2d2d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2f342af158465d348668bd5bb978b7"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gade2f342af158465d348668bd5bb978b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gade2f342af158465d348668bd5bb978b7">neg</a> (const Arg &amp;arg) -&gt; decltype(arg.neg())</td></tr>
<tr class="memdesc:gade2f342af158465d348668bd5bb978b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the tile argument.  <a href="group___non_intrusive_tile_interface.html#gade2f342af158465d348668bd5bb978b7">More...</a><br /></td></tr>
<tr class="separator:gade2f342af158465d348668bd5bb978b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a1f3d20d3d6da90c12e29879fe7289"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaf3a1f3d20d3d6da90c12e29879fe7289"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf3a1f3d20d3d6da90c12e29879fe7289">neg</a> (const Arg &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(arg.neg(perm))</td></tr>
<tr class="memdesc:gaf3a1f3d20d3d6da90c12e29879fe7289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#gaf3a1f3d20d3d6da90c12e29879fe7289">More...</a><br /></td></tr>
<tr class="separator:gaf3a1f3d20d3d6da90c12e29879fe7289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga0983dfc5809ebfca2de350b5bf42dca0">neg_to</a> (Result &amp;result)</td></tr>
<tr class="memdesc:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication constant scalar to a tile.  <a href="group___non_intrusive_tile_interface.html#ga0983dfc5809ebfca2de350b5bf42dca0">More...</a><br /></td></tr>
<tr class="separator:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87213011b8c50f78163c06418ffc9b14"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga87213011b8c50f78163c06418ffc9b14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga87213011b8c50f78163c06418ffc9b14">conj</a> (const Arg &amp;arg) -&gt; decltype(arg.conj())</td></tr>
<tr class="memdesc:ga87213011b8c50f78163c06418ffc9b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of a tile.  <a href="group___non_intrusive_tile_interface.html#ga87213011b8c50f78163c06418ffc9b14">More...</a><br /></td></tr>
<tr class="separator:ga87213011b8c50f78163c06418ffc9b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927149238201ac7a3bd6e6a302f0281b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt;                                  TiledArray::detail::is_numeric&lt; Scalar &gt;::value               &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga927149238201ac7a3bd6e6a302f0281b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga927149238201ac7a3bd6e6a302f0281b">conj</a> (const Arg &amp;arg, const Scalar factor) -&gt; decltype(arg.conj(factor))</td></tr>
<tr class="memdesc:ga927149238201ac7a3bd6e6a302f0281b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of a tile.  <a href="group___non_intrusive_tile_interface.html#ga927149238201ac7a3bd6e6a302f0281b">More...</a><br /></td></tr>
<tr class="separator:ga927149238201ac7a3bd6e6a302f0281b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a8c28be49ceb7f072d8bc6c9f9507c"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaf8a8c28be49ceb7f072d8bc6c9f9507c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf8a8c28be49ceb7f072d8bc6c9f9507c">conj</a> (const Arg &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(arg.conj(perm))</td></tr>
<tr class="memdesc:gaf8a8c28be49ceb7f072d8bc6c9f9507c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of a tile.  <a href="group___non_intrusive_tile_interface.html#gaf8a8c28be49ceb7f072d8bc6c9f9507c">More...</a><br /></td></tr>
<tr class="separator:gaf8a8c28be49ceb7f072d8bc6c9f9507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d229a48d9efe566224d75095f186c0"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt;                                  TiledArray::detail::is_numeric&lt; Scalar &gt;::value               &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa4d229a48d9efe566224d75095f186c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaa4d229a48d9efe566224d75095f186c0">conj</a> (const Arg &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm) -&gt; decltype(arg.conj(factor, perm))</td></tr>
<tr class="memdesc:gaa4d229a48d9efe566224d75095f186c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of a tile.  <a href="group___non_intrusive_tile_interface.html#gaa4d229a48d9efe566224d75095f186c0">More...</a><br /></td></tr>
<tr class="separator:gaa4d229a48d9efe566224d75095f186c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga65b3ee6f080b8a842bba1e7a56afb794">conj_to</a> (Result &amp;result)</td></tr>
<tr class="memdesc:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate a tile.  <a href="group___non_intrusive_tile_interface.html#ga65b3ee6f080b8a842bba1e7a56afb794">More...</a><br /></td></tr>
<tr class="separator:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt;                                  TiledArray::detail::is_numeric&lt; Scalar &gt;::value               &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5e2f551d8e19e04b8fa91c6a0da7d18c">conj_to</a> (Result &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate and scale a tile.  <a href="group___non_intrusive_tile_interface.html#ga5e2f551d8e19e04b8fa91c6a0da7d18c">More...</a><br /></td></tr>
<tr class="separator:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db8e9e48946aa55061a5e492ca9e354"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7db8e9e48946aa55061a5e492ca9e354"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7db8e9e48946aa55061a5e492ca9e354">gemm</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config) -&gt; decltype(left.gemm(right, factor, gemm_config))</td></tr>
<tr class="memdesc:ga7db8e9e48946aa55061a5e492ca9e354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga7db8e9e48946aa55061a5e492ca9e354">More...</a><br /></td></tr>
<tr class="separator:ga7db8e9e48946aa55061a5e492ca9e354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb5f80c0b106673576299ae702e129"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7fcb5f80c0b106673576299ae702e129"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7fcb5f80c0b106673576299ae702e129">gemm</a> (Result &amp;result, const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga7fcb5f80c0b106673576299ae702e129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments to the result tile.  <a href="group___non_intrusive_tile_interface.html#ga7fcb5f80c0b106673576299ae702e129">More...</a><br /></td></tr>
<tr class="separator:ga7fcb5f80c0b106673576299ae702e129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab076d9dc13b30efebb8b9b5d87e88fe0"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gab076d9dc13b30efebb8b9b5d87e88fe0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab076d9dc13b30efebb8b9b5d87e88fe0">trace</a> (const Arg &amp;arg) -&gt; decltype(arg.trace())</td></tr>
<tr class="memdesc:gab076d9dc13b30efebb8b9b5d87e88fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the hyper-diagonal elements a tile.  <a href="group___non_intrusive_tile_interface.html#gab076d9dc13b30efebb8b9b5d87e88fe0">More...</a><br /></td></tr>
<tr class="separator:gab076d9dc13b30efebb8b9b5d87e88fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249653057ef2ca720682a712e37742c6"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga249653057ef2ca720682a712e37742c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga249653057ef2ca720682a712e37742c6">sum</a> (const Arg &amp;arg) -&gt; decltype(arg.sum())</td></tr>
<tr class="memdesc:ga249653057ef2ca720682a712e37742c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#ga249653057ef2ca720682a712e37742c6">More...</a><br /></td></tr>
<tr class="separator:ga249653057ef2ca720682a712e37742c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569a94d2d8ee754bca97ab8c32759233"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga569a94d2d8ee754bca97ab8c32759233"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga569a94d2d8ee754bca97ab8c32759233">product</a> (const Arg &amp;arg) -&gt; decltype(arg.product())</td></tr>
<tr class="memdesc:ga569a94d2d8ee754bca97ab8c32759233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#ga569a94d2d8ee754bca97ab8c32759233">More...</a><br /></td></tr>
<tr class="separator:ga569a94d2d8ee754bca97ab8c32759233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab247e1bf9f6082796fac3dec22b427c6"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gab247e1bf9f6082796fac3dec22b427c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab247e1bf9f6082796fac3dec22b427c6">squared_norm</a> (const Arg &amp;arg) -&gt; decltype(arg.squared_norm())</td></tr>
<tr class="memdesc:gab247e1bf9f6082796fac3dec22b427c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared vector 2-norm of the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#gab247e1bf9f6082796fac3dec22b427c6">More...</a><br /></td></tr>
<tr class="separator:gab247e1bf9f6082796fac3dec22b427c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbeed1dca754abd7f31c867ef5ded0ec"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gadbeed1dca754abd7f31c867ef5ded0ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gadbeed1dca754abd7f31c867ef5ded0ec">norm</a> (const Arg &amp;arg) -&gt; decltype(arg.norm())</td></tr>
<tr class="memdesc:gadbeed1dca754abd7f31c867ef5ded0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___non_intrusive_tile_interface.html#gadbeed1dca754abd7f31c867ef5ded0ec">More...</a><br /></td></tr>
<tr class="separator:gadbeed1dca754abd7f31c867ef5ded0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1c6464956e87e23c0808ca2a668411"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga4e1c6464956e87e23c0808ca2a668411"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga4e1c6464956e87e23c0808ca2a668411">max</a> (const Arg &amp;arg) -&gt; decltype(arg.max())</td></tr>
<tr class="memdesc:ga4e1c6464956e87e23c0808ca2a668411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga4e1c6464956e87e23c0808ca2a668411">More...</a><br /></td></tr>
<tr class="separator:ga4e1c6464956e87e23c0808ca2a668411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a672d16ca0c1d77906e0a14cf04be3d"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga9a672d16ca0c1d77906e0a14cf04be3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9a672d16ca0c1d77906e0a14cf04be3d">min</a> (const Arg &amp;arg) -&gt; decltype(arg.min())</td></tr>
<tr class="memdesc:ga9a672d16ca0c1d77906e0a14cf04be3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga9a672d16ca0c1d77906e0a14cf04be3d">More...</a><br /></td></tr>
<tr class="separator:ga9a672d16ca0c1d77906e0a14cf04be3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973d736b80129e70a4378765be1adfa3"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga973d736b80129e70a4378765be1adfa3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga973d736b80129e70a4378765be1adfa3">abs_max</a> (const Arg &amp;arg) -&gt; decltype(arg.abs_max())</td></tr>
<tr class="memdesc:ga973d736b80129e70a4378765be1adfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga973d736b80129e70a4378765be1adfa3">More...</a><br /></td></tr>
<tr class="separator:ga973d736b80129e70a4378765be1adfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f183815ca14ce3a4f9a597375c830e"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga44f183815ca14ce3a4f9a597375c830e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga44f183815ca14ce3a4f9a597375c830e">abs_min</a> (const Arg &amp;arg) -&gt; decltype(arg.abs_min())</td></tr>
<tr class="memdesc:ga44f183815ca14ce3a4f9a597375c830e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute mainimum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga44f183815ca14ce3a4f9a597375c830e">More...</a><br /></td></tr>
<tr class="separator:ga44f183815ca14ce3a4f9a597375c830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d184e26e0ea04d8efd04a460f79343a"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga7d184e26e0ea04d8efd04a460f79343a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7d184e26e0ea04d8efd04a460f79343a">dot</a> (const Left &amp;left, const Right &amp;right) -&gt; decltype(left.dot(right))</td></tr>
<tr class="memdesc:ga7d184e26e0ea04d8efd04a460f79343a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product of a tile.  <a href="group___non_intrusive_tile_interface.html#ga7d184e26e0ea04d8efd04a460f79343a">More...</a><br /></td></tr>
<tr class="separator:ga7d184e26e0ea04d8efd04a460f79343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1fa4c93060bc503429e3527f2993ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2b1fa4c93060bc503429e3527f2993ad">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r)</td></tr>
<tr class="memdesc:a2b1fa4c93060bc503429e3527f2993ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of an N-dimensional, tiled tensor. ">TiledRange</a> permutation operator.  <a href="#a2b1fa4c93060bc503429e3527f2993ad">More...</a><br /></td></tr>
<tr class="separator:a2b1fa4c93060bc503429e3527f2993ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0947b0d351b9ee0112b292eb869249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4b0947b0d351b9ee0112b292eb869249">swap</a> (<a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1)</td></tr>
<tr class="memdesc:a4b0947b0d351b9ee0112b292eb869249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the content of the two given <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of an N-dimensional, tiled tensor. ">TiledRange</a>'s.  <a href="#a4b0947b0d351b9ee0112b292eb869249">More...</a><br /></td></tr>
<tr class="separator:a4b0947b0d351b9ee0112b292eb869249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a1447230c9a5ca4906ee3684cbe890"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a95a1447230c9a5ca4906ee3684cbe890">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r2)</td></tr>
<tr class="memdesc:a95a1447230c9a5ca4906ee3684cbe890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when all tile and element ranges are the same.  <a href="#a95a1447230c9a5ca4906ee3684cbe890">More...</a><br /></td></tr>
<tr class="separator:a95a1447230c9a5ca4906ee3684cbe890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282e9e655ef9479b267ac1975d77eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4282e9e655ef9479b267ac1975d77eb6">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r2)</td></tr>
<tr class="separator:a4282e9e655ef9479b267ac1975d77eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42dd6da4a499c34371973b91d3529c0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac42dd6da4a499c34371973b91d3529c0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;rng)</td></tr>
<tr class="separator:ac42dd6da4a499c34371973b91d3529c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abe5632aeeaf569807a5e38b4ae1c5a98">swap</a> (<a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1)</td></tr>
<tr class="memdesc:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the data of the two given ranges.  <a href="#abe5632aeeaf569807a5e38b4ae1c5a98">More...</a><br /></td></tr>
<tr class="separator:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0508aa5150620ac2a2a5476c6c5612"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9e0508aa5150620ac2a2a5476c6c5612">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:a9e0508aa5150620ac2a2a5476c6c5612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a9e0508aa5150620ac2a2a5476c6c5612">More...</a><br /></td></tr>
<tr class="separator:a9e0508aa5150620ac2a2a5476c6c5612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a49a6fdebe3f7dff3beb2637c2c48809f">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a49a6fdebe3f7dff3beb2637c2c48809f">More...</a><br /></td></tr>
<tr class="separator:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3e4d830e8d3e6b0c3ef4db415eeed8f3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;rng)</td></tr>
<tr class="memdesc:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> ostream operator.  <a href="#a3e4d830e8d3e6b0c3ef4db415eeed8f3">More...</a><br /></td></tr>
<tr class="separator:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="adf28ccfd580f62de5342a9a1510e22e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int, typename Tile  = Tensor&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;, typename Policy  = DensePolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">TiledArray::Array</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00072">72</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a598c53efb66f9c18b8a6b5bcfbeaf8f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;double&gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#a598c53efb66f9c18b8a6b5bcfbeaf8f3">TiledArray::EigenMatrixXcd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00042">42</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="adde89f3f1e4ba23ddf9ce7b6e2db088f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;float&gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#adde89f3f1e4ba23ddf9ce7b6e2db088f">TiledArray::EigenMatrixXcf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00043">43</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac5db88c965b8d32f1f72d37d3dc3561c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#ac5db88c965b8d32f1f72d37d3dc3561c">TiledArray::EigenMatrixXd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00040">40</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="aacdf44d8771941244661bf77cf07069e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#aacdf44d8771941244661bf77cf07069e">TiledArray::EigenMatrixXf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00041">41</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5d1d4be6c1d3cef049c42490778da56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#ae5d1d4be6c1d3cef049c42490778da56">TiledArray::EigenMatrixXi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00044">44</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="afa83a358322961f1da1b50d5e28ae0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#afa83a358322961f1da1b50d5e28ae0ea">TiledArray::EigenMatrixXl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00045">45</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19c2ebf917a509ec12deca6a13dd1904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;double&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespace_tiled_array.html#a19c2ebf917a509ec12deca6a13dd1904">TiledArray::EigenVectorXcd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00048">48</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="abfe17eddb0710849aa9af552f4f85098"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;float&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespace_tiled_array.html#abfe17eddb0710849aa9af552f4f85098">TiledArray::EigenVectorXcf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00049">49</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa783ea4f581c1c1bb75f647d68c65a68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;double, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#aa783ea4f581c1c1bb75f647d68c65a68">TiledArray::EigenVectorXd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00046">46</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0c54f8e9145825b6155cf5389a9ee03a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;float, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#a0c54f8e9145825b6155cf5389a9ee03a">TiledArray::EigenVectorXf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00047">47</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="acb38a6b56111826e5b451528b939eb60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;int, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#acb38a6b56111826e5b451528b939eb60">TiledArray::EigenVectorXi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00050">50</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec5f429338b7707830ce0339ebaf6274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;long, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#aec5f429338b7707830ce0339ebaf6274">TiledArray::EigenVectorXl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00051">51</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a14381436074bbf8eff68427766e395a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TiledArray::TArray</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;T&gt; &gt;, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00053">53</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea17c71440d5a58110b7ade911cf1102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;std::complex&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#aea17c71440d5a58110b7ade911cf1102">TiledArray::TArrayC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00059">59</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b25748e8f1dd4d7421925264bbe4905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;double&gt; <a class="el" href="namespace_tiled_array.html#a0b25748e8f1dd4d7421925264bbe4905">TiledArray::TArrayD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00054">54</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaeec85e445a8f0330f135292858a3cb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;float&gt; <a class="el" href="namespace_tiled_array.html#aaeec85e445a8f0330f135292858a3cb4">TiledArray::TArrayF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00056">56</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d6a345559008046e6785aee9d35f11d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;int&gt; <a class="el" href="namespace_tiled_array.html#a2d6a345559008046e6785aee9d35f11d">TiledArray::TArrayI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00055">55</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a99743650f2570e83f35a0ba1958c9569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;long&gt; <a class="el" href="namespace_tiled_array.html#a99743650f2570e83f35a0ba1958c9569">TiledArray::TArrayL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00057">57</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa010edfe058bd83377e3790741e14dee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;std::complex&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#aa010edfe058bd83377e3790741e14dee">TiledArray::TArrayZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00058">58</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac685ca67ab67879d908e57681834604c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;std::complex&lt;float&gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;std::complex&lt;float&gt; &gt; &gt; <a class="el" href="namespace_tiled_array.html#ac685ca67ab67879d908e57681834604c">TiledArray::TensorC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00045">45</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a73a976c8f2da26f51732e5ce811f54ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TiledArray::TensorConstMap</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;typename std::add_const&lt;T&gt;::type, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00047">47</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1950fa935cff5cb1415b58d822057f23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a1950fa935cff5cb1415b58d822057f23">TiledArray::TensorConstView</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;typename std::add_const&lt;T&gt;::type, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_8h_source.html#l00046">46</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1a673c87e7624e63f641318f610a297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;double, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#ac1a673c87e7624e63f641318f610a297">TiledArray::TensorD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00038">38</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a43b4522d34881253139d842d7345dcbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;float, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#a43b4522d34881253139d842d7345dcbc">TiledArray::TensorF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00042">42</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7f58ff1caa878600bc482e36acb64060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;int, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;int&gt; &gt; <a class="el" href="namespace_tiled_array.html#a7f58ff1caa878600bc482e36acb64060">TiledArray::TensorI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00041">41</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a940148a41f1a9b47fabd83511d0ad11f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;long, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;long&gt; &gt; <a class="el" href="namespace_tiled_array.html#a940148a41f1a9b47fabd83511d0ad11f">TiledArray::TensorL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00043">43</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a87417c27b1375ed3dacce12f7430a73c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TiledArray::TensorMap</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00043">43</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a59d2edc4ec73d986edc524386dab1f9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a59d2edc4ec73d986edc524386dab1f9c">TiledArray::TensorView</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor_8h_source.html#l00042">42</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe4438e1e4fac9c7ed76af5bae4a6aff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;std::complex&lt;double&gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;std::complex&lt;double&gt; &gt; &gt; <a class="el" href="namespace_tiled_array.html#abe4438e1e4fac9c7ed76af5bae4a6aff">TiledArray::TensorZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00044">44</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0231c1beab8d7e7c31c19aeceede50fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TiledArray::TSpArray</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;T&gt; &gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00063">63</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="add9caaa3d2c9f944690670df6a1a08ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;std::complex&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#add9caaa3d2c9f944690670df6a1a08ed">TiledArray::TSpArrayC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00069">69</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb0c4ccd3689f4dafb20c6d238690705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;double&gt; <a class="el" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TiledArray::TSpArrayD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00064">64</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6bd8165f08a44cf5a27efca786bee5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;float&gt; <a class="el" href="namespace_tiled_array.html#a6bd8165f08a44cf5a27efca786bee5ac">TiledArray::TSpArrayF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00066">66</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4dd7da1c48d18d477b9d0366e94d9b10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;int&gt; <a class="el" href="namespace_tiled_array.html#a4dd7da1c48d18d477b9d0366e94d9b10">TiledArray::TSpArrayI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00065">65</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51e13a617d7cc592f38124462d5a853d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;long&gt; <a class="el" href="namespace_tiled_array.html#a51e13a617d7cc592f38124462d5a853d">TiledArray::TSpArrayL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00067">67</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa157a11e4eb462e70e5fec1411acab8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;std::complex&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#aa157a11e4eb462e70e5fec1411acab8c">TiledArray::TSpArrayZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00068">68</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a2dfeed8031f6509bdfb6dd1a4d456ffd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;typename Tile::value_type, Eigen::Dynamic, Eigen::Dynamic&gt; TiledArray::array_to_eigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Array object into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix object. </p>
<p>This function will copy the content of an <code>Array</code> object into matrix. The copy operation is done in parallel, and this function will block until all elements of <code>array</code> have been copied into the result matrix. The size of world must be exactly equal to 1, or <code>array</code> must be a replicated object. Usage: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array(world, trange);</div>
<div class="line"><span class="comment">// Set tiles of array ...</span></div>
<div class="line"></div>
<div class="line">Eigen::MatrixXd m = <a class="code" href="namespace_tiled_array.html#a2dfeed8031f6509bdfb6dd1a4d456ffd">array_to_eigen</a>(array);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the array </td></tr>
    <tr><td class="paramname">DIM</td><td>The array dimension </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The array tile type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 and <code>array</code> is not replicated. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the number of dimensions of <code>array</code> is not equal to 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work in non-distributed environments. </dd></dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00433">433</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a59f28503ce59e167667a4d8259619bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00122">122</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a299983d3798619c4de88f351bbe369ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::axpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00114">114</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7c9fa503cbbd6e5627b1e1878cf51141"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; TiledArray::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a deep copy of an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The array to be cloned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="clone_8h_source.html#l00043">43</a> of file <a class="el" href="clone_8h_source.html">clone.h</a>.</p>

</div>
</div>
<a class="anchor" id="a272240d40c483f779f8affc3c12c3285"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::column_major_buffer_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::value_type::value_type *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a column-major matrix buffer into an Array object. </p>
<p>This function will copy the content of <code>buffer</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. The size of <code><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">world.size()</a></code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in <code>buffer</code> is identical on all nodes. Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span>* buffer = <span class="keyword">new</span> <span class="keywordtype">double</span>[100 * 100];</div>
<div class="line"><span class="comment">// Fill buffer with data ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a range for the new array object</span></div>
<div class="line">std::vector&lt;std::size_t&gt; blocks;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div>
<div class="line">  blocks.push_back(i);</div>
<div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div>
<div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div>
<div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div>
<div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div>
<div class="line">    column_major_buffer_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange, buffer, 100, 100);</div>
<div class="line"></div>
<div class="line"><span class="keyword">delete</span> [] buffer;</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">buffer</td><td>The row-major matrix buffer to be copied </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix </td></tr>
    <tr><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>m</code> and <code>n</code> are not equal to the number of rows or columns in tiled range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00571">571</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a44b52c74197023a357e41e93efd8cf0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt; TiledArray::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00057">57</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1e4ffd2673648a15c05d1380f0be0079"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait</a>&lt;Left&gt;::scalar_type TiledArray::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Left &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Right &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00095">95</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc0b1ca917df616d05128c35276462fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::element_type TiledArray::dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00088">88</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="af872c21673f2fd74250d0257fb80f2bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the result matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An m x n <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00065">65</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88684d17566e9778f88a27bb35f06a2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;<a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the result matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An m x n <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00083">83</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0362f265187dbcbec382fff3b76ccc2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, 1&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An n element <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> vector map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00100">100</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d234491688847706a6e1a1bd0c86319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;<a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, 1&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An n element <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> vector map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00117">117</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<p>The dimensions of the result tensor </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>tensor</code> dimensions are not equal to 2 or 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00134">134</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeaa6c8c7926367c10aaae6f056307b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;<a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">When</td><td><code>tensor</code> dimensions are not equal to 2 or 1. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00150">150</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="add789e43efcee8db349c7ec5c6218664"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::eigen_submatrix_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a block of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into a tensor. </p>
<p>A block of <code>matrix</code> will be copied into <code>tensor</code>. The block dimensions will be determined by the dimensions of the tensor's range. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
    <tr><td class="paramname">Derived</td><td>The derived type of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The object that will be assigned the content of <code>tensor</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tensor</td><td>The object that will be assigned the content of <code>matrix</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>tensor</code> are not equal to 1 or 2. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of <code>tensor</code> is outside the range of <code>matrix</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00171">171</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="acc20cb6cde49d2af9af3312a0309f540"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::eigen_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into an Array object. </p>
<p>This function will copy the content of <code>matrix</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. The size of <code><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">world.size()</a></code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in matrix is identical on all nodes. Usage: </p><div class="fragment"><div class="line">Eigen::MatrixXd m(100, 100);</div>
<div class="line"><span class="comment">// Fill m with data ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a range for the new array object</span></div>
<div class="line">std::vector&lt;std::size_t&gt; blocks;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div>
<div class="line">  blocks.push_back(i);</div>
<div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div>
<div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div>
<div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div>
<div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div>
<div class="line">    eigen_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange, m);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
    <tr><td class="paramname">Derived</td><td>The <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix derived type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">matrix</td><td>The <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix to be copied </td></tr>
    <tr><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will only work in non-distributed environments. If you need to convert an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix to an <code>Array</code> object, you must implement it yourself. However, you may use <code>eigen_submatrix_to_tensor</code> to make writing such an algorithm easier. </dd></dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00362">362</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad641711c98c1b64bdf7ad28cccfae69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::exception_break </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place a break point on this function to stop before <a class="el" href="namespace_tiled_array.html">TiledArray</a> exceptions are thrown. </p>

<p>Definition at line <a class="el" href="error_8h_source.html#l00076">76</a> of file <a class="el" href="error_8h_source.html">error.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33cf1d21760cdc032308a5045f0f4380"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a dense Array. </p>
<p>This function uses an <code>Array</code> object to generate a new <code>Array</code> where the output tiles are a function of the input tiles. Users must provide a function/functor that initializes the tiles for the new <code>Array</code> object. For example, if we want to create a new array with were each element is equal to the square root of the corresponding element of the original array: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;2, double&gt;</a> out_array =</div>
<div class="line">    <span class="keywordflow">foreach</span>(in_array, [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; out_tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; in_tile) {</div>
<div class="line">      out_tile = in_tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a69e6422efc9c251ed076b6602b484e97">unary</a>([=] (<span class="keyword">const</span> <span class="keywordtype">double</span> value) -&gt; <span class="keywordtype">double</span></div>
<div class="line">          { <span class="keywordflow">return</span> std::sqrt(value); });</div>
<div class="line">    });</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(<span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,DensePolicy&gt;::value_type</a>&amp; result_tile,</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,DensePolicy&gt;::value_type</a>&amp; arg_tile);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
    <tr><td class="paramname">T</td><td>Element type of the array </td></tr>
    <tr><td class="paramname">DIM</td><td>Dimension of the array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="foreach_8h_source.html#l00072">72</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9e4429634e6981c0ac9f7ff704f2b1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a sparse Array. </p>
<p>This function uses an <code>Array</code> object to generate a new <code>Array</code> where the output tiles are a function of the input tiles. Users must provide a function/functor that initializes the tiles for the new <code>Array</code> object. For example, if we want to create a new array with were each element is equal to the square root of the corresponding element of the original array: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;2, double, Tensor&lt;double&gt;</a>, SparsePolicy&gt; out_array =</div>
<div class="line">    <span class="keywordflow">foreach</span>(in_array, [] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; out_tile,</div>
<div class="line">                          <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; in_tile) -&gt; <span class="keywordtype">float</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">double</span> norm_squared = 0.0;</div>
<div class="line">      out_tile = in_tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a69e6422efc9c251ed076b6602b484e97">unary</a>([&amp;] (<span class="keyword">const</span> <span class="keywordtype">double</span> value) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> result = std::sqrt(value);</div>
<div class="line">        norm_squared += result * result;</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">      });</div>
<div class="line">      <span class="keywordflow">return</span> std::sqrt(norm_squared);</div>
<div class="line">    });</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> op(<span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,SparsePolicy&gt;::value_type</a>&amp; result_tile,</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,SparsePolicy&gt;::value_type</a>&amp; arg_tile);</div>
</div><!-- fragment --><p> where the return value of <code>op</code> is the 2-norm (Fibrinous norm) of the result tile. </p><dl class="section note"><dt>Note</dt><dd>This function should not be used to initialize the tiles of an array object. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
    <tr><td class="paramname">T</td><td>Element type of the array </td></tr>
    <tr><td class="paramname">DIM</td><td>Dimension of the array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="foreach_8h_source.html#l00219">219</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a class="anchor" id="a68370c5a4f4380edb45a5ef3171d97c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify each tile of a dense Array. </p>
<p>This function modifies the tile data of <code>Array</code> object. Users must provide a function/functor that modifies the tile data. For example, if we want to modify the elements of the array to be equal to the the square root of the original value: </p><div class="fragment"><div class="line"><span class="keywordflow">foreach</span>(array, [] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::TensorD</a>&amp; tile) {</div>
<div class="line">  tile.<a class="code" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a>([&amp;] (<span class="keywordtype">double</span>&amp; value) { value = std::sqrt(value); });</div>
<div class="line">});</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(<span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,DensePolicy&gt;::value_type</a>&amp; tile);</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Mutating tile operation </td></tr>
    <tr><td class="paramname">T</td><td>Element type of the array </td></tr>
    <tr><td class="paramname">DIM</td><td>Dimension of the array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The mutating tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array to be modified </td></tr>
    <tr><td class="paramname">fence</td><td>A flag that indicates fencing behavior. If <code>true</code> this function will fence before data is modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function fences by default to avoid data race conditions. Only disable the fence if you can ensure, the data is not being read by another thread. </dd>
<dd>
If there is a another copy of <code>arg</code> that was created via (or arg was created by) the <code>Array</code> copy constructor or copy assignment operator, this function will modify the data of that array since the data of a tile is held in a <code>std::shared_ptr</code>. If you need to ensure other copies of the data are not modified or this behavior causes problems in your application, use the <code><a class="el" href="namespace_tiled_array.html#a33cf1d21760cdc032308a5045f0f4380" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a></code> function instead. </dd></dl>

<p>Definition at line <a class="el" href="foreach_8h_source.html#l00141">141</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51965d14e5a05c4bfd18e4daaaa64875"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify each tile of a sparse Array. </p>
<p>This function modifies the tile data of <code>Array</code> object. Users must provide a function/functor that modifies the tile data in place. For example, if we want to modify the elements of the array to be equal to the square root of the original value: </p><div class="fragment"><div class="line"><span class="keywordflow">foreach</span>(array, [] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile) -&gt; <span class="keywordtype">float</span> {</div>
<div class="line">  <span class="keywordtype">double</span> norm_squared = 0.0;</div>
<div class="line">  tile.<a class="code" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a>([&amp;] (<span class="keywordtype">double</span>&amp; value) {</div>
<div class="line">    norm_squared += value; <span class="comment">// Assume value &gt;= 0</span></div>
<div class="line">    value = std::sqrt(value);</div>
<div class="line">  });</div>
<div class="line">  <span class="keywordflow">return</span> std::sqrt(norm_squared);</div>
<div class="line">});</div>
</div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> op(<span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,SparsePolicy&gt;::value_type</a>&amp; tile);</div>
</div><!-- fragment --><p> where the return value of <code>op</code> is the 2-norm (Fibrinous norm) of the tile. </p><dl class="section note"><dt>Note</dt><dd>This function should not be used to initialize the tiles of an array object. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
    <tr><td class="paramname">T</td><td>Element type of the array </td></tr>
    <tr><td class="paramname">DIM</td><td>Dimension of the array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The mutating tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array to be modified </td></tr>
    <tr><td class="paramname">fence</td><td>A flag that indicates fencing behavior. If <code>true</code> this function will fence before data is modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function fences by default to avoid data race conditions. Only disable the fence if you can ensure, the data is not being read by another thread. </dd>
<dd>
If there is a another copy of <code>arg</code> that was created via (or arg was created by) the <code>Array</code> copy constructor or copy assignment operator, this function will modify the data of that array since the data of a tile is held in a <code>std::shared_ptr</code>. If you need to ensure other copies of the data are not modified or this behavior causes problems in your application, use the <code><a class="el" href="namespace_tiled_array.html#a33cf1d21760cdc032308a5045f0f4380" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a></code> function instead. </dd></dl>

<p>Definition at line <a class="el" href="foreach_8h_source.html#l00322">322</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7cd3d9c18d8f36108c03e6ef9429144f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Op , typename std::enable_if&lt; is_dense&lt; Array &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> TiledArray::make_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">detail::pmap_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct dense Array. </p>
<p>Construct sparse Array.</p>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> object. Users must provide a world object, tiled range object, and function/functor that generates the tiles for the new array object. For example, if we want to create an array with were the elements are equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TArray&lt;double&gt;</a> out_array =</div>
<div class="line">    make_array&lt;TiledArray::TArray&lt;double&gt; &gt;(world, trange, pmap,</div>
<div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; range) {</div>
<div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div>
<div class="line">              *it = 1;</div>
<div class="line">          });</div>
</div><!-- fragment --><p> Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object. The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div>
</div><!-- fragment --><p> where <code>tile_t</code> and <code>range_t</code> are your tile type and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code></dd></dl>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> object. Users must provide a world object, tiled range object, process map, and function/ functor that generates the tiles for the new array object. For example, if we want to create an array with all elements equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TSpArray&lt;double&gt;</a> array =</div>
<div class="line">    make_array&lt;TiledArray::TSpArray&lt;double&gt; &gt;(world, trange, pmap,</div>
<div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; range) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div>
<div class="line">              *it = 1;</div>
<div class="line">            <span class="keywordflow">return</span> tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a43ca135b8db345c20bb54f470ee59747">norm</a>();</div>
<div class="line">          });</div>
</div><!-- fragment --><p> You may choose not to initialize a tile inside the tile initialization function (not shown in the example) by returning <code>0</code> for the tile norm. Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object unless the returned tile norm is zero. The expected signature of the tile operation is: </p><div class="fragment"><div class="line">value_t op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div>
</div><!-- fragment --><p> where <code>value_t</code>, <code>tile_t</code> and <code>range_t</code> are your tile value type, tile type, and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">pmap</td><td>A shared pointer to the array process map </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code> </dd></dl>

<p>Definition at line <a class="el" href="make__array_8h_source.html#l00071">71</a> of file <a class="el" href="make__array_8h_source.html">make_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad73ea2d1e2e1b222f741f94a3f949e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> TiledArray::make_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array. </p>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> object. Users must provide a world object, tiled range object, and function/functor that generates the tiles for the new array object. For example, if we want to create an array with were the elements are equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TSpArray&lt;double&gt;</a> array =</div>
<div class="line">    make_array&lt;TiledArray::TSpArray&lt;double&gt; &gt;(world, trange,</div>
<div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; range) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div>
<div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div>
<div class="line">              *it = 1;</div>
<div class="line">            <span class="keywordflow">return</span> tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a43ca135b8db345c20bb54f470ee59747">norm</a>();</div>
<div class="line">          });</div>
</div><!-- fragment --><p> For sparse arrays, you may choose not to initialize a tile inside the tile initialization (not shown in the example) by returning <code>0</code> for the tile norm. Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object unless the returned tile norm is zero. The expected signature of the tile operation is: </p><div class="fragment"><div class="line">value_t op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div>
</div><!-- fragment --><p> where <code>value_t</code>, <code>tile_t</code> and <code>range_t</code> are your tile value type, tile type, and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code> </dd></dl>

<p>Definition at line <a class="el" href="make__array_8h_source.html#l00219">219</a> of file <a class="el" href="make__array_8h_source.html">make_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada3e7bc14ca6d99904ada555922fc391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00082">82</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46acafb5a0d0468803cf0136997b0343"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00088">88</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7caf83be84a92371f88fa53b8e100317"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00094">94</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3f6231b75b996d3fa766849f952eef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00050">50</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a550c8b83d887c20998b7a696d3ee8111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00055">55</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="acbbe8d8ad0930df042711f7a4712f5fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00061">61</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e69e843e127604a961c87e9c987cce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00065">65</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78cce5a1ed8ed29fc23faee418274512"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00071">71</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91c319275bd48061cbd38e7171bef453"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a73a976c8f2da26f51732e5ce811f54ea">TensorConstMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00077">77</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8553a88a5735149954d4d04e491e7358"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::element_type TiledArray::maxabs_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00075">75</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc4078d3b132757efef1b74e42575149"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::element_type TiledArray::minabs_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00069">69</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b49b5f0f1d0448133635e42a4989137"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::element_type TiledArray::norm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00129">129</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a49a6fdebe3f7dff3beb2637c2c48809f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

<p>Definition at line <a class="el" href="tiled__range1_8h_source.html#l00213">213</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4282e9e655ef9479b267ac1975d77eb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiled__range_8h_source.html#l00224">224</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc410382ebb92ab3373034a9b54a9a78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> inequality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first range to be compared </td></tr>
    <tr><td class="paramname">r2</td><td>The second range to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>r1</code> does not represent the same range as <code>r2</code>, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="range_8h_source.html#l00873">873</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a class="anchor" id="a586be997af3bd421583c8fd36c4e95f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the array </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">a</td><td>The array to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>a</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permutation_8h_source.html#l00482">482</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3db915cc9b57726c63e876d1260c50dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>permute a <code>std::vector&lt;T&gt;</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permutation_8h_source.html#l00516">516</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a696e0fb9934a65b840e1b4b682d9b7da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *restrict const&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute a memory buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to the memory buffer to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of the memory buffer as a <code>std::vector</code> </dd></dl>

<p>Definition at line <a class="el" href="permutation_8h_source.html#l00546">546</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7536fceedf51ab22cfffa370ccc537d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.mult(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> multiplication operator. </p>
<p>Element-wise multiplication of two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] * right[i]</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00080">80</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="adaf93d3d11d940c8e031f50828fd2059"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.scale(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>left</code> that is scaled by <code>right</code>. </p>
<p>Scale a tensor </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code> left[i] * right </code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00097">97</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a56598114f338270d1a1e1d04049d61e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N , typename T , typename std::enable_if&lt;                                  detail::is_numeric&lt; N &gt;::value &amp;&amp;                               (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(right.scale(left))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>right</code> that is scaled by <code>left</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>A numeric type </td></tr>
    <tr><td class="paramname">T</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand scalar argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code> left * right[i] </code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00112">112</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a94eb9cd81ceddc9a6d03f4b122d37c79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;                                  detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(arg.permute(perm))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The argument tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>arg</code> </td></tr>
    <tr><td class="paramname">arg</td><td>The argument tensor to be permuted </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00137">137</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2b1fa4c93060bc503429e3527f2993ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of an N-dimensional, tiled tensor. ">TiledRange</a> permutation operator. </p>
<p>This function will permute the range. Note: only tiles that are not being used by other objects will be permuted. The owner of those objects are </p>

<p>Definition at line <a class="el" href="tiled__range_8h_source.html#l00207">207</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>

</div>
</div>
<a class="anchor" id="a678f80db611a7af38027953b96bc8f0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the range </td></tr>
    <tr><td class="paramname">r</td><td>The range to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>r</code>. </dd></dl>

<p>Definition at line <a class="el" href="range_8h_source.html#l00853">853</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae84ce21d711a462da4a1b44a811a5a94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; &amp; TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place permute a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the array </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>The array to be permuted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>a</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permutation_8h_source.html#l00499">499</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4beab363e9a6e97343bc39965e548f95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T, A &gt; &amp; TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place permute a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The vector to be permuted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permutation_8h_source.html#l00533">533</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a116f5e2ecfb93c7163f2059bd52c3f89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.mult_to(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor multiplication. </p>
<p>Multiply the elements of left by that of right </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00185">185</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29fc80968c1111be5a7be74a5fa5e807"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.scale_to(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor scale. </p>
<p>Scale the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00234">234</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91a59b3c5e05d4511f501d0d583bc6ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.add(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator. </p>
<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] + right[i]</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00048">48</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9688412f951f29a193bab6e8659cc0f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.add_to(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator. </p>
<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> the elements of <code>right</code> to that of <code>left</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] + right[i]</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00153">153</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a034cc7b6df60ee6292bdff4daf87ad42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.add_to(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor add constant. </p>
<p>Scale the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00202">202</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8991a55c5789853a510f20a134ca4f85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator- </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.subt(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator. </p>
<p>Subtract two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] - right[i]</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00064">64</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac90b5d6c5aae4293d2b9d3456477aeba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;                                  detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; decltype(arg.neg())
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a negated copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of <code>arg</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>-arg</code>[i] </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00124">124</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2392a7f20731da96a682b95aafd19559"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;                                  detail::is_tensor&lt; T1, T2 &gt;::value||                               detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.subt_to(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator. </p>
<p>Subtract the elements of <code>right</code> from that of <code>left</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00169">169</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed3e09d58de106a8665496a8f4adbf51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;                                  (detail::is_tensor&lt; T &gt;::value||                               detail::is_tensor_of_tensor&lt; T &gt;::value)&amp;&amp;                               detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.subt_to(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor subtract constant. </p>
<p>Scale the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p>Definition at line <a class="el" href="operators_8h_source.html#l00218">218</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67d07017bf139b8ea4e344216443b372"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;                                  detail::is_tensor&lt; T &gt;::value &amp;&amp;                               detail::is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> output operator. </p>
<p>Ouput tensor <code>t</code> to the output stream, <code>os</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">t</td><td>The tensor to be output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p>Definition at line <a class="el" href="tensor_8h_source.html#l00060">60</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3e4d830e8d3e6b0c3ef4db415eeed8f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> ostream operator. </p>

<p>Definition at line <a class="el" href="tiled__range1_8h_source.html#l00218">218</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac42dd6da4a499c34371973b91d3529c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tiled__range_8h_source.html#l00228">228</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8044f7d779135e7bc782943d785a0fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Tile addition operation. ">Add</a> the tensor to an output stream. </p>
<p>This function will iterate through all tiles on node 0 and print non-zero tiles. It will wait for each tile to be evaluated (i.e. it is a blocking function). Tasks will continue to be processed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of Array </td></tr>
    <tr><td class="paramname">DIM</td><td>The number of dimensions </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The <a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array to be put in the output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p>Definition at line <a class="el" href="dist__array_8h_source.html#l00669">669</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a00568c34aef7e5f9b2802cbdd4382ea5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> output operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream that will be used to print <code>r</code> </td></tr>
    <tr><td class="paramname">r</td><td>The range to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p>Definition at line <a class="el" href="range_8h_source.html#l00883">883</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e0508aa5150620ac2a2a5476c6c5612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

<p>Definition at line <a class="el" href="tiled__range1_8h_source.html#l00207">207</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95a1447230c9a5ca4906ee3684cbe890"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when all tile and element ranges are the same. </p>

<p>Definition at line <a class="el" href="tiled__range_8h_source.html#l00218">218</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac25a0fb0ad765d6c6a383c67d403fc57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> equality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first range to be compared </td></tr>
    <tr><td class="paramname">r2</td><td>The second range to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>r1</code> represents the same range as <code>r2</code>, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="range_8h_source.html#l00863">863</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a class="anchor" id="aadfd4a5d0073f766aeca78185b841a30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00134">134</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac6a59d75845f7586427931c3d854e70e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34d05db90b5aba567b8653f980ab3310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9b5cbaea4986ba92424520ae4a83f8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For reusing map without allocating new ranges . . . maybe. </p>

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00099">99</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="acac227696cd22877cfb9af3b37523345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a87417c27b1375ed3dacce12f7430a73c">TensorMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="tensor__map_8h_source.html#l00115">115</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a class="anchor" id="adfba97f8c60f13c48f7adfcabc677b95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::row_major_buffer_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::value_type::value_type *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a row-major matrix buffer into an Array object. </p>
<p>This function will copy the content of <code>buffer</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. The size of <code><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">world.size()</a></code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in <code>buffer</code> is identical on all nodes. Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span>* buffer = <span class="keyword">new</span> <span class="keywordtype">double</span>[100 * 100];</div>
<div class="line"><span class="comment">// Fill buffer with data ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a range for the new array object</span></div>
<div class="line">std::vector&lt;std::size_t&gt; blocks;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div>
<div class="line">  blocks.push_back(i);</div>
<div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div>
<div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div>
<div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div>
<div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div>
<div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div>
<div class="line">    row_major_buffer_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange, buffer, 100, 100);</div>
<div class="line"></div>
<div class="line"><span class="keyword">delete</span> [] buffer;</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">buffer</td><td>The row-major matrix buffer to be copied </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix </td></tr>
    <tr><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>m</code> and <code>n</code> are not equal to the number of rows or columns in tiled range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00515">515</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90e2f4b420375c45a2c21049e27377aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td>
          <td class="paramname"><em>scaling_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00107">107</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ed423a0b023a4a5aadfb5012d968a4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt;T&gt; TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> a tensor from one range to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted tensor object </dd></dl>

<p>Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00136">136</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>

</div>
</div>
<a class="anchor" id="a62b1b3fec016be7c5ed4230f72e5b29d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt;const T&gt; TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> a tensor from one range to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted tensor object </dd></dl>

<p>Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00147">147</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc51ed34e98a417052d745d91994de70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t TiledArray::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00048">48</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="abe5632aeeaf569807a5e38b4ae1c5a98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the data of the two given ranges. </p>

<p>Definition at line <a class="el" href="tiled__range1_8h_source.html#l00202">202</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b0947b0d351b9ee0112b292eb869249"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the content of the two given <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of an N-dimensional, tiled tensor. ">TiledRange</a>'s. </p>

<p>Definition at line <a class="el" href="tiled__range_8h_source.html#l00215">215</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>

</div>
</div>
<a class="anchor" id="a705b350b2dbf336a9cc24fb1d0f78fca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the values of the give two ranges. </p>

<p>Definition at line <a class="el" href="range_8h_source.html#l00843">843</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a1e016346f447dcd7b5b4d7f29246b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::tensor_to_eigen_submatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the content of a tensor into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix block. </p>
<p>The content of tensor will be copied into a block of matrix. The block dimensions will be determined by the dimensions of the tensor's range. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
    <tr><td class="paramname">Derived</td><td>The derived type of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td>The object that will be copied to <code>matrix</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The object that will be assigned the content of <code>tensor</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>tensor</code> are not equal to 1 or 2. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of <code>tensor</code> is outside the range of <code>matrix</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00235">235</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa9380eed8edcb28bcde6b05f2a2e85f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sparse__to__dense_8h_source.html#l00035">35</a> of file <a class="el" href="sparse__to__dense_8h_source.html">sparse_to_dense.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d73428d629118ac2c9ab7f08b6ca180"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sparse__to__dense_8h_source.html#l00066">66</a> of file <a class="el" href="sparse__to__dense_8h_source.html">sparse_to_dense.h</a>.</p>

</div>
</div>
<a class="anchor" id="a177c1ea27ad85cca7df258e71c7d9739"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;typename std::result_of&lt;Op(<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>)&gt;::type, Policy&gt; TiledArray::to_new_tile_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>old_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to convert an array to a new array with a different tile type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The array tile type </td></tr>
    <tr><td class="paramname">Policy</td><td>The array policy type </td></tr>
    <tr><td class="paramname">Op</td><td>The tile conversion operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to be converted </td></tr>
    <tr><td class="paramname">op</td><td>The tile type conversion operation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="to__new__tile__type_8h_source.html#l00042">42</a> of file <a class="el" href="to__new__tile__type_8h_source.html">to_new_tile_type.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3fe2d157bfac3a81e84b52461e754c96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::to_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>dense_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert a dense array into a block sparse array. </p>
<p>If the input array is dense then create a copy by checking the norms of the tiles in the dense array and then cloning the significant tiles into the sparse array. </p>

<p>Definition at line <a class="el" href="dense__to__sparse_8h_source.html#l00016">16</a> of file <a class="el" href="dense__to__sparse_8h_source.html">dense_to_sparse.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9f448baf0d9da33c2112d366334c744a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::to_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the array is already sparse return a copy of the array. </p>

<p>Definition at line <a class="el" href="dense__to__sparse_8h_source.html#l00053">53</a> of file <a class="el" href="dense__to__sparse_8h_source.html">dense_to_sparse.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc763468b96a704d6b4efb628909485f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate a dense Array. </p>
<p>This is a no op </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the array </td></tr>
    <tr><td class="paramname">DIM</td><td>Dimension of the array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array object to be truncated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="truncate_8h_source.html#l00046">46</a> of file <a class="el" href="truncate_8h_source.html">truncate.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9f42ee8853ef4f42c260f1a22ffc1eef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate a sparse Array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the array </td></tr>
    <tr><td class="paramname">DIM</td><td>Dimension of the array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array object to be truncated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="truncate_8h_source.html#l00055">55</a> of file <a class="el" href="truncate_8h_source.html">truncate.h</a>.</p>

</div>
</div>
<a class="anchor" id="a297fc199c0e4a33cd3d6122b7c71f514"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::vec_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00080">80</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3558ec56f9d00590c35846d8f13c1b76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00062">62</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li>
    <li class="footer">Generated on Fri Apr 29 2016 12:03:07 for TiledArray by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
