<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MPQC: The KeyVal Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPQC
   &#160;<span id="projectnumber">4.0.0-beta.1</span>
   </div>
   <div id="projectbrief">Massively Parallel Electronic Structure platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('keyval.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The most powerful way to use MPQC is to provide input in an object-oriented text format that can be understood by the <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> class. MPQC version 3 and older use a custom text format for input data. MPQC4 abandoned the old format in favor of these popular industry-standard formats used for data exchange:</p><ul>
<li><a href="http://json.org/">JSON</a>,</li>
<li><a href="http://www.w3.org/XML/">XML</a>.<br />
 Another useful format that can be used is the <a href="http://www.boost.org/doc/libs/master/doc/html/property_tree/parsers.html#property_tree.parsers.info_parser">INFO format</a> understood by the Boost.PropertyTree library. It is similar to JSON, but is less verbose and supports comments and file inclusions.</li>
</ul>
<p>The <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> class is a means in a C++ program to convert such JSON, XML, or INFO input to C++ primitive data (booleans, integers, reals, string) and user-defined objects. For example, the following JSON, </p><pre class="fragment">{
  "type" : "Atom"
  "element" : "C",
  "r" : [0.0 1.0 -2.0],
  "isotope" : "13"
}
</pre><p> can be used to construct an object of the following C++ class representing an atom: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Atom {</div><div class="line">  <span class="keywordtype">int</span> Z;</div><div class="line">  std::array&lt;double, 3&gt; r;</div><div class="line">  <span class="keywordtype">int</span> isotope;</div><div class="line">};</div></div><!-- fragment --><p><a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> is more than just a structured text importer: it is a general-purpose component for representing "keyword=value" associations in a flexible form. and can be used in any C++ program that needs such functionality. <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> objects can be created from JSON-, XML-, or INFO-formatted text, or purely programmatically. For brevity, only the programmatic and JSON-based methods will be illustrated here.</p>
<ul>
<li><a class="el" href="keyval.html#keyvalass">Assignment</a></li>
<li><a class="el" href="keyval.html#keyvalconstruct">Constructing KeyVal</a></li>
<li><a class="el" href="keyval.html#keyvalgroup">Keyword Grouping and Paths</a></li>
<li><a class="el" href="keyval.html#keyvalobj">Simple Object Construction</a></li>
<li><a class="el" href="keyval.html#keyvalpobj">Polymorphic Object Construction</a></li>
<li><a class="el" href="keyval.html#keyvalarray">Array Specification</a></li>
<li><a class="el" href="keyval.html#keyvalsub">Value Substitution</a></li>
<li><a class="el" href="keyval.html#keyvaldescribedclass">The DescribedClass class</a></li>
<li><a class="el" href="keyval.html#keyvalforcelink">Forced linkage of DescribedClass objects</a></li>
<li><a class="el" href="keyval.html#keyvaldeprecatedkw">Deprecated keywords</a></li>
</ul>
<h1><a class="anchor" id="keyvalass"></a>
Assignment</h1>
<p>As an example of the use of <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a>, consider the following JSON input: </p><pre class="fragment">{
  "x_coordinate" :  1.0,
  "y_coordinate" :  2.0,
  "x_coordinate" :  3.0
}
</pre><p> Two assignements will be made. The keyword <code>x_coordinate</code> will be associated with the value <code>1.0</code> and the keyword <code>y_coordinate</code> will be assigned to <code>2.0</code>. The third line in the above input will have no effect since <code>x_coordinate</code> is already assigned.</p>
<dl class="section note"><dt>Note</dt><dd>The data specified by the third line is still internally kept by <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a>, but cannot be accessed by the standard API. Use <a class="el" href="classmpqc_1_1_key_val.html#ab32d9e717a274d228dec0a509ace84c2" title="returns a shared_ptr to this (sub)tree ">KeyVal::tree</a> or <a class="el" href="classmpqc_1_1_key_val.html#afd9c1e39d18333127017d59879fe382f" title="returns a shared_ptr to the (top) tree ">KeyVal::top_tree</a> to access the Boost.PropertyTree object to extract this data</dd></dl>
<h1><a class="anchor" id="keyvalgroup"></a>
Keyword Grouping and Paths</h1>
<p>Lets imagine that we have a program which needs to read in the characteristics of animals. There are lots of animals so it might be nice to catagorize them by their family. Here is a sample JSON input file for such a program: <a class="anchor" id="KeyValPage_Example1"></a></p><pre class="fragment">{
  "reptile": {
    "trex": {
      "legs": 2,
      "extinct: true
    },
    "python": {
      "legs": 0,
      "extinct": false
    }
  },
  "bird": {
    "bald eagle": {
      "species": "Haliaeetus leucocephalus",
      "flys": true,
      "extinct": false
    }
  }
}
</pre><p>This sample illustrates the use of <code>keyword:value</code> assignments and the keyword grouping operators <code>{</code> and <code>}</code> . The hierarchy of keyword/value pairs forms a tree. Direct access to a location in this tree is possible by arranging keywords into composite keywords, or <em>paths</em>. The data in this example can be accessed using these paths: </p><pre class="fragment">reptile:trex:legs
reptile:trex:extinct
reptile:python:legs
reptile:python:extinct
bird:bald eagle:species
bird:bald eagle:flys
bird:bald eagle:extinct
</pre><p>The <a class="el" href="classmpqc_1_1_key_val.html#ae287fb3c07e957abba5b38fb9550128a">KeyVal::separator</a> character, '<code></code>: ' , occuring in these paths break the paths into individual keywords, or path segments. The sole purpose of this is to allow persons writing input files to group the input into easy to read sections (JSON refers to such sections as <em>objects</em> , not to be confused with C++ objects). In the above example there are two main sections, the reptile section and the bird section. The reptile section takes the form</p><pre class="fragment">"reptile" : { "keyword1": value1, "keyword2": value2, ... } </pre><p> . Each of the keywords found in the reptile section has the <code>reptile:</code> prefix attached to its path. Within each of these sections further keyword groupings can be used, as many and as deeply nested as the user wants.</p>
<dl class="section note"><dt>Note</dt><dd>Keywords ("bald eagle") as well as string values ("Haliaeetus leucocephalus") can contain whitespace characters. The former was not possible in the old <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> input format.</dd></dl>
<p>Keyword grouping is also useful when you need many different programs to read from the same input file. Each program can be assigned its own unique section.</p>
<h1><a class="anchor" id="keyvalconstruct"></a>
Constructing KeyVal</h1>
<p><a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> objects can be directly created using JSON text input, or created programmatically. If the JSON text shown in <a class="el" href="keyval.html#KeyValPage_Example1">Example 1</a> is stored in text file <code>"example1.json"</code> then a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object is constructed and used as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="keyval_8h.html">mpqc/util/keyval/keyval.h</a>&quot;</span></div><div class="line"></div><div class="line">std::ifstream f(<span class="stringliteral">&quot;example1.json&quot;</span>);  assert(f.is_good());</div><div class="line"></div><div class="line"><a class="code" href="classmpqc_1_1_key_val.html">mpqc::KeyVal</a> kv; kv.<a class="code" href="classmpqc_1_1_key_val.html#a3d0de8f5c809cbe7719ca54737a9ec35">read_json</a>(f);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> trex_extinct = kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;reptile:trex:extinct&quot;</span>);</div><div class="line"><span class="keyword">auto</span> python_legs = kv.value&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;reptile:python:legs&quot;</span>); <span class="comment">// could use any integer type, e.g. &#39;unsigned long&#39;</span></div><div class="line"><span class="keyword">auto</span> bald_eagle_species = kv.value&lt;std::string&gt;(<span class="stringliteral">&quot;bird:bald eagle:species&quot;</span>);</div></div><!-- fragment --><p> Of course, any basic_istream can be used (e.g. std::istringstream) and not just std::ifstream.</p>
<p>To test whether a keyword refers to a group of keywords or to a value use <a class="el" href="classmpqc_1_1_key_val.html#a32a637d5baad1c583252aad02015326b">KeyVal::count</a> that returns a <code>boost::optional&lt;size_t&gt;</code> ; it contains a value if its argument refers to a keyword group: </p><div class="fragment"><div class="line">assert(!kv.count(<span class="stringliteral">&quot;reptile:trex:extinct&quot;</span>));   <span class="comment">// count returns an empty optional since &quot;reptile:trex:extinct&quot; refers to a value</span></div><div class="line">assert(!kv.count(<span class="stringliteral">&quot;reptile:trex&quot;</span>) == <span class="keyword">false</span>);  <span class="comment">// count returns a non-empty optional since reptile:trex&quot; is a keyword group</span></div><div class="line">assert(*kv.count(<span class="stringliteral">&quot;reptile:trex&quot;</span>) &gt; 0);       <span class="comment">// count &gt; 0 since reptile:trex&quot; is a nonempty keyword group</span></div></div><!-- fragment --><p> <a class="el" href="classmpqc_1_1_key_val.html#a32a637d5baad1c583252aad02015326b">KeyVal::count</a> can also be used to examine other aggregates like arrays (see <a class="el" href="keyval.html#keyvalarray">Array Specification</a> ).</p>
<p>It is often convenient to construct <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> objects programmatically. This is particularly useful to construct programmatically classes that have constructors that take <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> (see <a class="el" href="keyval.html#keyvaldescribedclass">The DescribedClass class</a> ). A <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object corresponding to the JSON input in <a class="el" href="keyval.html#KeyValPage_Example1">Example 1</a> can be created as follows: <a class="anchor" id="KeyValPage_Example2"></a></p><div class="fragment"><div class="line">KeyVal kv;</div><div class="line">kv.assign(<span class="stringliteral">&quot;reptile:trex:legs&quot;</span>, 2);</div><div class="line">kv.assign(<span class="stringliteral">&quot;reptile:trex:extinct&quot;</span>, <span class="keyword">true</span>);</div><div class="line">kv.assign(<span class="stringliteral">&quot;reptile:python:legs&quot;</span>, 0).assign(<span class="stringliteral">&quot;reptile:python:extinct&quot;</span>, <span class="keyword">false</span>);  <span class="comment">// can chain assignments</span></div><div class="line">kv.assign(<span class="stringliteral">&quot;bird:bald eagle:species&quot;</span>, <span class="stringliteral">&quot;Haliaeetus leucocephalus&quot;</span>).assign(<span class="stringliteral">&quot;bird:bald eagle:flys&quot;</span>, <span class="keyword">true</span>).assign(<span class="stringliteral">&quot;bird:bald eagle:extinct&quot;</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p>It is of course possible to erase the <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> entries: </p><div class="fragment"><div class="line">kv.erase(<span class="stringliteral">&quot;reptile:trex:legs&quot;</span>);</div></div><!-- fragment --><p>So far so good. But why all this complexity? To understand that, let's consider how <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> helps to construct C++ objects, not just simple data.</p>
<h1><a class="anchor" id="keyvalobj"></a>
Simple Object Construction</h1>
<p>Consider the following class representing Birds: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Bird {</div><div class="line">    std::string species;</div><div class="line">    <span class="keywordtype">bool</span> flys;</div><div class="line">    <span class="keywordtype">bool</span> extinct;</div><div class="line">};</div></div><!-- fragment --><p> To construct <code>Bird</code> from <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> objects we need to add a constructor: <a class="anchor" id="KeyValPage_Example4"></a></p><div class="fragment"><div class="line">Bird::Bird(<span class="keyword">const</span> KeyVal&amp; kv) {</div><div class="line">  species = kv.value&lt;std::string&gt;(<span class="stringliteral">&quot;species&quot;</span>);</div><div class="line">  flys = kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;flys&quot;</span>);</div><div class="line">  extinct = kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;extinct&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p> Then, given a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object constructed from JSON <a class="el" href="keyval.html#KeyValPage_Example1">Example 1</a> or as in <a class="el" href="keyval.html#KeyValPage_Example2">Example 2</a> we can construct a <code>Bird</code> object representing a bald eagle as follows: </p><div class="fragment"><div class="line">Bird bald_eagle(kv.keyval(<span class="stringliteral">&quot;bird:bald eagle&quot;</span>));</div><div class="line"><span class="comment">// or, alternative syntax:</span></div><div class="line"><span class="comment">// auto bald_eagle = kv.value&lt;Bird&gt;(&quot;bird:bald eagle&quot;);</span></div></div><!-- fragment --><p> Note the use of the <a class="el" href="classmpqc_1_1_key_val.html#a013e32435b4fbc49c5c20ea74dd6fa26" title="construct a KeyVal representing a subtree located at the given path ">KeyVal::keyval</a> method to construct a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object representing the subtree whose root is at "bird:bald eagle" of the base <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object. The ability to refer to keyword sections in an existing <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> is crucial for constructing hierarchies of C++ objects easily.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> objects have reference semantics, hence a copy of <code>kv</code> will refers to the same tree as <code>kv</code> and share <code>kv</code>'s mutable internal data, such as the internal object registry used by <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr</a> (see below). The same can be said about the new <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object returned by <code>kv.keyval()</code>. To create a deep copy of a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object use the <a class="el" href="classmpqc_1_1_key_val.html#a9d19d7373b0ffa6ad3d029d5352f16a9" title="creates a deep copy of this object ">KeyVal::clone</a> method (note that the <a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a> object registry is not copied, only the PropertyTree object).</dd></dl>
<h1><a class="anchor" id="keyvalpobj"></a>
Polymorphic Object Construction</h1>
<p>JSON in <a class="el" href="keyval.html#KeyValPage_Example1">Example 1</a> specifies three animals: 2 reptiles and 1 bird. Reptiles and birds are both animals, thus they have much in common, e.g. they can both be extinct. Although possible to express in other ways, this fact is often represented using inheritance: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Animal {</div><div class="line">  <span class="keywordtype">bool</span> extinct() <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">bool</span> m_extinct;</div><div class="line">};</div><div class="line"><span class="keyword">struct </span>Reptile: <span class="keyword">public</span> Animal {</div><div class="line">  <span class="keywordtype">int</span> legs() <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> m_legs;</div><div class="line">};</div><div class="line"><span class="keyword">struct </span>Bird: <span class="keyword">public</span> Animal {</div><div class="line">  <span class="keywordtype">bool</span> flys() <span class="keyword">const</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">bool</span> m_flys;</div><div class="line">};</div></div><!-- fragment --><p> This then allows to write a function that takes as its lone argument a reference or a pointer to an object of class Animal. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_extinct(<span class="keyword">const</span> Animal&amp; a) { <span class="keywordflow">return</span> a.extinct(); }</div><div class="line"></div><div class="line">Reptile trex;</div><div class="line">Bird owl;</div><div class="line"><span class="comment">// initialization not shown</span></div><div class="line">assert(is_extinct(trex) == <span class="keyword">true</span>); <span class="comment">// ok</span></div><div class="line">assert(is_extinct(owl) == <span class="keyword">false</span>); <span class="comment">// ok</span></div></div><!-- fragment --><p>Now we would like the user to be able to give a list of Animal objects and have the program count how many extinct animals are given, as well as print out their attributes like scientific names, etc. For each object in the input the user should be able to specify the exact <em>kind</em> of Animal it represents: Bird or Reptile.</p>
<p>For example, in a chemistry context, the MPQC program needs to be able to perform geometry optimization given a <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a> object whose type is specified by the user (Hartree-Fock, CCSD, etc.). The input parser code could read in a type string corresponding to the <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a> type and then test it in a long series of <code>if</code> statements against the known types. This unfortunately means that whenever a new <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a> is implemented the input parser code must be modified. This problem is solved by the <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> library.</p>
<p>Consider the following variant of <a class="el" href="keyval.html#KeyValPage_Example1">Example 1</a> JSON: <a class="anchor" id="KeyValPage_Example11"></a></p><pre class="fragment">{
  "trex": {
    "type": "Reptile",
    "legs": 2,
    "extinct: true
  },
  "python": {
    "type": "Reptile",
    "legs": 0
    "extinct": false
  },
  "bald eagle": {
    "type": "Bird",
    "species": "Haliaeetus leucocephalus",
    "flys": true
    "extinct": false
  }
}
</pre><p> Note that we eliminated the reptile and bird sections so that all animals appear at the same level.</p>
<p>Skipping for now the modifications of the C++ classes necessary, see how easy it is to read in these animals as objects of Animal class: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> trex = kv.class_ptr&lt;Animal&gt;(<span class="stringliteral">&quot;trex&quot;</span>);             assert(trex-&gt;extinct() == <span class="keyword">true</span>);</div><div class="line"><span class="keyword">auto</span> python = kv.class_ptr&lt;Animal&gt;(<span class="stringliteral">&quot;python&quot;</span>);         assert(python-&gt;extinct() == <span class="keyword">false</span>);</div><div class="line"><span class="keyword">auto</span> bald_eagle = kv.class_ptr&lt;Animal&gt;(<span class="stringliteral">&quot;bald eagle&quot;</span>); assert(bald_eagle-&gt;extinct() == <span class="keyword">false</span>);</div></div><!-- fragment --><p> <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr&lt;T&gt;</a> returns <code>std::shared_ptr&lt;T&gt;</code> , hence the pointer dereferencing. Also, the actual types of <code>trex</code> , <code>python</code> , and <code>bald_eagle</code> are Reptile, Reptile, and Bird, so we can access their full properties: </p><div class="fragment"><div class="line">assert(std::dynamic_pointer_cast&lt;Reptile&gt;(trex)-&gt;legs() == 2);</div><div class="line">assert(std::dynamic_pointer_cast&lt;Bird&gt;(bald_eagle)-&gt;flys() == <span class="keyword">true</span>);</div></div><!-- fragment --><p>Now let's see the actual implementation of Animal, Reptile, and Bird classes: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Animal : <span class="keyword">virtual</span> <span class="keyword">public</span> DescribedClass {</div><div class="line">  Animal(<span class="keyword">const</span> KeyVal&amp; kv) {</div><div class="line">    m_extinct = kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;extinct&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">bool</span> extinct()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> extinct; }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">bool</span> m_extinct;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Reptile: <span class="keyword">public</span> Animal {</div><div class="line">  Reptile(<span class="keyword">const</span> KeyVal&amp; kv) : Animal(kv) {</div><div class="line">    m_legs = kv.value&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;legs&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> legs <span class="keyword">const</span> ();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> m_legs;</div><div class="line">};</div><div class="line"><a class="code" href="group___core_key_val.html#ga51f6fa219f736d9823d14e4b44eee63f">MPQC_CLASS_EXPORT_KEY</a>(Reptile);</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>mammals {</div><div class="line">  <span class="keyword">struct </span>Bird: <span class="keyword">public</span> Animal {</div><div class="line">    Bird(<span class="keyword">const</span> KeyVal&amp; kv) : Animal(kv) {</div><div class="line">      m_flys = kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;flys&quot;</span>);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">bool</span> flys() <span class="keyword">const</span>;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">bool</span> m_flys;</div><div class="line">  };</div><div class="line">}  <span class="comment">// namespace mammals</span></div><div class="line"></div><div class="line"><a class="code" href="group___core_key_val.html#gaed852023b22874529d5999bb2698e760">MPQC_CLASS_EXPORT_KEY2</a>(<span class="stringliteral">&quot;Bird&quot;</span>, mammals::Bird);</div></div><!-- fragment --><p>A few comments:</p><ul>
<li>Animal class is derived from <a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a> to support polymorphic construction using <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr</a> (see <a class="el" href="keyval.html#keyvaldescribedclass">The DescribedClass class</a> ).</li>
<li>Smart pointers to objects created using <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr</a> method are stored in the registry associated with that <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a>'s top tree. They will not be destroyed until <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> is destroyed as well. This behavior can be bypassed by providing calling <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr</a> with the second parameter set to <code>true</code> ; the lifetime of the object then must be managed by the user.</li>
<li>If keyword <code>type</code> is not given, calling <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr&lt;T&gt;</a> where class <code>T</code> is abstract or not registered will throw an exception of type <a class="el" href="structmpqc_1_1_key_val_1_1bad__input.html" title="KeyVal exception. ">KeyVal::bad_input</a> . Setting the third parameter of <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr</a> to <code>true</code> will in such case cause <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr&lt;T&gt;</a> to return a null pointer.</li>
<li>Every class that we want to construct from <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> polymorphically needs to be associated with a global unique identifier descriptor (GUID) string (typically, GUID is the class name without the namespace). This is done using the <a class="el" href="group___core_key_val.html#ga51f6fa219f736d9823d14e4b44eee63f" title="Associates a key (character string) with a class and register the class&#39;s KeyVal constructor with Des...">MPQC_CLASS_EXPORT_KEY()</a> macro. <a class="el" href="group___core_key_val.html#ga51f6fa219f736d9823d14e4b44eee63f" title="Associates a key (character string) with a class and register the class&#39;s KeyVal constructor with Des...">MPQC_CLASS_EXPORT_KEY(Reptile)</a> registers GUID "Reptile" with class <code>Reptile</code>. Then a keyword group that includes keyword <code>type</code> set to "Reptile" can be used to construct an object of class <code>Reptile</code> . Note that the <a class="el" href="group___core_key_val.html#ga51f6fa219f736d9823d14e4b44eee63f" title="Associates a key (character string) with a class and register the class&#39;s KeyVal constructor with Des...">MPQC_CLASS_EXPORT_KEY()</a> statements must be placed in global namespace.<ul>
<li>For a class <code>T</code> that lives in a namespace <code>N</code> it is usually desired to use "T" instead of "N::T" for its GUID; this can be done by using the <a class="el" href="group___core_key_val.html#gaed852023b22874529d5999bb2698e760" title="Associates a key (character string) with a class using and register the class&#39;s KeyVal constructor wi...">MPQC_CLASS_EXPORT_KEY2()</a> macro that accepts the string GUID and the class as its two arguments.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Animal could also be an abstract class; no additional complications arise.</dd></dl>
<p>It is convenient to be able to refer to existing objects of classes derived from <a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a> in a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> constructed programmatically. This example demonstrates this capability: </p><div class="fragment"><div class="line">Keyval kv;</div><div class="line">std::shared_ptr&lt;DescribedClass&gt; trex = std::make_shared&lt;Reptile&gt;(...);</div><div class="line">kv.assign(<span class="stringliteral">&quot;trex&quot;</span>, trex);</div><div class="line">assert(kv.class_ptr(<span class="stringliteral">&quot;trex&quot;</span>) == trex);</div></div><!-- fragment --><p>Note that if the type of the object to be constructed is known at compile time, it is not necessary to provide the <code>type</code> keyword as long as <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr&lt;T&gt;</a> is called with the exact type rather than the base class type: </p><div class="fragment"><div class="line"><span class="comment">// must specify trex1::type keyword </span></div><div class="line">std::shared_ptr&lt;Animal&gt; trex1 = kv.class_ptr&lt;Animal&gt;(<span class="stringliteral">&quot;trex1&quot;</span>);</div><div class="line"><span class="comment">// tref2::type does NOT need to be specified</span></div><div class="line">std::shared_ptr&lt;Reptile&gt; trex2 = kv.class_ptr&lt;Reptile&gt;(<span class="stringliteral">&quot;trex2&quot;</span>);</div></div><!-- fragment --><h1><a class="anchor" id="keyvalarray"></a>
Array Specification</h1>
<p>Input for an array can be specified in several forms. In JSON there is standard support for arrays; alternatively, an array can be specified as a keyword group to make it possible to refer to elements of such arrays. Programmatic manipulation of <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> can assign and read arrays stored in standard sequence containers such as <code>std::vector</code> , <code>std::array</code> , and <code>std::list</code> .</p>
<h2><a class="anchor" id="keyvalarrayjsonarray"></a>
JSON Standard Array Syntax</h2>
<p>Consider how the attributes of animals in JSON <a class="el" href="keyval.html#KeyValPage_Example11">Example 3</a> can be specified using JSON arrays: <a class="anchor" id="KeyValPage_Example3"></a></p><pre class="fragment">{
  "names": [ "trex", "python", "bald eagle" ],
  "legs": [ 2, 0, 2 ],
  "extinct": [ true, false, false ]
}
</pre><p> Keyword <code>names</code> equals an array of 3 strings, keyword <code>legs</code> equals an array of 3 integers, etc. The following C++ code can access the data in the corresponding <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> names = kv.value&lt;std::vector&lt;std::string&gt;&gt;(<span class="stringliteral">&quot;names&quot;</span>);</div><div class="line"><span class="keyword">auto</span> legs = kv.value&lt;std::vector&lt;int&gt;&gt;(<span class="stringliteral">&quot;legs&quot;</span>);</div><div class="line"><span class="keyword">auto</span> extinct = kv.value&lt;std::vector&lt;bool&gt;&gt;(<span class="stringliteral">&quot;extinct&quot;</span>);</div></div><!-- fragment --><p> <a class="el" href="classmpqc_1_1_key_val.html#a32a637d5baad1c583252aad02015326b">KeyVal::count</a> can be used to count the number of elements before reading the data: </p><div class="fragment"><div class="line">assert(*kv.count(<span class="stringliteral">&quot;names&quot;</span>) == 3);</div></div><!-- fragment --><p>It is also possible to specify an array of objects: </p><div class="fragment"><div class="line">{</div><div class="line">  <span class="stringliteral">&quot;values&quot;</span> : [</div><div class="line">    { <span class="stringliteral">&quot;value&quot;</span> : 0 },</div><div class="line">    { <span class="stringliteral">&quot;value&quot;</span> : 1 },</div><div class="line">    { <span class="stringliteral">&quot;value&quot;</span> : 2 }</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p> can be parsed as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Value {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  Value() = <span class="keywordflow">default</span>;  <span class="comment">// need this to put it into a container</span></div><div class="line">  Value(<span class="keyword">const</span> KeyVal&amp; kv) : value_(kv.value&lt;int&gt;(<span class="stringliteral">&quot;value&quot;</span>)) {}</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> value_;</div><div class="line">};</div><div class="line"></div><div class="line">kv.value&lt;std::vector&lt;Value&gt;&gt;(<span class="stringliteral">&quot;values&quot;</span>);</div></div><!-- fragment --><p> It is not yet possible to read in polymorphic objects this way.</p>
<dl class="section note"><dt>Note</dt><dd>Elements of an array specified in standard syntax all have same (empty) key, i.e. elements of an array corresponding to path <code>path</code> are located at path <code>path:</code> . This scheme for assigning keys is used by Boost.PropertyTree when reading JSON arrays. This makes it impossible to refer to individual elements since they all share a path, i.e. <code><a class="el" href="classmpqc_1_1_key_val.html#a7f54bf6f1028581ad68496a97afd9174">KeyVal::value&lt;T&gt;</a></code>("path:") return only the first element of the array at path <code>path</code> .</dd></dl>
<h2><a class="anchor" id="keyvalarrayjsonextarray"></a>
JSON Extended Array Syntax</h2>
<p>The extended array syntax specifies arrays as a group of keywords <code>"0"</code>, <code></code>"1", etc. For example, the arrays in JSON <a class="el" href="keyval.html#KeyValPage_Example3">Example 3</a> can be specified in the extended syntax as </p><pre class="fragment">{
  "names": { "0":"trex", "1":"python", "2":"bald eagle" },
  "legs": { "0":2, "1":0, "2":2 },
  "extinct": { "0":true, "1":false, "2":false }
}
</pre><p>Although, this syntax is more verbose than the standard JSON array syntax, it can be used to specify arrays of objects and to refer to the elements of an array (see <a class="el" href="keyval.html#keyvalsub">Value Substitution</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Another advantage of the extended syntax is that by ensuring that all paths are unique and do not involve empty keywords it is compatible with XML.</dd></dl>
<h2><a class="anchor" id="keyvalarrayprogrammatic"></a>
Programmatic Handling of Arrays</h2>
<p>The following C++ snippet demonstrates how to assign array values to keywords, and read the array values: </p><div class="fragment"><div class="line"><span class="comment">// assign three 3-element arrays; std::array, std::vector, and std::list can be used as input</span></div><div class="line">kv.assign(<span class="stringliteral">&quot;x:ivec&quot;</span>, std::vector&lt;int&gt;{{0, 1, 2}});</div><div class="line">kv.assign(<span class="stringliteral">&quot;x:iarr&quot;</span>, std::array&lt;int,3&gt;{{1, 2, 3}});</div><div class="line">kv.assign(<span class="stringliteral">&quot;x:bvec&quot;</span>, std::vector&lt;bool&gt;{{<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>}});</div><div class="line"></div><div class="line"><span class="comment">// read the arrays; the container type is not sticky</span></div><div class="line"><span class="keyword">auto</span> ivec = kv.value&lt;std::array&lt;int,3&gt;&gt;(<span class="stringliteral">&quot;x:ivec&quot;</span>); <span class="comment">// x:ivec was assigned using std::vector, read into std::array</span></div><div class="line"><span class="keyword">auto</span> iarr = kv.value&lt;std::list&lt;int&gt;&gt;(<span class="stringliteral">&quot;x:iarr&quot;</span>);</div><div class="line"><span class="keyword">auto</span> bvec = kv.value&lt;std::vector&lt;bool&gt;&gt;(<span class="stringliteral">&quot;x:bvec&quot;</span>);</div></div><!-- fragment --><h1><a class="anchor" id="keyvalsub"></a>
Value Substitution</h1>
<p>Another powerful feature of <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> is the ability to refer to the same value/object multiple times in a <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a>. The <em>value substitution feature</em> of <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> allows for multiple paths to refer to the same value/object. This is accomplished by setting keyword's value to a string that starts with <code>$</code> followed by the (relative or absolute) path to the keyword whose value to be used. The variable substition feature is best illustrated by a simple JSON example: </p><pre class="fragment">{
  "types": { "0":"Reptile", "1":"Reptile", "2":"Bird" },
  "extinct": { "0":true, "1":false, "2":"$1" },
  "trex": {
    "type": "$:types:0",
    "extinct": "$..:extinct:0"
  },
  "anothertrex": "$trex",
  "bald eagle": {
    "type": "$:types:3",
    "extinct": "$..:extinct:3"
  }
}
</pre><p> is (almost) the same as the following JSON: </p><pre class="fragment">{
  "types": { "0":"Reptile", "1":"Reptile", "2":"Bird" },
  "extinct": { "0":true, "1":false, "2":false },
  "trex": {
    "type": "Reptile",
    "extinct": true
  },
  "anothertrex": {
    "type": "Reptile",
    "extinct": true
  },
  "bald eagle": {
    "type": "Bird",
    "extinct": false
  }
}
</pre><p> The only difference between the examples with and without the value substition: in the first case constructing Reptile objects corresponding to keywords <code>trex</code> and <code>anothertrex</code> would produce pointers to the <em>same</em> object, whereas in the second case the two pointers would refer to two <em>different</em> Reptile objects. This feature is implemented by tracking all smart pointers produced by <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr</a> . The object pointer registry is destroyed when the main <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> and all of its subobjects produced with <a class="el" href="classmpqc_1_1_key_val.html#a013e32435b4fbc49c5c20ea74dd6fa26" title="construct a KeyVal representing a subtree located at the given path ">KeyVal::keyval</a> are destroyed. Therefore it is a good practice to delete <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> objects as soon as they are no longer needed. N.B. the object registry can be bypass by calling <a class="el" href="classmpqc_1_1_key_val.html#af1e398eb00a68455ba539ecac59d0716" title="return a pointer to an object at the given path ">KeyVal::class_ptr</a> with the second argument set to <code>true</code> .</p>
<p>Value substitution can be used also with the programmatic <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> construction: </p><div class="fragment"><div class="line">KeyVal kv;</div><div class="line">kv.assign(<span class="stringliteral">&quot;types:0&quot;</span>, <span class="stringliteral">&quot;Reptile&quot;</span>).assign(<span class="stringliteral">&quot;types:1&quot;</span>, <span class="stringliteral">&quot;Reptile&quot;</span>).assign(<span class="stringliteral">&quot;types:2&quot;</span>, <span class="stringliteral">&quot;Bird&quot;</span>);</div><div class="line">kv.assign(<span class="stringliteral">&quot;extinct:0&quot;</span>, <span class="keyword">true</span>).assign(<span class="stringliteral">&quot;extinct:1&quot;</span>, <span class="keyword">false</span>).assign(<span class="stringliteral">&quot;extinct:2&quot;</span>, <span class="stringliteral">&quot;$1&quot;</span>);</div><div class="line">kv.assign(<span class="stringliteral">&quot;trex:type&quot;</span>, <span class="stringliteral">&quot;$..:types:0&quot;</span>).assign(<span class="stringliteral">&quot;trex:extinct&quot;</span>, <span class="stringliteral">&quot;$:extinct:0&quot;</span>);</div><div class="line">kv.assign(<span class="stringliteral">&quot;anothertrex&quot;</span>, <span class="stringliteral">&quot;$trex&quot;</span>);</div><div class="line">kv.assign(<span class="stringliteral">&quot;bald eagle:type&quot;</span>, <span class="stringliteral">&quot;$..:types:2&quot;</span>).assign(<span class="stringliteral">&quot;bald eagle:extinct&quot;</span>, <span class="stringliteral">&quot;$:extinct:2&quot;</span>);</div><div class="line"></div><div class="line">assert(kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;extinct:0&quot;</span>) == kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;trex:extinct&quot;</span>));</div><div class="line">assert(kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;extinct:1&quot;</span>) == kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;extinct:2&quot;</span>));</div><div class="line">assert(kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;extinct:2&quot;</span>) == kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;bald eagle:extinct&quot;</span>));</div><div class="line">assert(kv.class&lt;Reptile&gt;(<span class="stringliteral">&quot;trex&quot;</span>) == kv.class&lt;Reptile&gt;(<span class="stringliteral">&quot;anothertrex&quot;</span>)); <span class="comment">// anothertrex referred to trex, hence point to same object</span></div></div><!-- fragment --><p>Value substitution can also be used when constructing polymorphic objects programmatically: </p><div class="fragment"><div class="line">KeyVal kv;</div><div class="line">std::shared_ptr&lt;DescribedClass&gt; donkey = std::make_shared&lt;Donkey&gt;();</div><div class="line">std::shared_ptr&lt;DescribedClass&gt; horse = std::make_shared&lt;Horse&gt;();</div><div class="line">kv.assign(<span class="stringliteral">&quot;donkey&quot;</span>, donkey);</div><div class="line">kv.assign(<span class="stringliteral">&quot;horse&quot;</span>, horse);</div><div class="line">kv.assign(<span class="stringliteral">&quot;mule:type&quot;</span>, <span class="stringliteral">&quot;Mule&quot;</span>);</div><div class="line">kv.assign(<span class="stringliteral">&quot;mule:father&quot;</span>, <span class="stringliteral">&quot;$:donkey&quot;</span>);</div><div class="line">kv.assign(<span class="stringliteral">&quot;mule:mother&quot;</span>, <span class="stringliteral">&quot;$..:horse&quot;</span>);</div><div class="line"><span class="keyword">auto</span> mule = kv.class_ptr(<span class="stringliteral">&quot;mule&quot;</span>);</div></div><!-- fragment --><h1><a class="anchor" id="keyvaldescribedclass"></a>
The DescribedClass class</h1>
<p>To support polymorphic object construction (see <a class="el" href="keyval.html#keyvalpobj">Polymorphic Object Construction</a>) the base class must be (publicly) derived from <a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a>. This potentially adds the overhead of a vtable (<a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a> has a virtual destructor) and can complicate the lifetime management of such objects because their smart pointers will survive in <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object's registry at least through the lifetime of the owning <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> object.</p>
<p>To be able to construct a class <code>T</code> from <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> objects do this:</p><ol type="1">
<li>make <a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a> a public base of <code>T</code>, or any of its bases, and</li>
<li><p class="startli">register <code>T</code> with <a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a> . The latter can be achieved in a number of ways, but the easiest is to add any of the following statements to a source file in the <em>global</em> scope:</p><ol type="a">
<li>if you want to use class name <code>T</code> as the type identifier in <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> input: <code><a class="el" href="group___core_key_val.html#ga51f6fa219f736d9823d14e4b44eee63f" title="Associates a key (character string) with a class and register the class&#39;s KeyVal constructor with Des...">MPQC_CLASS_EXPORT_KEY(T)</a></code> </li>
<li>if you want to use any other key <code>Key</code> as the type identifier in <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> input: <code><a class="el" href="group___core_key_val.html#gaed852023b22874529d5999bb2698e760" title="Associates a key (character string) with a class using and register the class&#39;s KeyVal constructor wi...">MPQC_CLASS_EXPORT_KEY2(Key, T)</a></code> </li>
</ol>
<p class="startli">It is the easiest to add these statements to the .cpp file that defines <code>T</code> , but any other .cpp file will work.</p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Both <a class="el" href="group___core_key_val.html#ga51f6fa219f736d9823d14e4b44eee63f" title="Associates a key (character string) with a class and register the class&#39;s KeyVal constructor with Des...">MPQC_CLASS_EXPORT_KEY()</a> and <a class="el" href="group___core_key_val.html#gaed852023b22874529d5999bb2698e760" title="Associates a key (character string) with a class using and register the class&#39;s KeyVal constructor wi...">MPQC_CLASS_EXPORT_KEY2()</a> create a Global Unique ID (GUID) for the class using a mechanism similar to that of the Boost.Serialization library. (see <a href="http://www.boost.org/doc/libs/master/libs/serialization/doc/special.html#export">Boost docs</a> for more details). However, using these macros does not make the type usable with Boost.Serialization, you should use the corresponding BOOST_CLASS_EXPORT() and BOOST_CLASS_EXPORT2() macros (in practice you are likely to need to use BOOST_CLASS_EXPORT_KEY(), or BOOST_CLASS_EXPORT_KEY2(), and BOOST_CLASS_EXPORT_IMPLEMENT(): read the docs CAREFULLY as it is very easy to introduce subtle bugs by misusing the macros).</dd>
<dd>
As of Boost 1.62.0, the Boost.Serialization macros BOOST_CLASS_EXPORT_KEY(), BOOST_CLASS_EXPORT_KEY2() and BOOST_CLASS_EXPORT_IMPLEMENT() are not variadic and should not work for template classes with 2 or more template arguments. MPQC provides macros <a class="el" href="group___core_key_val.html#ga6c4a793e1de57c764a2f01c39e364a69">MPQC_BOOST_CLASS_EXPORT_KEY2()</a> and <a class="el" href="group___core_key_val.html#gac2204ef81dabb828d11afcfbe3c71106" title="Forces the class instantiation so that it can be deserialized with Boost.Serialization. ">MPQC_BOOST_CLASS_EXPORT_IMPLEMENT()</a> that should be used in their place for classes with 2 or more template arguments.</dd>
<dd>
If <code>T</code> is a template class, you must register each instance of this class you want to construct from <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a>.</dd></dl>
<h1><a class="anchor" id="keyvalforcelink"></a>
Forced linkage of DescribedClass objects</h1>
<p>Executables that initialize DescribedClass-derived objects using the <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> library need a mechanism for forcing the linkage of the corresponding libraries. For example, the MPQC executable program knows that user will want to construct and use an object of <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a> class, but does not know GUID of <em>which</em> <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a> class the user specified in the input file until runtime. The easiest way to force the linkage of all <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a> classes that the executable wants to be able to use is to explicitly instantiate an object of every <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a> class. But this would create a massive compile dependency between all <em>template</em> classes derived from <a class="el" href="classmpqc_1_1_wavefunction.html">Wavefunction</a>: changing any of them will force recompilation of all of them when recompiling the main executable. Class ForceLink provides a workaround to this problem. To force linkage of template class <code>T</code> into an executable the user needs to do the following:</p><ul>
<li>add the following code to the executable: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="forcelink_8h.html">mpqc/util/keyval/forcelink.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">class </span>T;  <span class="comment">// note the forward declaration! no need to include the definition of T</span></div><div class="line"></div><div class="line"><span class="comment">// define 1 ForceLink object per each instantiation of T</span></div><div class="line"><a class="code" href="classmpqc_1_1detail_1_1_force_link.html">mpqc::detail::ForceLink&lt;T&lt;double&gt;</a>&gt; link_T_double;</div><div class="line"><a class="code" href="classmpqc_1_1detail_1_1_force_link.html">mpqc::detail::ForceLink&lt;T&lt;int&gt;</a>&gt; link_T_int;</div></div><!-- fragment --></li>
<li>instantate and export instances of class <code>T</code> in a source file of the library that defines <code>T</code> : <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="forcelink_8h.html">mpqc/util/keyval/forcelink.h</a>&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="forcelink_8h.html#a7a68d88f5aba42f53d3463da467faaa9">MPQC_FORCELINK_KEYVAL_CTOR</a>(T&lt;double&gt;);</div><div class="line"><a class="code" href="forcelink_8h.html#a7a68d88f5aba42f53d3463da467faaa9">MPQC_FORCELINK_KEYVAL_CTOR</a>(T&lt;int&gt;);</div></div><!-- fragment --></li>
</ul>
<p>N.B. For convenience, we provide macros <a class="el" href="forcelink_8h.html#aff5941b10809304cee7c20c59a57dd82">MPQC_CLASS_EXPORT()</a> and <a class="el" href="forcelink_8h.html#a837d2c91108e8f94b86681d7d6eddd94">MPQC_CLASS_EXPORT2()</a> that combine the <a class="el" href="classmpqc_1_1_described_class.html">DescribedClass</a> registration macros <a class="el" href="group___core_key_val.html#ga51f6fa219f736d9823d14e4b44eee63f" title="Associates a key (character string) with a class and register the class&#39;s KeyVal constructor with Des...">MPQC_CLASS_EXPORT_KEY()</a> and <a class="el" href="group___core_key_val.html#gaed852023b22874529d5999bb2698e760" title="Associates a key (character string) with a class using and register the class&#39;s KeyVal constructor wi...">MPQC_CLASS_EXPORT_KEY2()</a>, respectively, with the <a class="el" href="forcelink_8h.html#a7a68d88f5aba42f53d3463da467faaa9" title="Streamlines the definition of ForceLink&lt;T&gt;::create methods. ">MPQC_FORCELINK_KEYVAL_CTOR()</a> macro.</p>
<h1><a class="anchor" id="keyvaldeprecatedkw"></a>
Deprecated keywords</h1>
<p>It is useful to be able to deprecate some keywords to be able to evolve input format smoothly. For example, we may want to rename an input keyword, but do not want to obsolete the keyword until some future software release. By obsoleting the keyword we can nudge the users to start using new keywords. For example, if we want to rename keywords <code>"extinct"</code> in JSON <a class="el" href="keyval.html#KeyValPage_Example1">Example 1</a> to <code>"is_extinct"</code>, we need to modify the <a class="el" href="classmpqc_1_1_key_val.html" title="KeyVal specifies C++ primitive data (booleans, integers, reals, string) and user-defined objects obta...">KeyVal</a> constructor of class <code>Bird</code> (C++ <a class="el" href="keyval.html#KeyValPage_Example4">Example 4</a>) to initialize field <code>extinct</code> as </p><div class="fragment"><div class="line">extinct = kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;is_extinct&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;extinct&quot;</span>);</div></div><!-- fragment --><p> This code will:</p><ul>
<li>query keyword <code>is_extinct</code> , if not found</li>
<li>query deprecated keyword <code>extinct</code> , if not found</li>
<li>initialize field <code>extinct</code> to <code>false</code> </li>
</ul>
<p>If the deprecated keyword is <em>read</em> (not just queried), a message will be added by default to <code>std::cerr</code> . It is possible to change the default to throwing an exception (specifically, <code><a class="el" href="structmpqc_1_1_key_val_1_1bad__input.html" title="KeyVal exception. ">KeyVal::bad_input</a></code> ) by calling <code>KeyVal::throw_if_deprecated_path(true)</code> .</p>
<p>To deprecate a keyword without specifying a replacement the primary keyword can be empty: </p><div class="fragment"><div class="line">extinct = kv.value&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;is_extinct&quot;</span>, <span class="keyword">false</span>, <span class="stringliteral">&quot;extinct&quot;</span>);</div></div><!-- fragment --><p> This code will:</p><ul>
<li>query deprecated keyword <code>extinct</code> , if not found</li>
<li>initialize field <code>extinct</code> to <code>false</code> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address>
<small>
Generated at Mon Aug 27 2018 08:29:38 for <a
href="http://www.mpqc.org">MPQC</a>
4.0.0-beta.1 using the documentation package <a
href="http://www.doxygen.org">Doxygen</a>
1.8.14.
</small>
</address>
</body>
</html>
