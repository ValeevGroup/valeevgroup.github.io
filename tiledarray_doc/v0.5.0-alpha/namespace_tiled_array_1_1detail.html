<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>TiledArray: TiledArray::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TiledArray
   &#160;<span id="projectnumber">0.5.0-alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_tiled_array_1_1detail.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray::detail Namespace Reference<div class="ingroups"><a class="el" href="group___tile_interface.html">Tile interface for user defined tensor types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper.html">ArgumentHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01_future_3_01_t_01_4_01_4.html">ArgumentHelper&lt; Future&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01std_1_1pair_3_01_future_3_01_t_01_4_00_01_future_3_01_u_01_4_01_4_01_4.html">ArgumentHelper&lt; std::pair&lt; Future&lt; T &gt;, Future&lt; U &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html">ArrayEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator for <code><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">TiledArray::Array</a></code> objects.  <a href="class_tiled_array_1_1detail_1_1_array_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_iiterator.html">ArrayIiterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed tensor iterator.  <a href="class_tiled_array_1_1detail_1_1_array_iiterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_impl.html">ArrayImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_array_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html">BinaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary, distributed tensor evaluator.  <a href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_wrapper.html">BinaryWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary tile operation wrapper.  <a href="class_tiled_array_1_1detail_1_1_binary_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size bitset.  <a href="class_tiled_array_1_1detail_1_1_bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_blocked_pmap.html">BlockedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A blocked process map.  <a href="class_tiled_array_1_1detail_1_1_blocked_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01_complex_neg_tag_01_4.html">ComplexConjugate&lt; ComplexNegTag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01void_01_4.html">ComplexConjugate&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html">CyclicPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps cyclically a sequence of indices onto a 2-d matrix of processes.  <a href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval.html">DistEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> expression object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html">DistEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator implementation object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_distributed_storage.html">DistributedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed storage container.  <a href="class_tiled_array_1_1detail_1_1_distributed_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_hash_pmap.html">HashPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashed process map.  <a href="class_tiled_array_1_1detail_1_1_hash_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile.html">is_array_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect tiles used by <code><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html" title="Distributed evaluator for TiledArray::Array objects. ">ArrayEvalImpl</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__array__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile_3_01_tiled_array_1_1detail_1_1_lazy_array_tile_3_01_t_00_01_op_01_4_01_4.html">is_array_tile&lt; TiledArray::detail::LazyArrayTile&lt; T, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_complex&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor.html">is_contiguous_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t_01_4.html">is_contiguous_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_contiguous_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_4.html">is_contiguous_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper.html">is_contiguous_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_contiguous_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_contiguous_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_interface_3_01_t_00_01_range_01_4_01_4.html">is_contiguous_tensor_helper&lt; TensorInterface&lt; T, Range &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__dense.html">is_dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if <code>T</code> is a dense array type.  <a href="struct_tiled_array_1_1detail_1_1is__dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__dense_3_01_dist_array_3_01_tile_00_01_dense_policy_01_4_01_4.html">is_dense&lt; DistArray&lt; Tile, DensePolicy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">is_integral_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper.html">is_integral_list_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_01_t_00_01_ts_8_8_8_01_4.html">is_integral_list_helper&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_4.html">is_integral_list_helper&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5_00_01void_01_4.html">is_iterator&lt; const T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; const T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5_00_01void_01_4.html">is_iterator&lt; T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_00_01typename_01std_1_1enable__if_3_01is__tyf33ee9a886ca9d82cca7639bd5722af8.html">is_iterator&lt; T, typename std::enable_if&lt; is_type&lt; typename T::iterator_category &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html">is_non_array_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect a lazy evaluation tile that are not a <code><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html" title="Lazy tile for on-the-fly evaluation of array tiles. ">LazyArrayTile</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric.html">is_numeric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01bool_01_4.html">is_numeric&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01_complex_conjugate_3_01_s_01_4_01_4.html">is_numeric&lt; ComplexConjugate&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_numeric&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__output__iterator.html">is_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__random__iterator.html">is_random_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_scalar&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted.html">is_shifted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t_01_4.html">is_shifted&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_shifted&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_4.html">is_shifted&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper.html">is_shifted_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_shifted_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor.html">is_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t_01_4.html">is_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_4.html">is_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper.html">is_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01const_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; const T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_interface_3_01_t_00_01_r_01_4_01_4.html">is_tensor_helper&lt; TensorInterface&lt; T, R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor.html">is_tensor_of_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t_01_4.html">is_tensor_of_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor_of_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_4.html">is_tensor_of_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper.html">is_tensor_of_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_of_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_of_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_interface_3_01_t_00_01_range_type_01_4_01_4.html">is_tensor_of_tensor_helper&lt; TensorInterface&lt; T, RangeType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__type.html">is_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html">LazyArrayTile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy tile for on-the-fly evaluation of array tiles.  <a href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1non__iterator__tag.html">non_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">numeric_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for extracting the numeric type of tensors and arrays.  <a href="struct_tiled_array_1_1detail_1_1numeric__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_eigen_1_1_array_3_01_t_00_01_rows_00_01_cols_2dc1846cf3442651d13911035a045167.html">numeric_type&lt; Eigen::Array&lt; T, Rows, Cols, Opts, MaxRows, MaxCols &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_eigen_1_1_map_3_01_plain_object_type_00_01_madde20a404ff8630b7fe4aeb0d69ce57e.html">numeric_type&lt; Eigen::Map&lt; PlainObjectType, MapOptions, StrideType &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_eigen_1_1_matrix_3_01_t_00_01_rows_00_01_colsa4a4e2b0c5fc859c2d4c3373b5e620d7.html">numeric_type&lt; Eigen::Matrix&lt; T, Rows, Cols, Opts, MaxRows, MaxCols &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01_01_01_01_01_01_01_01_01_01_01_01_01_0f213729785db708601396ca16c55663d.html">numeric_type&lt; T,                                           typename std::enable_if&lt; is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01_01_0c1381c49a6edc60898b614b0663635ec.html">numeric_type&lt; T, typename std::enable_if&lt;                                                                  is_lazy_tile&lt; T &gt;::value                                                           &amp;&amp;!is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01_01_0a17740bbcc6e8df1acabdcac107e7268.html">numeric_type&lt; T, typename std::enable_if&lt;                                                                  is_type&lt; typename T::value_type &gt;::value &amp;&amp;                                                           (!is_lazy_tile&lt; T &gt;::value)&amp;&amp;                                                           (!is_numeric&lt; T &gt;::value)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_tile_3_01_t_01_4_00_01void_01_4.html">numeric_type&lt; Tile&lt; T &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01is__numeric_33ed69f6b1e4f90bd5899462119a67d06.html">param&lt; T, typename std::enable_if&lt; is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__po026251cf0f0a4c03557bdf8a6565693e.html">param&lt; T, typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__rece401fa407cc0a1ee19af25268964063.html">param&lt; T, typename std::enable_if&lt; std::is_reference&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_perm_index.html">PermIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that permutes ordinal indices.  <a href="class_tiled_array_1_1detail_1_1_perm_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1policy__type.html">policy_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1policy__type_3_01_dist_array_3_01_tile_00_01_policy_01_4_01_4.html">policy_type&lt; DistArray&lt; Tile, Policy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_proc_grid.html">ProcGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D processor grid.  <a href="class_tiled_array_1_1detail_1_1_proc_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinate index iterate.  <a href="class_tiled_array_1_1detail_1_1_range_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html">ReducePairOpWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper that to convert a pair-wise reduction into a standard reduction.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html">ReducePairTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce pair task.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_task.html">ReduceTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce task.  <a href="class_tiled_array_1_1detail_1_1_reduce_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1remove__cvr.html">remove_cvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove const, volatile, and reference qualifiers.  <a href="struct_tiled_array_1_1detail_1_1remove__cvr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicated_pmap.html">ReplicatedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Replicated process map.  <a href="class_tiled_array_1_1detail_1_1_replicated_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicator.html">Replicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate a <code>Array</code> object.  <a href="class_tiled_array_1_1detail_1_1_replicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">scalar_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01std_1_1complex_3_01_t_01_4_01_4.html">scalar_type&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Tile shift operation. ">Shift</a> wrapper class.  <a href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array wrapper.  <a href="class_tiled_array_1_1detail_1_1_size_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_summa.html">Summa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed contraction evaluator implementation.  <a href="class_tiled_array_1_1detail_1_1_summa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_const_reference.html">TensorConstReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_impl.html">TensorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_tensor_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> interface for external data.  <a href="class_tiled_array_1_1detail_1_1_tensor_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_reference.html">TensorReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html">UnaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> that is composed from an argument tensor.  <a href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_wrapper.html">UnaryWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary tile operation wrapper.  <a href="class_tiled_array_1_1detail_1_1_unary_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value array.  <a href="class_tiled_array_1_1detail_1_1_val_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a763e783371e091990055d391dc6d2090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a763e783371e091990055d391dc6d2090"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a763e783371e091990055d391dc6d2090">numeric_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a763e783371e091990055d391dc6d2090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5d3c6ec63959b5ed57e480adf45732d7">scalar_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">param_type</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt; U &gt;::type</td></tr>
<tr class="separator:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af97c9bf4ef025af9a6a81c86b49d2fad">add_t</a> = decltype(std::declval&lt; Scalar1 &gt;()+std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb1097bfa2f729cf40656648ed4116a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:abeb1097bfa2f729cf40656648ed4116a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abeb1097bfa2f729cf40656648ed4116a">subt_t</a> = decltype(std::declval&lt; Scalar1 &gt;()-std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:abeb1097bfa2f729cf40656648ed4116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0808e462394d3ca16b63a873448283bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:a0808e462394d3ca16b63a873448283bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0808e462394d3ca16b63a873448283bd">mult_t</a> = decltype(std::declval&lt; Scalar1 &gt;()*std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:a0808e462394d3ca16b63a873448283bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">trange_t</a> = typename T::trange_type</td></tr>
<tr class="separator:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3199b02c7815c0d03a919fc87807656a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3199b02c7815c0d03a919fc87807656a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3199b02c7815c0d03a919fc87807656a">shape_t</a> = typename T::shape_type</td></tr>
<tr class="separator:a3199b02c7815c0d03a919fc87807656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">pmap_t</a> = typename T::pmap_interface</td></tr>
<tr class="separator:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4711b607050b27e4cee4c5fb4b6b880b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4711b607050b27e4cee4c5fb4b6b880b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a4711b607050b27e4cee4c5fb4b6b880b">policy_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1policy__type.html">policy_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a4711b607050b27e4cee4c5fb4b6b880b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad38f2970e843e56f76822d775d4d52c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9">dummy_annotation</a> (unsigned int DIM)</td></tr>
<tr class="separator:ad38f2970e843e56f76822d775d4d52c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1d6fcb450ef829c3ad4e8e1db5be514a">swap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b0, <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b1)</td></tr>
<tr class="separator:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a47735f4cdfcb24330a02fe4d9e68b8e7">operator&amp;</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and operator of bitset.  <a href="#a47735f4cdfcb24330a02fe4d9e68b8e7">More...</a><br /></td></tr>
<tr class="separator:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d0266e20b12eefced1cde7a01d4cdcd">operator|</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or operator of bitset.  <a href="#a0d0266e20b12eefced1cde7a01d4cdcd">More...</a><br /></td></tr>
<tr class="separator:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9c12507ffe191d9e79b32f6687ec46b1">operator^</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a9c12507ffe191d9e79b32f6687ec46b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor operator of bitset.  <a href="#a9c12507ffe191d9e79b32f6687ec46b1">More...</a><br /></td></tr>
<tr class="separator:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aaf888c0b992f597156737f71e2bc6d32">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;bitset)</td></tr>
<tr class="separator:aaf888c0b992f597156737f71e2bc6d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb8da29b68c4968447132218416e21"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Derived &gt; </td></tr>
<tr class="memitem:a32cb8da29b68c4968447132218416e21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a32cb8da29b68c4968447132218416e21">counted_eigen_submatrix_to_tensor</a> (const Eigen::MatrixBase&lt; Derived &gt; *matrix, A &amp;array, const typename A::size_type i, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:a32cb8da29b68c4968447132218416e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix to a tensor.  <a href="#a32cb8da29b68c4968447132218416e21">More...</a><br /></td></tr>
<tr class="separator:a32cb8da29b68c4968447132218416e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename T &gt; </td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2">counted_tensor_to_eigen_submatrix</a> (const T &amp;tensor, Eigen::MatrixBase&lt; Derived &gt; *matrix, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:afe493525138ef355ba76900e56ae8cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix.  <a href="#afe493525138ef355ba76900e56ae8cf2">More...</a><br /></td></tr>
<tr class="separator:afe493525138ef355ba76900e56ae8cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecba5efe7b319458a9f16df0563472b"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename Arg , typename Result &gt; </td></tr>
<tr class="memitem:a9ecba5efe7b319458a9f16df0563472b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b">permute_array</a> (const Perm &amp;perm, const Arg &amp;arg, Result &amp;result)</td></tr>
<tr class="memdesc:a9ecba5efe7b319458a9f16df0563472b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of an array.  <a href="#a9ecba5efe7b319458a9f16df0563472b">More...</a><br /></td></tr>
<tr class="separator:a9ecba5efe7b319458a9f16df0563472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a48b1ec146fbd546954d72262124a5b74">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a48b1ec146fbd546954d72262124a5b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a48b1ec146fbd546954d72262124a5b74">More...</a><br /></td></tr>
<tr class="separator:a48b1ec146fbd546954d72262124a5b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3699581fa58aa15f3376c5e6f66f68b3">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a3699581fa58aa15f3376c5e6f66f68b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a3699581fa58aa15f3376c5e6f66f68b3">More...</a><br /></td></tr>
<tr class="separator:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af085e2abd40acbf24fbc80033634097b">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;orig)</td></tr>
<tr class="separator:af085e2abd40acbf24fbc80033634097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a7179e9c73eed3c5738bf4d0c5ebd068d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;size_array)</td></tr>
<tr class="separator:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a7abe197b45ae95a4132fc240ed383"><td class="memTemplParams" colspan="2">template&lt;typename R , typename std::enable_if&lt;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a32a7abe197b45ae95a4132fc240ed383"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">conj</a> (const R r)</td></tr>
<tr class="memdesc:a32a7abe197b45ae95a4132fc240ed383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code>std::conj</code>  <a href="#a32a7abe197b45ae95a4132fc240ed383">More...</a><br /></td></tr>
<tr class="separator:a32a7abe197b45ae95a4132fc240ed383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381e9dfb596a18e208171ce358fa6f16"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a381e9dfb596a18e208171ce358fa6f16"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE std::complex&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a381e9dfb596a18e208171ce358fa6f16">conj</a> (const std::complex&lt; R &gt; z)</td></tr>
<tr class="memdesc:a381e9dfb596a18e208171ce358fa6f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for std::conj.  <a href="#a381e9dfb596a18e208171ce358fa6f16">More...</a><br /></td></tr>
<tr class="separator:a381e9dfb596a18e208171ce358fa6f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af885da1706c23576a28eb38b7afab176"><td class="memTemplParams" colspan="2">template&lt;typename R , typename std::enable_if&lt;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af885da1706c23576a28eb38b7afab176"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af885da1706c23576a28eb38b7afab176">norm</a> (const R r)</td></tr>
<tr class="memdesc:af885da1706c23576a28eb38b7afab176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code>std::norm</code>  <a href="#af885da1706c23576a28eb38b7afab176">More...</a><br /></td></tr>
<tr class="separator:af885da1706c23576a28eb38b7afab176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af182bb984874298c8351edad6f03517c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:af182bb984874298c8351edad6f03517c"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af182bb984874298c8351edad6f03517c">norm</a> (const std::complex&lt; R &gt; z)</td></tr>
<tr class="memdesc:af182bb984874298c8351edad6f03517c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm of a complex number <code>z</code>  <a href="#af182bb984874298c8351edad6f03517c">More...</a><br /></td></tr>
<tr class="separator:af182bb984874298c8351edad6f03517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a78aafa383b1b3e69b6e57b6b78c61306">conj_op</a> (const S factor)</td></tr>
<tr class="memdesc:a78aafa383b1b3e69b6e57b6b78c61306"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function.  <a href="#a78aafa383b1b3e69b6e57b6b78c61306">More...</a><br /></td></tr>
<tr class="separator:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c470158b2bbbdb712cbbaf18a55101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab2c470158b2bbbdb712cbbaf18a55101">conj_op</a> ()</td></tr>
<tr class="memdesc:ab2c470158b2bbbdb712cbbaf18a55101"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function.  <a href="#ab2c470158b2bbbdb712cbbaf18a55101">More...</a><br /></td></tr>
<tr class="separator:ab2c470158b2bbbdb712cbbaf18a55101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0b7cc0cdac97544b2f0511894b4e55"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a6e0b7cc0cdac97544b2f0511894b4e55"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a6e0b7cc0cdac97544b2f0511894b4e55">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt; op) -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value)*op.factor())        </td></tr>
<tr class="separator:a6e0b7cc0cdac97544b2f0511894b4e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6134f3cf8937e7fea6bc822a1b8254"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a3b6134f3cf8937e7fea6bc822a1b8254"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3b6134f3cf8937e7fea6bc822a1b8254">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;) -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))        </td></tr>
<tr class="separator:a3b6134f3cf8937e7fea6bc822a1b8254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde746dca4328f6cc7927e04716afa7c"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:abde746dca4328f6cc7927e04716afa7c"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abde746dca4328f6cc7927e04716afa7c">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;) -&gt; decltype(-<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))        </td></tr>
<tr class="separator:abde746dca4328f6cc7927e04716afa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2cdb4243dea691e0c8a4471c561340"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a0d2cdb4243dea691e0c8a4471c561340"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d2cdb4243dea691e0c8a4471c561340">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; L &gt; op, const R value) -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value)*op.factor())        </td></tr>
<tr class="separator:a0d2cdb4243dea691e0c8a4471c561340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5c814e34b5fb11e9ada74a4002233b"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a1f5c814e34b5fb11e9ada74a4002233b"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1f5c814e34b5fb11e9ada74a4002233b">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;, const R value) -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))        </td></tr>
<tr class="separator:a1f5c814e34b5fb11e9ada74a4002233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d5be76f71a2d3a280b20faf92e5fa5"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:aa7d5be76f71a2d3a280b20faf92e5fa5"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa7d5be76f71a2d3a280b20faf92e5fa5">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt;, const R value) -&gt; decltype(-<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))        </td></tr>
<tr class="separator:aa7d5be76f71a2d3a280b20faf92e5fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea2c5a93d37330153912da87c7c3877"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R , typename std::enable_if&lt;!std::is_void&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acea2c5a93d37330153912da87c7c3877"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#acea2c5a93d37330153912da87c7c3877">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt; op)</td></tr>
<tr class="separator:acea2c5a93d37330153912da87c7c3877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa443b57aebf3d340cc65deeeb00c2073"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:aa443b57aebf3d340cc65deeeb00c2073"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa443b57aebf3d340cc65deeeb00c2073">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;)</td></tr>
<tr class="separator:aa443b57aebf3d340cc65deeeb00c2073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab4bd519fc858458a6bf061c1ef2ef5b3">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;)</td></tr>
<tr class="separator:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17e850985b5c94dc082d40978d0e22c"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac17e850985b5c94dc082d40978d0e22c"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac17e850985b5c94dc082d40978d0e22c">tensor_op</a> (Op &amp;&amp;op, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:ac17e850985b5c94dc082d40978d0e22c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> operations with contiguous data.  <a href="#ac17e850985b5c94dc082d40978d0e22c">More...</a><br /></td></tr>
<tr class="separator:ac17e850985b5c94dc082d40978d0e22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968a88eff54f4dc3105f31c57a5e06ac"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value)                                       &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a968a88eff54f4dc3105f31c57a5e06ac"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a968a88eff54f4dc3105f31c57a5e06ac">tensor_op</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a968a88eff54f4dc3105f31c57a5e06ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> permutation operations with contiguous data.  <a href="#a968a88eff54f4dc3105f31c57a5e06ac">More...</a><br /></td></tr>
<tr class="separator:a968a88eff54f4dc3105f31c57a5e06ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab349de6abb99d242fdfa23318f28b407"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab349de6abb99d242fdfa23318f28b407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab349de6abb99d242fdfa23318f28b407">inplace_tensor_op</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:ab349de6abb99d242fdfa23318f28b407"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor operations with contiguous data.  <a href="#ab349de6abb99d242fdfa23318f28b407">More...</a><br /></td></tr>
<tr class="separator:ab349de6abb99d242fdfa23318f28b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea82008dbcee62101a2865a602852cb"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acea82008dbcee62101a2865a602852cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#acea82008dbcee62101a2865a602852cb">inplace_tensor_op</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:acea82008dbcee62101a2865a602852cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor permutation operations with contiguous data.  <a href="#acea82008dbcee62101a2865a602852cb">More...</a><br /></td></tr>
<tr class="separator:acea82008dbcee62101a2865a602852cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad0cc592bab4bc45fd24ad38ce5805d38">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with contiguous tensor arguments.  <a href="#ad0cc592bab4bc45fd24ad38ce5805d38">More...</a><br /></td></tr>
<tr class="separator:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474df5f74ea75c66470f333f78dad3d5"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a474df5f74ea75c66470f333f78dad3d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a474df5f74ea75c66470f333f78dad3d5">tensor_init</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a474df5f74ea75c66470f333f78dad3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with permuted tensor arguments.  <a href="#a474df5f74ea75c66470f333f78dad3d5">More...</a><br /></td></tr>
<tr class="separator:a474df5f74ea75c66470f333f78dad3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843205677d75eda1fcd81b50f9042b84"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value                                                           &amp;&amp;!is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a843205677d75eda1fcd81b50f9042b84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a843205677d75eda1fcd81b50f9042b84">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a843205677d75eda1fcd81b50f9042b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with one or more non-contiguous tensor arguments.  <a href="#a843205677d75eda1fcd81b50f9042b84">More...</a><br /></td></tr>
<tr class="separator:a843205677d75eda1fcd81b50f9042b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c95c206465e8ff50da0a55ab3878a2"><td class="memTemplParams" colspan="2">template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if&lt; is_numeric&lt; Scalar &gt;::value &amp;&amp;is_tensor&lt; T1, Ts... &gt;::value                                           &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a72c95c206465e8ff50da0a55ab3878a2"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a72c95c206465e8ff50da0a55ab3878a2">tensor_reduce</a> (ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;join_op, Scalar identity, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a72c95c206465e8ff50da0a55ab3878a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> reduction operation for contiguous tensors.  <a href="#a72c95c206465e8ff50da0a55ab3878a2">More...</a><br /></td></tr>
<tr class="separator:a72c95c206465e8ff50da0a55ab3878a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dc83ca421c400766d0f15bf0652691"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:a91dc83ca421c400766d0f15bf0652691"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a91dc83ca421c400766d0f15bf0652691">fuse_dimensions</a> (SizeType *restrict const fused_size, SizeType *restrict const fused_weight, const SizeType *restrict const <a class="el" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02">size</a>, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a91dc83ca421c400766d0f15bf0652691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fused dimensions for permutation.  <a href="#a91dc83ca421c400766d0f15bf0652691">More...</a><br /></td></tr>
<tr class="separator:a91dc83ca421c400766d0f15bf0652691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccc13338ac000c35d064a2b147b52f6"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename Result , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:abccc13338ac000c35d064a2b147b52f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abccc13338ac000c35d064a2b147b52f6">permute</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, Result &amp;result, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const Arg0 &amp;arg0, const Args &amp;...args)</td></tr>
<tr class="memdesc:abccc13338ac000c35d064a2b147b52f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a permuted tensor copy.  <a href="#abccc13338ac000c35d064a2b147b52f6">More...</a><br /></td></tr>
<tr class="separator:abccc13338ac000c35d064a2b147b52f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c">is_range_congruent</a> (const Left &amp;left, const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:aa49fdad6dffe4694cd2f6568461a409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for congruent range objects with a shifted tensor.  <a href="#aa49fdad6dffe4694cd2f6568461a409c">More...</a><br /></td></tr>
<tr class="separator:aa49fdad6dffe4694cd2f6568461a409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb317d5215b2beef4f9093ce8f81d96"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9eb317d5215b2beef4f9093ce8f81d96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9eb317d5215b2beef4f9093ce8f81d96">clone_range</a> (const T &amp;tensor) -&gt; decltype(tensor.range())        </td></tr>
<tr class="memdesc:a9eb317d5215b2beef4f9093ce8f81d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the range of the tensor.  <a href="#a9eb317d5215b2beef4f9093ce8f81d96">More...</a><br /></td></tr>
<tr class="separator:a9eb317d5215b2beef4f9093ce8f81d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afd25794432f3ae654ef616a170280af3">clone_range</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:afd25794432f3ae654ef616a170280af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a contiguous copy of the range of the tensor.  <a href="#afd25794432f3ae654ef616a170280af3">More...</a><br /></td></tr>
<tr class="separator:afd25794432f3ae654ef616a170280af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0b9a43dfee2749874d4677ea89ab4188">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a0b9a43dfee2749874d4677ea89ab4188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of tensors are congruent.  <a href="#a0b9a43dfee2749874d4677ea89ab4188">More...</a><br /></td></tr>
<tr class="separator:a0b9a43dfee2749874d4677ea89ab4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa35b616db0b6d4da11b862de9570fb93">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aa35b616db0b6d4da11b862de9570fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of permuted tensors are congruent.  <a href="#aa35b616db0b6d4da11b862de9570fb93">More...</a><br /></td></tr>
<tr class="separator:aa35b616db0b6d4da11b862de9570fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T &amp;tensor)</td></tr>
<tr class="memdesc:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted tensor is congruent with itself.  <a href="#a0d75a0a0d43e9a5d8beec072cdbe678c">More...</a><br /></td></tr>
<tr class="separator:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938eb07a4afc6e9ed4c238b24a504074"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a938eb07a4afc6e9ed4c238b24a504074"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a938eb07a4afc6e9ed4c238b24a504074">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a938eb07a4afc6e9ed4c238b24a504074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted set of tensors are congruent.  <a href="#a938eb07a4afc6e9ed4c238b24a504074">More...</a><br /></td></tr>
<tr class="separator:a938eb07a4afc6e9ed4c238b24a504074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8d01c42f84f360ae79da4a0c8e5b84a2">is_range_set_congruent</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a tensor is congruent with itself.  <a href="#a8d01c42f84f360ae79da4a0c8e5b84a2">More...</a><br /></td></tr>
<tr class="separator:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af1762b34b3d5d9a4eb5ceea9b6b3ad43">is_range_set_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a set of tensors are congruent.  <a href="#af1762b34b3d5d9a4eb5ceea9b6b3ad43">More...</a><br /></td></tr>
<tr class="separator:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58">inner_size_helper</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a85557b284f443993530894acbb158b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="#a85557b284f443993530894acbb158b58">More...</a><br /></td></tr>
<tr class="separator:a85557b284f443993530894acbb158b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a227f69a3e3e5de0854bac8e8f2ec6cee">inner_size_helper</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="#a227f69a3e3e5de0854bac8e8f2ec6cee">More...</a><br /></td></tr>
<tr class="separator:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!is_contiguous_tensor&lt; T1 &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a">inner_size</a> (const T1 &amp;tensor1, const T2 &amp;)</td></tr>
<tr class="memdesc:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="#a91ec4c7e7bd4d19b11f0674903ce630a">More...</a><br /></td></tr>
<tr class="separator:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a4b57f060bc5b930d00c088dc270cf15b">inner_size</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a4b57f060bc5b930d00c088dc270cf15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="#a4b57f060bc5b930d00c088dc270cf15b">More...</a><br /></td></tr>
<tr class="separator:a4b57f060bc5b930d00c088dc270cf15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b25c9db0387e3327718de2cbc9112c6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6">empty</a> ()</td></tr>
<tr class="memdesc:a2b25c9db0387e3327718de2cbc9112c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors in an empty list.  <a href="#a2b25c9db0387e3327718de2cbc9112c6">More...</a><br /></td></tr>
<tr class="separator:a2b25c9db0387e3327718de2cbc9112c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af285dd25efb111afecb865a496e3a92c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:af285dd25efb111afecb865a496e3a92c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af285dd25efb111afecb865a496e3a92c">empty</a> (const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:af285dd25efb111afecb865a496e3a92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors.  <a href="#af285dd25efb111afecb865a496e3a92c">More...</a><br /></td></tr>
<tr class="separator:af285dd25efb111afecb865a496e3a92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de">make_tile</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:ada724a31400bb94f55097560394438de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for tiles.  <a href="#ada724a31400bb94f55097560394438de">More...</a><br /></td></tr>
<tr class="separator:ada724a31400bb94f55097560394438de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt; Iter1, Iter2, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a58f2092d8f52e938f74173f7ede0b07d">make_tran_it</a> (Iter1 it1, Iter2 it2, Op op)</td></tr>
<tr class="memdesc:a58f2092d8f52e938f74173f7ede0b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Transform iterator factory.  <a href="#a58f2092d8f52e938f74173f7ede0b07d">More...</a><br /></td></tr>
<tr class="separator:a58f2092d8f52e938f74173f7ede0b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Op &gt; </td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt; Iter, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab52e422e441d6c6cd06db1812f784e1c">make_tran_it</a> (Iter it, Op op)</td></tr>
<tr class="memdesc:ab52e422e441d6c6cd06db1812f784e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary Transform iterator factory.  <a href="#ab52e422e441d6c6cd06db1812f784e1c">More...</a><br /></td></tr>
<tr class="separator:ab52e422e441d6c6cd06db1812f784e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d281f943194c67e7b0a491f03d49e02"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5d281f943194c67e7b0a491f03d49e02"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02">size</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:a5d281f943194c67e7b0a491f03d49e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size accessor.  <a href="#a5d281f943194c67e7b0a491f03d49e02">More...</a><br /></td></tr>
<tr class="separator:a5d281f943194c67e7b0a491f03d49e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3432456d26bf2a1704062cb243f71b5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae3432456d26bf2a1704062cb243f71b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae3432456d26bf2a1704062cb243f71b5">size</a> (const std::array&lt; T, N &gt; &amp;)</td></tr>
<tr class="memdesc:ae3432456d26bf2a1704062cb243f71b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size accessor.  <a href="#ae3432456d26bf2a1704062cb243f71b5">More...</a><br /></td></tr>
<tr class="separator:ae3432456d26bf2a1704062cb243f71b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_array&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a19a7aa4c081be027bd2ecc5cd917cd27">size</a> (const T &amp;a) -&gt; decltype(a.size())</td></tr>
<tr class="memdesc:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size accessor.  <a href="#a19a7aa4c081be027bd2ecc5cd917cd27">More...</a><br /></td></tr>
<tr class="separator:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e04235d40c96d96422f30a70ed1201"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9e04235d40c96d96422f30a70ed1201"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad9e04235d40c96d96422f30a70ed1201">data</a> (T &amp;t) -&gt; decltype(t.data())        </td></tr>
<tr class="memdesc:ad9e04235d40c96d96422f30a70ed1201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container data pointer accessor.  <a href="#ad9e04235d40c96d96422f30a70ed1201">More...</a><br /></td></tr>
<tr class="separator:ad9e04235d40c96d96422f30a70ed1201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad803140a90d4444f810296c6066c0351"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad803140a90d4444f810296c6066c0351"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad803140a90d4444f810296c6066c0351">data</a> (const T &amp;t) -&gt; decltype(t.data())        </td></tr>
<tr class="memdesc:ad803140a90d4444f810296c6066c0351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container data pointer accessor.  <a href="#ad803140a90d4444f810296c6066c0351">More...</a><br /></td></tr>
<tr class="separator:ad803140a90d4444f810296c6066c0351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2522fa9dce38df89d59c259234ae97"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:adc2522fa9dce38df89d59c259234ae97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#adc2522fa9dce38df89d59c259234ae97">data</a> (T t)</td></tr>
<tr class="memdesc:adc2522fa9dce38df89d59c259234ae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer data adapter.  <a href="#adc2522fa9dce38df89d59c259234ae97">More...</a><br /></td></tr>
<tr class="separator:adc2522fa9dce38df89d59c259234ae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af4497aea8e7d4da928677e84dbd9a8d2">data</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:af4497aea8e7d4da928677e84dbd9a8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array data pointer accessor.  <a href="#af4497aea8e7d4da928677e84dbd9a8d2">More...</a><br /></td></tr>
<tr class="separator:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9089108f04afecf1a84e407e12f6789b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9089108f04afecf1a84e407e12f6789b"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9089108f04afecf1a84e407e12f6789b">data</a> (const T(&amp;a)[N])</td></tr>
<tr class="memdesc:a9089108f04afecf1a84e407e12f6789b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array data pointer accessor.  <a href="#a9089108f04afecf1a84e407e12f6789b">More...</a><br /></td></tr>
<tr class="separator:a9089108f04afecf1a84e407e12f6789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac74aa9708c3bef3b4f6a349fafcc61dd">data</a> (std::initializer_list&lt; T &gt; &amp;l)</td></tr>
<tr class="memdesc:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list data pointer accessor.  <a href="#ac74aa9708c3bef3b4f6a349fafcc61dd">More...</a><br /></td></tr>
<tr class="separator:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca80e64fd39a776342605ae74915df46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca80e64fd39a776342605ae74915df46"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aca80e64fd39a776342605ae74915df46">data</a> (const std::initializer_list&lt; T &gt; &amp;l)</td></tr>
<tr class="memdesc:aca80e64fd39a776342605ae74915df46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list const data pointer accessor.  <a href="#aca80e64fd39a776342605ae74915df46">More...</a><br /></td></tr>
<tr class="separator:aca80e64fd39a776342605ae74915df46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d">print_array</a> (std::ostream &amp;out, const A &amp;a, const std::size_t n)</td></tr>
<tr class="memdesc:a5cd635d089830705f84e08204967760d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="#a5cd635d089830705f84e08204967760d">More...</a><br /></td></tr>
<tr class="separator:a5cd635d089830705f84e08204967760d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce">print_array</a> (std::ostream &amp;out, const A &amp;a)</td></tr>
<tr class="memdesc:a2c0a678c425372465314f925b87612ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="#a2c0a678c425372465314f925b87612ce">More...</a><br /></td></tr>
<tr class="separator:a2c0a678c425372465314f925b87612ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa26bd55f3154ac62a00c6ff633db1d40">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;val_array)</td></tr>
<tr class="separator:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af97c9bf4ef025af9a6a81c86b49d2fad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#af97c9bf4ef025af9a6a81c86b49d2fad">TiledArray::detail::add_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() + std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00346">346</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0808e462394d3ca16b63a873448283bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a0808e462394d3ca16b63a873448283bd">TiledArray::detail::mult_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() * std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00353">353</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a763e783371e091990055d391dc6d2090"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a763e783371e091990055d391dc6d2090">TiledArray::detail::numeric_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00225">225</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d58e523957afcbcb1a47b8d98ab30d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">TiledArray::detail::param_type</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt;U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00282">282</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a11981ec4cf6f0e145fe51fa42c93ec10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">TiledArray::detail::pmap_t</a> = typedef typename T::pmap_interface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00370">370</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4711b607050b27e4cee4c5fb4b6b880b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a4711b607050b27e4cee4c5fb4b6b880b">TiledArray::detail::policy_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1policy__type.html">policy_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00381">381</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d3c6ec63959b5ed57e480adf45732d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a5d3c6ec63959b5ed57e480adf45732d7">TiledArray::detail::scalar_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00234">234</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3199b02c7815c0d03a919fc87807656a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a3199b02c7815c0d03a919fc87807656a">TiledArray::detail::shape_t</a> = typedef typename T::shape_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00367">367</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="abeb1097bfa2f729cf40656648ed4116a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#abeb1097bfa2f729cf40656648ed4116a">TiledArray::detail::subt_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() - std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00350">350</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="a06e12c23ae1ad65ad65ef54b041abb37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">TiledArray::detail::trange_t</a> = typedef typename T::trange_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00364">364</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9eb317d5215b2beef4f9093ce8f81d96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> -&gt; decltype(tensor.range())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00046">46</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="afd25794432f3ae654ef616a170280af3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a contiguous copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00057">57</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32a7abe197b45ae95a4132fc240ed383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename std::enable_if&lt;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::conj </td>
          <td>(</td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for <code>std::conj</code> </p>
<p>This function disables the call to <code>std::conj</code> for real values to prevent the result from being converted into a complex value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A real scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The real scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p>Definition at line <a class="el" href="complex_8h_source.html#l00044">44</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a381e9dfb596a18e208171ce358fa6f16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE std::complex&lt;R&gt; TiledArray::detail::conj </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; R &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for std::conj. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The complex scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of <code>z</code> </dd></dl>

<p>Definition at line <a class="el" href="complex_8h_source.html#l00054">54</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78aafa383b1b3e69b6e57b6b78c61306"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt;S&gt; TiledArray::detail::conj_op </td>
          <td>(</td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaling complex conjugate operator </dd></dl>

<p>Definition at line <a class="el" href="complex_8h_source.html#l00154">154</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab2c470158b2bbbdb712cbbaf18a55101"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt;void&gt; TiledArray::detail::conj_op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function. </p>
<dl class="section return"><dt>Returns</dt><dd>A complex conjugate operator </dd></dl>

<p>Definition at line <a class="el" href="complex_8h_source.html#l00161">161</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32cb8da29b68c4968447132218416e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_eigen_submatrix_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix to a tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>Array type </td></tr>
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that will be copied </td></tr>
    <tr><td class="paramname">array</td><td>The array that will hold the result </td></tr>
    <tr><td class="paramname">i</td><td>The index of the tile to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00295">295</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe493525138ef355ba76900e56ae8cf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_tensor_to_eigen_submatrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be assigned </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00312">312</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9e04235d40c96d96422f30a70ed1201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(t.data())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A container object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the container, <code>v</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00073">73</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad803140a90d4444f810296c6066c0351"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(t.data())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A container object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the container, <code>v</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00085">85</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc2522fa9dce38df89d59c259234ae97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer data adapter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>t</code> (pass through) </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00095">95</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="af4497aea8e7d4da928677e84dbd9a8d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The c-style array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00103">103</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9089108f04afecf1a84e407e12f6789b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The c-style array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00111">111</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac74aa9708c3bef3b4f6a349fafcc61dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The initializer list element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer list object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the initializer list, <code>l</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00120">120</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca80e64fd39a776342605ae74915df46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list const data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The initializer list element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer list object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the first element of the initializer list, <code>l</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00128">128</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad38f2970e843e56f76822d775d4d52c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TiledArray::detail::dummy_annotation </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>DIM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00037">37</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2b25c9db0387e3327718de2cbc9112c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors in an empty list. </p>
<p>This function is used as the termination step for the recursive <a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. ">empty()</a> function. It also handles the case where there are no tensors in the list. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00326">326</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="af285dd25efb111afecb865a496e3a92c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to test </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensors to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if one or more tensors are empty </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00336">336</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91dc83ca421c400766d0f15bf0652691"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::fuse_dimensions </td>
          <td>(</td>
          <td class="paramtype">SizeType *restrict const&#160;</td>
          <td class="paramname"><em>fused_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType *restrict const&#160;</td>
          <td class="paramname"><em>fused_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeType *restrict const&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fused dimensions for permutation. </p>
<p>This function will compute the fused dimensions of a tensor for use in permutation algorithms. The idea is to partition the stride 1 dimensions in both the input and output tensor, which yields a forth-order tensor (second- and third-order tensors have size of 1 and stride of 0 in the unused dimensions). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeType</td><td>An unsigned integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_size</td><td>An array for the fused size output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_weight</td><td>An array for the fused weight output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>An array that holds the unfused size information of the argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to the argument tensor(s). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permute_8h_source.html#l00051">51</a> of file <a class="el" href="permute_8h_source.html">permute.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91ec4c7e7bd4d19b11f0674903ce630a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!is_contiguous_tensor&lt; T1 &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest common, contiguous inner-dimension size of the two tensors. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00265">265</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b57f060bc5b930d00c088dc270cf15b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00315">315</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a85557b284f443993530894acbb158b58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00196">196</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a227f69a3e3e5de0854bac8e8f2ec6cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size of the two tensors. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00227">227</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab349de6abb99d242fdfa23318f28b407"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor operations with contiguous data. </p>
<p>In-place tensor of tensors operations with non-contiguous data.</p>
<p>In-place tensor operations with non-contiguous data.</p>
<p>In-place tensor of tensors operations with contiguous data.</p>
<p>This function sets the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00101">101</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="acea82008dbcee62101a2865a602852cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor permutation operations with contiguous data. </p>
<p>In-place tensor of tensors permutation operations with contiguous data.</p>
<p>This function sets the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type, <span class="keyword">const</span> Ts::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(TR::value_type*, <span class="keyword">const</span> TR::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type::value_type, <span class="keyword">const</span> Ts::value_type::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(TR::value_type::value_type*, <span class="keyword">const</span> TR::value_type::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00163">163</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b9a43dfee2749874d4677ea89ab4188"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of tensors are congruent. </p>
<p>Test that the ranges of a pair of shifted tensors are congruent.</p>
<p>This function tests that the rank, lower bound, and upper bound of <code>tensor1</code> is equal to that of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>.</dd></dl>
<p>This function tests that the extents of the two tensors are equal. One or both of the tensors may be shifted. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00074">74</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa35b616db0b6d4da11b862de9570fb93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of permuted tensors are congruent. </p>
<p>This function tests that the rank, lower bound, and upper bound of <code>tensor1</code> is equal to that of the permuted range of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00092">92</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa49fdad6dffe4694cd2f6568461a409c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for congruent range objects with a shifted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lower and upper bounds of the the left- and right-hand tensor ranges are equal, otherwise <code>false</code> </dd></dl>

<p>Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00122">122</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d75a0a0d43e9a5d8beec072cdbe678c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. ">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00131">131</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a938eb07a4afc6e9ed4c238b24a504074"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> and <code>tensors</code>... </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all permuted tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00147">147</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d01c42f84f360ae79da4a0c8e5b84a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. ">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00164">164</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1762b34b3d5d9a4eb5ceea9b6b3ad43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00179">179</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada724a31400bb94f55097560394438de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt;T&gt; TiledArray::detail::make_tile </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for tiles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that wraps a copy of t. </dd></dl>

<p>Definition at line <a class="el" href="tile_8h_source.html#l00256">256</a> of file <a class="el" href="tile_8h_source.html">tile.h</a>.</p>

</div>
</div>
<a class="anchor" id="a58f2092d8f52e938f74173f7ede0b07d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt;Iter1, Iter2, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>it2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter1</td><td>First iterator type </td></tr>
    <tr><td class="paramname">Iter2</td><td>Second iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it1</td><td>First iterator </td></tr>
    <tr><td class="paramname">it2</td><td>Second iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A binary transform iterator </dd></dl>

<p>Definition at line <a class="el" href="transform__iterator_8h_source.html#l00424">424</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab52e422e441d6c6cd06db1812f784e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt;Iter, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>The iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unary transform iterator </dd></dl>

<p>Definition at line <a class="el" href="transform__iterator_8h_source.html#l00436">436</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="af885da1706c23576a28eb38b7afab176"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename std::enable_if&lt;!is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::norm </td>
          <td>(</td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for <code>std::norm</code> </p>
<p>This function disables the call to <code>std::conj</code> for real values to prevent the result from being converted into a complex value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A real scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The real scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p>Definition at line <a class="el" href="complex_8h_source.html#l00067">67</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="af182bb984874298c8351edad6f03517c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::norm </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; R &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the norm of a complex number <code>z</code> </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\rm norm}(z) = zz^* = {\rm Re}(z)^2 + {\rm Im}(z)^2 \]" src="form_87.png"/>
</p>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The complex scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of <code>z</code> </dd></dl>

<p>Definition at line <a class="el" href="complex_8h_source.html#l00080">80</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3699581fa58aa15f3376c5e6f66f68b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Compares the iterators for inequality. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the the value or container are not equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p>Definition at line <a class="el" href="range__iterator_8h_source.html#l00173">173</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47735f4cdfcb24330a02fe4d9e68b8e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise and operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The a intersection of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00615">615</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e0b7cc0cdac97544b2f0511894b4e55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value) * op.factor())
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00167">167</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b6134f3cf8937e7fea6bc822a1b8254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00173">173</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="abde746dca4328f6cc7927e04716afa7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(-<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00179">179</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d2cdb4243dea691e0c8a4471c561340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; L &gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value) * op.factor())
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00186">186</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f5c814e34b5fb11e9ada74a4002233b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00192">192</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa7d5be76f71a2d3a280b20faf92e5fa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(-<a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">TiledArray::detail::conj</a>(value))
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00198">198</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="af085e2abd40acbf24fbc80033634097b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="size__array_8h_source.html#l00432">432</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="acea2c5a93d37330153912da87c7c3877"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R , typename std::enable_if&lt;!std::is_void&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00206">206</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa443b57aebf3d340cc65deeeb00c2073"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00213">213</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab4bd519fc858458a6bf061c1ef2ef5b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="complex_8h_source.html#l00220">220</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7179e9c73eed3c5738bf4d0c5ebd068d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="size__array_8h_source.html#l00439">439</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa26bd55f3154ac62a00c6ff633db1d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="val__array_8h_source.html#l00453">453</a> of file <a class="el" href="val__array_8h_source.html">val_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf888c0b992f597156737f71e2bc6d32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>bitset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00646">646</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a48b1ec146fbd546954d72262124a5b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Compares the iterators for equality. They must reference the same range object to be considered equal. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the the value and container are equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p>Definition at line <a class="el" href="range__iterator_8h_source.html#l00156">156</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c12507ffe191d9e79b32f6687ec46b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise xor operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00640">640</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d0266e20b12eefced1cde7a01d4cdcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise or operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00627">627</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="abccc13338ac000c35d064a2b147b52f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename Result , typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a permuted tensor copy. </p>
<p>The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type input_op(<span class="keyword">const</span> Arg0::value_type, <span class="keyword">const</span> Args::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> output_op(Result::value_type*, <span class="keyword">const</span> Result::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">Result</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Arg0</td><td>The first tensor argument type </td></tr>
    <tr><td class="paramname">Args</td><td>The the remaining tensor argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramname">args</td><td>The data pointers of the tensors to be permuted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the copy </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permute_8h_source.html#l00122">122</a> of file <a class="el" href="permute_8h_source.html">permute.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ecba5efe7b319458a9f16df0563472b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Perm , typename Arg , typename Result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute_array </td>
          <td>(</td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>The permutation type </td></tr>
    <tr><td class="paramname">Arg</td><td>The input array type </td></tr>
    <tr><td class="paramname">Result</td><td>The output array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The input array to be permuted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The output array that will hold the permuted array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permutation_8h_source.html#l00057">57</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5cd635d089830705f84e08204967760d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00137">137</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c0a678c425372465314f925b87612ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00153">153</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d281f943194c67e7b0a491f03d49e02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of c-stype array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00047">47</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae3432456d26bf2a1704062cb243f71b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of c-stype array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00055">55</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19a7aa4c081be027bd2ecc5cd917cd27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_array&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; decltype(a.size()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of array <code>a</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00064">64</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1d6fcb450ef829c3ad4e8e1db5be514a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00593">593</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad0cc592bab4bc45fd24ad38ce5805d38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with contiguous tensor arguments. </p>
<p>Initialize tensor of tensors with contiguous tensor arguments.</p>
<p>This function initializes the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00304">304</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a474df5f74ea75c66470f333f78dad3d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with permuted tensor arguments. </p>
<p>Initialize tensor of tensors with permuted tensor arguments.</p>
<p>This function initializes the elements of <code>tensor1</code> with the result of <code>op</code>(tensor1[i], tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>result</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to tensor2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00361">361</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a843205677d75eda1fcd81b50f9042b84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value                                                           &amp;&amp;!is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with one or more non-contiguous tensor arguments. </p>
<p>This function initializes the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tensor1</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00429">429</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac17e850985b5c94dc082d40978d0e22c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> operations with contiguous data. </p>
<p>This function sets the elements of the result tensor with <code>op</code>(tensor1[i], tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>The element-wise operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00056">56</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a968a88eff54f4dc3105f31c57a5e06ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value)                                       &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> permutation operations with contiguous data. </p>
<p>This function sets the elements of the result tensor with <code>op</code>(tensor1[i],tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>The element-wise operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation that is used to compute the result value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00078">78</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a72c95c206465e8ff50da0a55ab3878a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if&lt; is_numeric&lt; Scalar &gt;::value &amp;&amp;is_tensor&lt; T1, Ts... &gt;::value                                           &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar TiledArray::detail::tensor_reduce </td>
          <td>(</td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> reduction operation for contiguous tensors. </p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> of tensors reduction operation for non-contiguous tensors.</p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> reduction operation for non-contiguous tensors.</p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> of tensor reduction operation for contiguous tensors.</p>
<p>Perform an element-wise reduction of the tensors. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s)</dd></dl>
<p>Perform an element-wise reduction of the tensors. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The result join operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s) </dd></dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00511">511</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li><li class="navelem"><a class="el" href="namespace_tiled_array_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Fri Apr 29 2016 12:03:07 for TiledArray by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
