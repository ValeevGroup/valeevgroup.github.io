<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>TiledArray: TiledArray::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TiledArray
   &#160;<span id="projectnumber">0.5.0-alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_tiled_array_1_1detail.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray::detail Namespace Reference<div class="ingroups"><a class="el" href="group___tile_interface.html">Tile interface for user defined tensor types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper.html">ArgumentHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01_future_3_01_t_01_4_01_4.html">ArgumentHelper&lt; Future&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01std_1_1pair_3_01_future_3_01_t_01_4_00_01_future_3_01_u_01_4_01_4_01_4.html">ArgumentHelper&lt; std::pair&lt; Future&lt; T &gt;, Future&lt; U &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html">ArrayEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator for <code><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">TiledArray::Array</a></code> objects.  <a href="class_tiled_array_1_1detail_1_1_array_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_iiterator.html">ArrayIiterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed tensor iterator.  <a href="class_tiled_array_1_1detail_1_1_array_iiterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_impl.html">ArrayImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_array_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html">BinaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary, distributed tensor evaluator.  <a href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size bitset.  <a href="class_tiled_array_1_1detail_1_1_bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_blocked_pmap.html">BlockedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A blocked process map.  <a href="class_tiled_array_1_1detail_1_1_blocked_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html">CyclicPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map processes using a 2D cyclic decomposition.  <a href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval.html">DistEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> expression object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html">DistEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator implementation object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_distributed_storage.html">DistributedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed storage container.  <a href="class_tiled_array_1_1detail_1_1_distributed_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_hash_pmap.html">HashPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashed process map.  <a href="class_tiled_array_1_1detail_1_1_hash_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile.html">is_array_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect tiles used by <code><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html" title="Distributed evaluator for TiledArray::Array objects. ">ArrayEvalImpl</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__array__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile_3_01_tiled_array_1_1detail_1_1_lazy_array_tile_3_01_t_00_01_op_01_4_01_4.html">is_array_tile&lt; TiledArray::detail::LazyArrayTile&lt; T, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_complex&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor.html">is_contiguous_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t_01_4.html">is_contiguous_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_contiguous_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_4.html">is_contiguous_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper.html">is_contiguous_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_contiguous_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_contiguous_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_interface_3_01_t_00_01_range_01_4_01_4.html">is_contiguous_tensor_helper&lt; TensorInterface&lt; T, Range &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__float__or__complex.html">is_float_or_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to detect floating point and complex types.  <a href="struct_tiled_array_1_1detail_1_1is__float__or__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">is_integral_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper.html">is_integral_list_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_01_t_00_01_ts_8_8_8_01_4.html">is_integral_list_helper&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_4.html">is_integral_list_helper&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5_00_01void_01_4.html">is_iterator&lt; const T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; const T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5_00_01void_01_4.html">is_iterator&lt; T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_00_01typename_01std_1_1enable__if_3_01is__tyf33ee9a886ca9d82cca7639bd5722af8.html">is_iterator&lt; T, typename std::enable_if&lt; is_type&lt; typename T::iterator_category &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__lazy__tile.html">is_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect lazy evaluation tiles.  <a href="struct_tiled_array_1_1detail_1_1is__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html">is_non_array_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect a lazy evaluation tile that are not a <code><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html" title="Lazy tile for on-the-fly evaluation of array tiles. ">LazyArrayTile</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric.html">is_numeric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01_conjugate_3_01_t_01_4_01_4.html">is_numeric&lt; Conjugate&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01double_01_4.html">is_numeric&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01float_01_4.html">is_numeric&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01int_01_4.html">is_numeric&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01long_01int_01_4.html">is_numeric&lt; long int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01short_01int_01_4.html">is_numeric&lt; short int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_numeric&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01unsigned_01int_01_4.html">is_numeric&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01unsigned_01long_01int_01_4.html">is_numeric&lt; unsigned long int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__output__iterator.html">is_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__random__iterator.html">is_random_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted.html">is_shifted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t_01_4.html">is_shifted&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_shifted&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_4.html">is_shifted&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper.html">is_shifted_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_shifted_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor.html">is_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t_01_4.html">is_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_4.html">is_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper.html">is_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01const_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; const T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_interface_3_01_t_00_01_r_01_4_01_4.html">is_tensor_helper&lt; TensorInterface&lt; T, R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor.html">is_tensor_of_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t_01_4.html">is_tensor_of_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor_of_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_4.html">is_tensor_of_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper.html">is_tensor_of_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_of_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_of_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_interface_3_01_t_00_01_range_type_01_4_01_4.html">is_tensor_of_tensor_helper&lt; TensorInterface&lt; T, RangeType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__type.html">is_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html">LazyArrayTile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy tile for on-the-fly evaluation of array tiles.  <a href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1non__iterator__tag.html">non_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01is__numeric_33ed69f6b1e4f90bd5899462119a67d06.html">param&lt; T, typename std::enable_if&lt; is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__po026251cf0f0a4c03557bdf8a6565693e.html">param&lt; T, typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__rece401fa407cc0a1ee19af25268964063.html">param&lt; T, typename std::enable_if&lt; std::is_reference&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_perm_index.html">PermIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that permutes ordinal indices.  <a href="class_tiled_array_1_1detail_1_1_perm_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_proc_grid.html">ProcGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D processor grid.  <a href="class_tiled_array_1_1detail_1_1_proc_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinate index iterate.  <a href="class_tiled_array_1_1detail_1_1_range_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html">ReducePairOpWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper that to convert a pair-wise reduction into a standard reduction.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html">ReducePairTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce pair task.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_task.html">ReduceTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce task.  <a href="class_tiled_array_1_1detail_1_1_reduce_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1remove__cvr.html">remove_cvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove const, volatile, and reference qualifiers.  <a href="struct_tiled_array_1_1detail_1_1remove__cvr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicated_pmap.html">ReplicatedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Replicated process map.  <a href="class_tiled_array_1_1detail_1_1_replicated_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicator.html">Replicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate a <code><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a></code> object.  <a href="class_tiled_array_1_1detail_1_1_replicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for extracting the scalar numeric type of tensors and arrays.  <a href="struct_tiled_array_1_1detail_1_1scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_eigen_1_1_array_3_01_t_00_01_rows_00_01_cols_02d8e809d1ed49fdab0e8d111578e0440.html">scalar_type&lt; Eigen::Array&lt; T, Rows, Cols, Opts, MaxRows, MaxCols &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_eigen_1_1_map_3_01_plain_object_type_00_01_mapb11f76b3aeea39791efc5319e329e6cd.html">scalar_type&lt; Eigen::Map&lt; PlainObjectType, MapOptions, StrideType &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_eigen_1_1_matrix_3_01_t_00_01_rows_00_01_cols_da9a4c3b75d59b0cdcc54069c9d98bf1.html">scalar_type&lt; Eigen::Matrix&lt; T, Rows, Cols, Opts, MaxRows, MaxCols &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__nu417ffaf7a4e9a72afff56ede7e77f14c.html">scalar_type&lt; T, typename std::enable_if&lt; is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__ty957fb57f824e2a4464b83ed5c4b43ec2.html">scalar_type&lt; T, typename std::enable_if&lt; is_type&lt; typename T::value_type &gt;::value                                                           &amp;&amp;!is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_tile_3_01_t_01_4_00_01void_01_4.html">scalar_type&lt; Tile&lt; T &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift wrapper class.  <a href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> wrapper.  <a href="class_tiled_array_1_1detail_1_1_size_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_summa.html">Summa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed contraction evaluator implementation.  <a href="class_tiled_array_1_1detail_1_1_summa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_const_reference.html">TensorConstReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_impl.html">TensorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_tensor_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> interface for external data.  <a href="class_tiled_array_1_1detail_1_1_tensor_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_reference.html">TensorReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html">UnaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> that is composed from an argument tensor.  <a href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value array.  <a href="class_tiled_array_1_1detail_1_1_val_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adaab9e7f8fb937e66e6e550cb8087576"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaab9e7f8fb937e66e6e550cb8087576"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#adaab9e7f8fb937e66e6e550cb8087576">result_of_t</a> = typename std::result_of&lt; T &gt;::type</td></tr>
<tr class="separator:adaab9e7f8fb937e66e6e550cb8087576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">param_type</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt; U &gt;::type</td></tr>
<tr class="separator:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad38f2970e843e56f76822d775d4d52c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9">dummy_annotation</a> (unsigned int DIM)</td></tr>
<tr class="separator:ad38f2970e843e56f76822d775d4d52c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1d6fcb450ef829c3ad4e8e1db5be514a">swap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b0, <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b1)</td></tr>
<tr class="separator:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a47735f4cdfcb24330a02fe4d9e68b8e7">operator&amp;</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and operator of bitset.  <a href="#a47735f4cdfcb24330a02fe4d9e68b8e7">More...</a><br /></td></tr>
<tr class="separator:a47735f4cdfcb24330a02fe4d9e68b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d0266e20b12eefced1cde7a01d4cdcd">operator|</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or operator of bitset.  <a href="#a0d0266e20b12eefced1cde7a01d4cdcd">More...</a><br /></td></tr>
<tr class="separator:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9c12507ffe191d9e79b32f6687ec46b1">operator^</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a9c12507ffe191d9e79b32f6687ec46b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor operator of bitset.  <a href="#a9c12507ffe191d9e79b32f6687ec46b1">More...</a><br /></td></tr>
<tr class="separator:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aaf888c0b992f597156737f71e2bc6d32">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;bitset)</td></tr>
<tr class="separator:aaf888c0b992f597156737f71e2bc6d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb8da29b68c4968447132218416e21"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Derived &gt; </td></tr>
<tr class="memitem:a32cb8da29b68c4968447132218416e21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a32cb8da29b68c4968447132218416e21">counted_eigen_submatrix_to_tensor</a> (const Eigen::MatrixBase&lt; Derived &gt; *matrix, A &amp;array, const typename A::size_type i, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:a32cb8da29b68c4968447132218416e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix to a tensor.  <a href="#a32cb8da29b68c4968447132218416e21">More...</a><br /></td></tr>
<tr class="separator:a32cb8da29b68c4968447132218416e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename T &gt; </td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2">counted_tensor_to_eigen_submatrix</a> (const T &amp;tensor, Eigen::MatrixBase&lt; Derived &gt; *matrix, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:afe493525138ef355ba76900e56ae8cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix.  <a href="#afe493525138ef355ba76900e56ae8cf2">More...</a><br /></td></tr>
<tr class="separator:afe493525138ef355ba76900e56ae8cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecba5efe7b319458a9f16df0563472b"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename Arg , typename Result &gt; </td></tr>
<tr class="memitem:a9ecba5efe7b319458a9f16df0563472b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b">permute_array</a> (const Perm &amp;perm, const Arg &amp;arg, Result &amp;result)</td></tr>
<tr class="memdesc:a9ecba5efe7b319458a9f16df0563472b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of an array.  <a href="#a9ecba5efe7b319458a9f16df0563472b">More...</a><br /></td></tr>
<tr class="separator:a9ecba5efe7b319458a9f16df0563472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a48b1ec146fbd546954d72262124a5b74">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a48b1ec146fbd546954d72262124a5b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a48b1ec146fbd546954d72262124a5b74">More...</a><br /></td></tr>
<tr class="separator:a48b1ec146fbd546954d72262124a5b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3699581fa58aa15f3376c5e6f66f68b3">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a3699581fa58aa15f3376c5e6f66f68b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a3699581fa58aa15f3376c5e6f66f68b3">More...</a><br /></td></tr>
<tr class="separator:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af085e2abd40acbf24fbc80033634097b">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;orig)</td></tr>
<tr class="separator:af085e2abd40acbf24fbc80033634097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a7179e9c73eed3c5738bf4d0c5ebd068d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;size_array)</td></tr>
<tr class="separator:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17e850985b5c94dc082d40978d0e22c"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac17e850985b5c94dc082d40978d0e22c"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac17e850985b5c94dc082d40978d0e22c">tensor_op</a> (Op &amp;&amp;op, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:ac17e850985b5c94dc082d40978d0e22c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> operations with contiguous data.  <a href="#ac17e850985b5c94dc082d40978d0e22c">More...</a><br /></td></tr>
<tr class="separator:ac17e850985b5c94dc082d40978d0e22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968a88eff54f4dc3105f31c57a5e06ac"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value)                                       &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a968a88eff54f4dc3105f31c57a5e06ac"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a968a88eff54f4dc3105f31c57a5e06ac">tensor_op</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a968a88eff54f4dc3105f31c57a5e06ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> permutation operations with contiguous data.  <a href="#a968a88eff54f4dc3105f31c57a5e06ac">More...</a><br /></td></tr>
<tr class="separator:a968a88eff54f4dc3105f31c57a5e06ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab349de6abb99d242fdfa23318f28b407"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab349de6abb99d242fdfa23318f28b407"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab349de6abb99d242fdfa23318f28b407">inplace_tensor_op</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:ab349de6abb99d242fdfa23318f28b407"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor operations with contiguous data.  <a href="#ab349de6abb99d242fdfa23318f28b407">More...</a><br /></td></tr>
<tr class="separator:ab349de6abb99d242fdfa23318f28b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea82008dbcee62101a2865a602852cb"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acea82008dbcee62101a2865a602852cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#acea82008dbcee62101a2865a602852cb">inplace_tensor_op</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:acea82008dbcee62101a2865a602852cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor permutation operations with contiguous data.  <a href="#acea82008dbcee62101a2865a602852cb">More...</a><br /></td></tr>
<tr class="separator:acea82008dbcee62101a2865a602852cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad0cc592bab4bc45fd24ad38ce5805d38">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with contiguous tensor arguments.  <a href="#ad0cc592bab4bc45fd24ad38ce5805d38">More...</a><br /></td></tr>
<tr class="separator:ad0cc592bab4bc45fd24ad38ce5805d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474df5f74ea75c66470f333f78dad3d5"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a474df5f74ea75c66470f333f78dad3d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a474df5f74ea75c66470f333f78dad3d5">tensor_init</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a474df5f74ea75c66470f333f78dad3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with permuted tensor arguments.  <a href="#a474df5f74ea75c66470f333f78dad3d5">More...</a><br /></td></tr>
<tr class="separator:a474df5f74ea75c66470f333f78dad3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843205677d75eda1fcd81b50f9042b84"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value                                                           &amp;&amp;!is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a843205677d75eda1fcd81b50f9042b84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a843205677d75eda1fcd81b50f9042b84">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a843205677d75eda1fcd81b50f9042b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with one or more non-contiguous tensor arguments.  <a href="#a843205677d75eda1fcd81b50f9042b84">More...</a><br /></td></tr>
<tr class="separator:a843205677d75eda1fcd81b50f9042b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c476e766ff095a095ff4e5508684975"><td class="memTemplParams" colspan="2">template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if&lt; is_numeric&lt; Scalar &gt;::value &amp;&amp;is_tensor&lt; T1, Ts... &gt;::value                                           &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2c476e766ff095a095ff4e5508684975"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2c476e766ff095a095ff4e5508684975">tensor_reduce</a> (ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;, Scalar identity, const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a2c476e766ff095a095ff4e5508684975"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> reduction operation for contiguous tensors.  <a href="#a2c476e766ff095a095ff4e5508684975">More...</a><br /></td></tr>
<tr class="separator:a2c476e766ff095a095ff4e5508684975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dc83ca421c400766d0f15bf0652691"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:a91dc83ca421c400766d0f15bf0652691"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a91dc83ca421c400766d0f15bf0652691">fuse_dimensions</a> (SizeType *restrict const fused_size, SizeType *restrict const fused_weight, const SizeType *restrict const <a class="el" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02">size</a>, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a91dc83ca421c400766d0f15bf0652691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fused dimensions for permutation.  <a href="#a91dc83ca421c400766d0f15bf0652691">More...</a><br /></td></tr>
<tr class="separator:a91dc83ca421c400766d0f15bf0652691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccc13338ac000c35d064a2b147b52f6"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename Result , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:abccc13338ac000c35d064a2b147b52f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abccc13338ac000c35d064a2b147b52f6">permute</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, Result &amp;result, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const Arg0 &amp;arg0, const Args &amp;...args)</td></tr>
<tr class="memdesc:abccc13338ac000c35d064a2b147b52f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a permuted tensor copy.  <a href="#abccc13338ac000c35d064a2b147b52f6">More...</a><br /></td></tr>
<tr class="separator:abccc13338ac000c35d064a2b147b52f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c">is_range_congruent</a> (const Left &amp;left, const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:aa49fdad6dffe4694cd2f6568461a409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for congruent range objects with a shifted tensor.  <a href="#aa49fdad6dffe4694cd2f6568461a409c">More...</a><br /></td></tr>
<tr class="separator:aa49fdad6dffe4694cd2f6568461a409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb317d5215b2beef4f9093ce8f81d96"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9eb317d5215b2beef4f9093ce8f81d96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9eb317d5215b2beef4f9093ce8f81d96">clone_range</a> (const T &amp;tensor) -&gt; decltype(tensor.range())        </td></tr>
<tr class="memdesc:a9eb317d5215b2beef4f9093ce8f81d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the range of the tensor.  <a href="#a9eb317d5215b2beef4f9093ce8f81d96">More...</a><br /></td></tr>
<tr class="separator:a9eb317d5215b2beef4f9093ce8f81d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afd25794432f3ae654ef616a170280af3">clone_range</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:afd25794432f3ae654ef616a170280af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a contiguous copy of the range of the tensor.  <a href="#afd25794432f3ae654ef616a170280af3">More...</a><br /></td></tr>
<tr class="separator:afd25794432f3ae654ef616a170280af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0b9a43dfee2749874d4677ea89ab4188">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a0b9a43dfee2749874d4677ea89ab4188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of tensors are congruent.  <a href="#a0b9a43dfee2749874d4677ea89ab4188">More...</a><br /></td></tr>
<tr class="separator:a0b9a43dfee2749874d4677ea89ab4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa35b616db0b6d4da11b862de9570fb93">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aa35b616db0b6d4da11b862de9570fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of permuted tensors are congruent.  <a href="#aa35b616db0b6d4da11b862de9570fb93">More...</a><br /></td></tr>
<tr class="separator:aa35b616db0b6d4da11b862de9570fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T &amp;tensor)</td></tr>
<tr class="memdesc:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted tensor is congruent with itself.  <a href="#a0d75a0a0d43e9a5d8beec072cdbe678c">More...</a><br /></td></tr>
<tr class="separator:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938eb07a4afc6e9ed4c238b24a504074"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a938eb07a4afc6e9ed4c238b24a504074"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a938eb07a4afc6e9ed4c238b24a504074">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:a938eb07a4afc6e9ed4c238b24a504074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted set of tensors are congruent.  <a href="#a938eb07a4afc6e9ed4c238b24a504074">More...</a><br /></td></tr>
<tr class="separator:a938eb07a4afc6e9ed4c238b24a504074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8d01c42f84f360ae79da4a0c8e5b84a2">is_range_set_congruent</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a tensor is congruent with itself.  <a href="#a8d01c42f84f360ae79da4a0c8e5b84a2">More...</a><br /></td></tr>
<tr class="separator:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af1762b34b3d5d9a4eb5ceea9b6b3ad43">is_range_set_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a set of tensors are congruent.  <a href="#af1762b34b3d5d9a4eb5ceea9b6b3ad43">More...</a><br /></td></tr>
<tr class="separator:af1762b34b3d5d9a4eb5ceea9b6b3ad43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58">inner_size_helper</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a85557b284f443993530894acbb158b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="#a85557b284f443993530894acbb158b58">More...</a><br /></td></tr>
<tr class="separator:a85557b284f443993530894acbb158b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a227f69a3e3e5de0854bac8e8f2ec6cee">inner_size_helper</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="#a227f69a3e3e5de0854bac8e8f2ec6cee">More...</a><br /></td></tr>
<tr class="separator:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!is_contiguous_tensor&lt; T1 &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a">inner_size</a> (const T1 &amp;tensor1, const T2 &amp;)</td></tr>
<tr class="memdesc:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="#a91ec4c7e7bd4d19b11f0674903ce630a">More...</a><br /></td></tr>
<tr class="separator:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a4b57f060bc5b930d00c088dc270cf15b">inner_size</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a4b57f060bc5b930d00c088dc270cf15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="#a4b57f060bc5b930d00c088dc270cf15b">More...</a><br /></td></tr>
<tr class="separator:a4b57f060bc5b930d00c088dc270cf15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b25c9db0387e3327718de2cbc9112c6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6">empty</a> ()</td></tr>
<tr class="memdesc:a2b25c9db0387e3327718de2cbc9112c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors in an empty list.  <a href="#a2b25c9db0387e3327718de2cbc9112c6">More...</a><br /></td></tr>
<tr class="separator:a2b25c9db0387e3327718de2cbc9112c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af285dd25efb111afecb865a496e3a92c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:af285dd25efb111afecb865a496e3a92c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af285dd25efb111afecb865a496e3a92c">empty</a> (const T1 &amp;tensor1, const Ts &amp;...tensors)</td></tr>
<tr class="memdesc:af285dd25efb111afecb865a496e3a92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors.  <a href="#af285dd25efb111afecb865a496e3a92c">More...</a><br /></td></tr>
<tr class="separator:af285dd25efb111afecb865a496e3a92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de">make_tile</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:ada724a31400bb94f55097560394438de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for tiles.  <a href="#ada724a31400bb94f55097560394438de">More...</a><br /></td></tr>
<tr class="separator:ada724a31400bb94f55097560394438de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt; Iter1, Iter2, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a58f2092d8f52e938f74173f7ede0b07d">make_tran_it</a> (Iter1 it1, Iter2 it2, Op op)</td></tr>
<tr class="memdesc:a58f2092d8f52e938f74173f7ede0b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Transform iterator factory.  <a href="#a58f2092d8f52e938f74173f7ede0b07d">More...</a><br /></td></tr>
<tr class="separator:a58f2092d8f52e938f74173f7ede0b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Op &gt; </td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt; Iter, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab52e422e441d6c6cd06db1812f784e1c">make_tran_it</a> (Iter it, Op op)</td></tr>
<tr class="memdesc:ab52e422e441d6c6cd06db1812f784e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary Transform iterator factory.  <a href="#ab52e422e441d6c6cd06db1812f784e1c">More...</a><br /></td></tr>
<tr class="separator:ab52e422e441d6c6cd06db1812f784e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d281f943194c67e7b0a491f03d49e02"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5d281f943194c67e7b0a491f03d49e02"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02">size</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:a5d281f943194c67e7b0a491f03d49e02"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> size accessor.  <a href="#a5d281f943194c67e7b0a491f03d49e02">More...</a><br /></td></tr>
<tr class="separator:a5d281f943194c67e7b0a491f03d49e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3432456d26bf2a1704062cb243f71b5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae3432456d26bf2a1704062cb243f71b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae3432456d26bf2a1704062cb243f71b5">size</a> (const std::array&lt; T, N &gt; &amp;)</td></tr>
<tr class="memdesc:ae3432456d26bf2a1704062cb243f71b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> size accessor.  <a href="#ae3432456d26bf2a1704062cb243f71b5">More...</a><br /></td></tr>
<tr class="separator:ae3432456d26bf2a1704062cb243f71b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_array&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a19a7aa4c081be027bd2ecc5cd917cd27">size</a> (const T &amp;a) -&gt; decltype(a.size())</td></tr>
<tr class="memdesc:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> size accessor.  <a href="#a19a7aa4c081be027bd2ecc5cd917cd27">More...</a><br /></td></tr>
<tr class="separator:a19a7aa4c081be027bd2ecc5cd917cd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e04235d40c96d96422f30a70ed1201"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9e04235d40c96d96422f30a70ed1201"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad9e04235d40c96d96422f30a70ed1201">data</a> (T &amp;t) -&gt; decltype(t.data())        </td></tr>
<tr class="memdesc:ad9e04235d40c96d96422f30a70ed1201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container data pointer accessor.  <a href="#ad9e04235d40c96d96422f30a70ed1201">More...</a><br /></td></tr>
<tr class="separator:ad9e04235d40c96d96422f30a70ed1201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad803140a90d4444f810296c6066c0351"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad803140a90d4444f810296c6066c0351"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad803140a90d4444f810296c6066c0351">data</a> (const T &amp;t) -&gt; decltype(t.data())        </td></tr>
<tr class="memdesc:ad803140a90d4444f810296c6066c0351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container data pointer accessor.  <a href="#ad803140a90d4444f810296c6066c0351">More...</a><br /></td></tr>
<tr class="separator:ad803140a90d4444f810296c6066c0351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2522fa9dce38df89d59c259234ae97"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:adc2522fa9dce38df89d59c259234ae97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#adc2522fa9dce38df89d59c259234ae97">data</a> (T t)</td></tr>
<tr class="memdesc:adc2522fa9dce38df89d59c259234ae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer data adapter.  <a href="#adc2522fa9dce38df89d59c259234ae97">More...</a><br /></td></tr>
<tr class="separator:adc2522fa9dce38df89d59c259234ae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af4497aea8e7d4da928677e84dbd9a8d2">data</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:af4497aea8e7d4da928677e84dbd9a8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> data pointer accessor.  <a href="#af4497aea8e7d4da928677e84dbd9a8d2">More...</a><br /></td></tr>
<tr class="separator:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9089108f04afecf1a84e407e12f6789b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9089108f04afecf1a84e407e12f6789b"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9089108f04afecf1a84e407e12f6789b">data</a> (const T(&amp;a)[N])</td></tr>
<tr class="memdesc:a9089108f04afecf1a84e407e12f6789b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> data pointer accessor.  <a href="#a9089108f04afecf1a84e407e12f6789b">More...</a><br /></td></tr>
<tr class="separator:a9089108f04afecf1a84e407e12f6789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac74aa9708c3bef3b4f6a349fafcc61dd">data</a> (std::initializer_list&lt; T &gt; &amp;l)</td></tr>
<tr class="memdesc:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list data pointer accessor.  <a href="#ac74aa9708c3bef3b4f6a349fafcc61dd">More...</a><br /></td></tr>
<tr class="separator:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca80e64fd39a776342605ae74915df46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca80e64fd39a776342605ae74915df46"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aca80e64fd39a776342605ae74915df46">data</a> (const std::initializer_list&lt; T &gt; &amp;l)</td></tr>
<tr class="memdesc:aca80e64fd39a776342605ae74915df46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list const data pointer accessor.  <a href="#aca80e64fd39a776342605ae74915df46">More...</a><br /></td></tr>
<tr class="separator:aca80e64fd39a776342605ae74915df46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d">print_array</a> (std::ostream &amp;out, const A &amp;a, const std::size_t n)</td></tr>
<tr class="memdesc:a5cd635d089830705f84e08204967760d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="#a5cd635d089830705f84e08204967760d">More...</a><br /></td></tr>
<tr class="separator:a5cd635d089830705f84e08204967760d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce">print_array</a> (std::ostream &amp;out, const A &amp;a)</td></tr>
<tr class="memdesc:a2c0a678c425372465314f925b87612ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="#a2c0a678c425372465314f925b87612ce">More...</a><br /></td></tr>
<tr class="separator:a2c0a678c425372465314f925b87612ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa26bd55f3154ac62a00c6ff633db1d40">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;val_array)</td></tr>
<tr class="separator:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a0d58e523957afcbcb1a47b8d98ab30d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">TiledArray::detail::param_type</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt;U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="type__traits_8h_source.html#l00183">183</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a class="anchor" id="adaab9e7f8fb937e66e6e550cb8087576"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#adaab9e7f8fb937e66e6e550cb8087576">TiledArray::detail::result_of_t</a> = typedef typename std::result_of&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__new__tile__type_8h_source.html#l00011">11</a> of file <a class="el" href="to__new__tile__type_8h_source.html">to_new_tile_type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9eb317d5215b2beef4f9093ce8f81d96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> -&gt; decltype(tensor.range())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00046">46</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="afd25794432f3ae654ef616a170280af3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a contiguous copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00057">57</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32cb8da29b68c4968447132218416e21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_eigen_submatrix_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix to a tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> type </td></tr>
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that will be copied </td></tr>
    <tr><td class="paramname">array</td><td>The array that will hold the result </td></tr>
    <tr><td class="paramname">i</td><td>The index of the tile to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00290">290</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="afe493525138ef355ba76900e56ae8cf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_tensor_to_eigen_submatrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be assigned </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00307">307</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9e04235d40c96d96422f30a70ed1201"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(t.data())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A container object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the container, <code>v</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00073">73</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad803140a90d4444f810296c6066c0351"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; decltype(t.data())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A container object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the container, <code>v</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00085">85</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc2522fa9dce38df89d59c259234ae97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer data adapter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>t</code> (pass through) </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00095">95</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="af4497aea8e7d4da928677e84dbd9a8d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The c-style array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00103">103</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9089108f04afecf1a84e407e12f6789b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The c-style array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00111">111</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac74aa9708c3bef3b4f6a349fafcc61dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The initializer list element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer list object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the initializer list, <code>l</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00120">120</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="aca80e64fd39a776342605ae74915df46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list const data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The initializer list element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer list object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the first element of the initializer list, <code>l</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00128">128</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad38f2970e843e56f76822d775d4d52c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TiledArray::detail::dummy_annotation </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>DIM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="utils_8h_source.html#l00036">36</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2b25c9db0387e3327718de2cbc9112c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors in an empty list. </p>
<p>This function is used as the termination step for the recursive <a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. ">empty()</a> function. It also handles the case where there are no tensors in the list. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00326">326</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="af285dd25efb111afecb865a496e3a92c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to test </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensors to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if one or more tensors are empty </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00336">336</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91dc83ca421c400766d0f15bf0652691"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::fuse_dimensions </td>
          <td>(</td>
          <td class="paramtype">SizeType *restrict const&#160;</td>
          <td class="paramname"><em>fused_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType *restrict const&#160;</td>
          <td class="paramname"><em>fused_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeType *restrict const&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fused dimensions for permutation. </p>
<p>This function will compute the fused dimensions of a tensor for use in permutation algorithms. The idea is to partition the stride 1 dimensions in both the input and output tensor, which yields a forth-order tensor (second- and third-order tensors have size of 1 and stride of 0 in the unused dimensions). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeType</td><td>An unsigned integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_size</td><td>An array for the fused size output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_weight</td><td>An array for the fused weight output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>An array that holds the unfused size information of the argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to the argument tensor(s). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permute_8h_source.html#l00051">51</a> of file <a class="el" href="permute_8h_source.html">permute.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91ec4c7e7bd4d19b11f0674903ce630a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!is_contiguous_tensor&lt; T1 &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest common, contiguous inner-dimension size of the two tensors. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00265">265</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b57f060bc5b930d00c088dc270cf15b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00315">315</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a85557b284f443993530894acbb158b58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00196">196</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a227f69a3e3e5de0854bac8e8f2ec6cee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size of the two tensors. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00227">227</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab349de6abb99d242fdfa23318f28b407"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor operations with contiguous data. </p>
<p>In-place tensor of tensors operations with non-contiguous data.</p>
<p>In-place tensor operations with non-contiguous data.</p>
<p>In-place tensor of tensors operations with contiguous data.</p>
<p>This function sets the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00101">101</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="acea82008dbcee62101a2865a602852cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor permutation operations with contiguous data. </p>
<p>In-place tensor of tensors permutation operations with contiguous data.</p>
<p>This function sets the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type, <span class="keyword">const</span> Ts::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(TR::value_type*, <span class="keyword">const</span> TR::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type::value_type, <span class="keyword">const</span> Ts::value_type::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(TR::value_type::value_type*, <span class="keyword">const</span> TR::value_type::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00163">163</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b9a43dfee2749874d4677ea89ab4188"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of tensors are congruent. </p>
<p>Test that the ranges of a pair of shifted tensors are congruent.</p>
<p>This function tests that the rank, lower bound, and upper bound of <code>tensor1</code> is equal to that of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>.</dd></dl>
<p>This function tests that the extents of the two tensors are equal. One or both of the tensors may be shifted. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00074">74</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa35b616db0b6d4da11b862de9570fb93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value                                       ||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of permuted tensors are congruent. </p>
<p>This function tests that the rank, lower bound, and upper bound of <code>tensor1</code> is equal to that of the permuted range of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00092">92</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa49fdad6dffe4694cd2f6568461a409c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for congruent range objects with a shifted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lower and upper bounds of the the left- and right-hand tensor ranges are equal, otherwise <code>false</code> </dd></dl>

<p>Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00122">122</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d75a0a0d43e9a5d8beec072cdbe678c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. ">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00131">131</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a938eb07a4afc6e9ed4c238b24a504074"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> and <code>tensors</code>... </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all permuted tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00147">147</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8d01c42f84f360ae79da4a0c8e5b84a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. ">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00164">164</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1762b34b3d5d9a4eb5ceea9b6b3ad43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00179">179</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada724a31400bb94f55097560394438de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt;T&gt; TiledArray::detail::make_tile </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for tiles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that wraps a copy of t. </dd></dl>

<p>Definition at line <a class="el" href="tile_8h_source.html#l00256">256</a> of file <a class="el" href="tile_8h_source.html">tile.h</a>.</p>

</div>
</div>
<a class="anchor" id="a58f2092d8f52e938f74173f7ede0b07d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt;Iter1, Iter2, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>it2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter1</td><td>First iterator type </td></tr>
    <tr><td class="paramname">Iter2</td><td>Second iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it1</td><td>First iterator </td></tr>
    <tr><td class="paramname">it2</td><td>Second iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A binary transform iterator </dd></dl>

<p>Definition at line <a class="el" href="transform__iterator_8h_source.html#l00424">424</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab52e422e441d6c6cd06db1812f784e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt;Iter, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>The iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unary transform iterator </dd></dl>

<p>Definition at line <a class="el" href="transform__iterator_8h_source.html#l00436">436</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3699581fa58aa15f3376c5e6f66f68b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Compares the iterators for inequality. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the the value or container are not equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p>Definition at line <a class="el" href="range__iterator_8h_source.html#l00173">173</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47735f4cdfcb24330a02fe4d9e68b8e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise and operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The a intersection of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00615">615</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="af085e2abd40acbf24fbc80033634097b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="size__array_8h_source.html#l00430">430</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7179e9c73eed3c5738bf4d0c5ebd068d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="size__array_8h_source.html#l00437">437</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa26bd55f3154ac62a00c6ff633db1d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="val__array_8h_source.html#l00453">453</a> of file <a class="el" href="val__array_8h_source.html">val_array.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaf888c0b992f597156737f71e2bc6d32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>bitset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00646">646</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a48b1ec146fbd546954d72262124a5b74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Compares the iterators for equality. They must reference the same range object to be considered equal. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the the value and container are equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p>Definition at line <a class="el" href="range__iterator_8h_source.html#l00156">156</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c12507ffe191d9e79b32f6687ec46b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise xor operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00640">640</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d0266e20b12eefced1cde7a01d4cdcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise or operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00627">627</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="abccc13338ac000c35d064a2b147b52f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename Result , typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a permuted tensor copy. </p>
<p>The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type input_op(<span class="keyword">const</span> Arg0::value_type, <span class="keyword">const</span> Args::value_type...)</div>
</div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> output_op(Result::value_type*, <span class="keyword">const</span> Result::value_type)</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">Result</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Arg0</td><td>The first tensor argument type </td></tr>
    <tr><td class="paramname">Args</td><td>The the remaining tensor argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramname">args</td><td>The data pointers of the tensors to be permuted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the copy </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permute_8h_source.html#l00122">122</a> of file <a class="el" href="permute_8h_source.html">permute.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ecba5efe7b319458a9f16df0563472b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Perm , typename Arg , typename Result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute_array </td>
          <td>(</td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>The permutation type </td></tr>
    <tr><td class="paramname">Arg</td><td>The input array type </td></tr>
    <tr><td class="paramname">Result</td><td>The output array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The input array to be permuted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The output array that will hold the permuted array </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="permutation_8h_source.html#l00057">57</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5cd635d089830705f84e08204967760d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00137">137</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c0a678c425372465314f925b87612ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00153">153</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d281f943194c67e7b0a491f03d49e02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of c-stype array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00047">47</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae3432456d26bf2a1704062cb243f71b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of c-stype array </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00055">55</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19a7aa4c081be027bd2ecc5cd917cd27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_array&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; decltype(a.size()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_array.html" title="An n-dimensional, tiled array. ">Array</a> size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of array <code>a</code> </dd></dl>

<p>Definition at line <a class="el" href="utility_8h_source.html#l00064">64</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1d6fcb450ef829c3ad4e8e1db5be514a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="bitset_8h_source.html#l00593">593</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad0cc592bab4bc45fd24ad38ce5805d38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with contiguous tensor arguments. </p>
<p>Initialize tensor of tensors with contiguous tensor arguments.</p>
<p>This function initializes the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00304">304</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a474df5f74ea75c66470f333f78dad3d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                   &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with permuted tensor arguments. </p>
<p>Initialize tensor of tensors with permuted tensor arguments.</p>
<p>This function initializes the elements of <code>tensor1</code> with the result of <code>op</code>(tensor1[i], tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>result</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to tensor2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00361">361</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a843205677d75eda1fcd81b50f9042b84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                                           &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value                                                           &amp;&amp;!is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with one or more non-contiguous tensor arguments. </p>
<p>This function initializes the elements of <code>tensor1</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tensor1</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00429">429</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac17e850985b5c94dc082d40978d0e22c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> operations with contiguous data. </p>
<p>This function sets the elements of the result tensor with <code>op</code>(tensor1[i], tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>The element-wise operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00056">56</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a968a88eff54f4dc3105f31c57a5e06ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value                                       ||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value)                                       &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> permutation operations with contiguous data. </p>
<p>This function sets the elements of the result tensor with <code>op</code>(tensor1[i],tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>The element-wise operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation that is used to compute the result value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00078">78</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2c476e766ff095a095ff4e5508684975"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if&lt; is_numeric&lt; Scalar &gt;::value &amp;&amp;is_tensor&lt; T1, Ts... &gt;::value                                           &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar TiledArray::detail::tensor_reduce </td>
          <td>(</td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> reduction operation for contiguous tensors. </p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> of tensors reduction operation for non-contiguous tensors.</p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> reduction operation for non-contiguous tensors.</p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> of tensor reduction operation for contiguous tensors.</p>
<p>Perform an element-wise reduction of the tensors. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s)</dd></dl>
<p>Perform an element-wise reduction of the tensors. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The result join operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s) </dd></dl>

<p>Definition at line <a class="el" href="kernels_8h_source.html#l00511">511</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li><li class="navelem"><a class="el" href="namespace_tiled_array_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Fri Oct 23 2015 09:53:45 for TiledArray by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
