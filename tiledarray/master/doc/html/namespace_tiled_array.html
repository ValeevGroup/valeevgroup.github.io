<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TiledArray: TiledArray Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TiledArray
   &#160;<span id="projectnumber">0.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_tiled_array.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_tiled_array_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1expressions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1expressions.html">expressions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1math"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1math.html">math</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1meta"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1meta.html">meta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1symmetry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1symmetry.html">symmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_tiled_array_1_1tile__interface"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1tile__interface.html">tile_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_abs_max_reduction.html">AbsMaxReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maxabs tile reduction.  <a href="class_tiled_array_1_1_abs_max_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_abs_min_reduction.html">AbsMinReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minabs tile reduction.  <a href="class_tiled_array_1_1_abs_min_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> tile operation.  <a href="class_tiled_array_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_add_to.html">AddTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add-to tile operation.  <a href="class_tiled_array_1_1_add_to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> that references a subblock of another range.  <a href="class_tiled_array_1_1_block_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> cast operation.  <a href="class_tiled_array_1_1_cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01_t_00_01_allocator_01_4_00_01btas_1_4609707baf645f507ebd5df14a7b8d69.html">Cast&lt; TiledArray::Tensor&lt; T, Allocator &gt;, btas::Tensor&lt; T, Range_, Storage &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a btas::Tensor to a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a>  <a href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01_t_00_01_allocator_01_4_00_01btas_1_4609707baf645f507ebd5df14a7b8d69.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01typename_01_t_1_1value__type_00_01_a5ddc81d43679d10d41a935c5d761cdb2.html">Cast&lt; TiledArray::Tensor&lt; typename T::value_type, Allocator &gt;, Tile&lt; T &gt;, detail::void_t&lt; decltype(std::declval&lt; TiledArray::Cast&lt; TiledArray::Tensor&lt; typename T::value_type, Allocator &gt;, T &gt;&gt;()(std::declval&lt; const T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement conversions from Tile&lt;T&gt; to TiledArray::Tensor&lt;T::value_type,Allocator&gt;  <a href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01typename_01_t_1_1value__type_00_01_a5ddc81d43679d10d41a935c5d761cdb2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_clone.html">Clone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of a tile.  <a href="class_tiled_array_1_1_clone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1clone__trait.html">clone_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_clone.html" title="Create a deep copy of a tile. ">Clone</a> trait.  <a href="struct_tiled_array_1_1clone__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_conjugate_gradient_solver.html">ConjugateGradientSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense shape of an array.  <a href="class_tiled_array_1_1_dense_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_d_i_i_s.html">DIIS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_d_i_i_s.html" title="DIIS (‘‘direct inversion of iterative subspace’’) extrapolation. ">DIIS</a> (&lsquo;&lsquo;direct inversion of iterative subspace&rsquo;&rsquo;) extrapolation.  <a href="class_tiled_array_1_1_d_i_i_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declarations.  <a href="class_tiled_array_1_1_dist_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_dot_reduction.html">DotReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product tile reduction.  <a href="class_tiled_array_1_1_dot_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1eval__trait.html">eval_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the object type used in the evaluation of tensor expressions.  <a href="struct_tiled_array_1_1eval__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_inner_product_reduction.html">InnerProductReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector inner product tile reduction.  <a href="class_tiled_array_1_1_inner_product_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_irrep.html">Irrep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_irrep.html" title="Irrep of an  symmetric group. ">Irrep</a> of an <img class="formulaInl" alt="$ S_n $" src="form_66.png"/> symmetric group.  <a href="class_tiled_array_1_1_irrep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__consumable__tile.html">is_consumable_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumable tile type trait.  <a href="struct_tiled_array_1_1is__consumable__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__consumable__tile_3_01_zero_tensor_01_4.html">is_consumable_tile&lt; ZeroTensor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense.html">is_dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to detect dense shape types.  <a href="struct_tiled_array_1_1is__dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense_3_01_dense_shape_01_4.html">is_dense&lt; DenseShape &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__dense_3_01_dist_array_3_01_tile_00_01_policy_01_4_01_4.html">is_dense&lt; DistArray&lt; Tile, Policy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__lazy__tile.html">is_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect lazy evaluation tiles.  <a href="struct_tiled_array_1_1is__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1is__lazy__tile_3_01_dist_array_3_01_tile_00_01_policy_01_4_01_4.html">is_lazy_tile&lt; DistArray&lt; Tile, Policy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_max_reduction.html">MaxReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum tile reduction.  <a href="class_tiled_array_1_1_max_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_max_reduction_3_01_tile_00_01typename_01std_1_1enable__if_3_01detail_1_1is72dbf640bf0586b2657ce5cdd9539f2d.html">MaxReduction&lt; Tile, typename std::enable_if&lt; detail::is_strictly_ordered&lt; detail::numeric_t&lt; Tile &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_min_reduction.html">MinReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum tile reduction.  <a href="class_tiled_array_1_1_min_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_min_reduction_3_01_tile_00_01typename_01std_1_1enable__if_3_01detail_1_1isbbf8cab6c762ebd87aacbfefa47f9cbf.html">MinReduction&lt; Tile, typename std::enable_if&lt; detail::is_strictly_ordered&lt; detail::numeric_t&lt; Tile &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> of a sequence of objects indexed by base-0 indices.  <a href="class_tiled_array_1_1_permutation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_permute.html">Permute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile. ">Permute</a> a tile.  <a href="class_tiled_array_1_1_permute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1permute__trait.html">permute_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile. ">Permute</a> trait.  <a href="struct_tiled_array_1_1permute__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_pmap.html">Pmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process map.  <a href="class_tiled_array_1_1_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_product_reduction.html">ProductReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> product reduction.  <a href="class_tiled_array_1_1_product_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (hyperrectangular) interval on <img class="formulaInl" alt="$ Z^n $" src="form_56.png"/>, space of integer n-indices.  <a href="class_tiled_array_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_add.html">ScalAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> tile operation.  <a href="class_tiled_array_1_1_scal_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scal_add_to.html">ScalAddTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add-to and scale tile operation.  <a href="class_tiled_array_1_1_scal_add_to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_scale.html">Scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> tile.  <a href="class_tiled_array_1_1_scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1scale__trait.html">scale_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> trait.  <a href="struct_tiled_array_1_1scale__trait.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_shift.html">Shift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of tile.  <a href="class_tiled_array_1_1_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_shift_to.html">ShiftTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of tile in place.  <a href="class_tiled_array_1_1_shift_to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitrary sparse shape.  <a href="class_tiled_array_1_1_sparse_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_squared_norm_reduction.html">SquaredNormReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared norm tile reduction.  <a href="class_tiled_array_1_1_squared_norm_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_sum_reduction.html">SumReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> sum reduction.  <a href="class_tiled_array_1_1_sum_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional tensor object.  <a href="class_tiled_array_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An N-dimensional shallow copy wrapper for tile objects.  <a href="class_tiled_array_1_1_tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> data of a tiled array.  <a href="class_tiled_array_1_1_tiled_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1_trace_reduction.html">TraceReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> trace reduction.  <a href="class_tiled_array_1_1_trace_reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1_zero_tensor.html">ZeroTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place-holder object for a zero tensor.  <a href="struct_tiled_array_1_1_zero_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac5db88c965b8d32f1f72d37d3dc3561c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac5db88c965b8d32f1f72d37d3dc3561c">EigenMatrixXd</a></td></tr>
<tr class="separator:ac5db88c965b8d32f1f72d37d3dc3561c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf44d8771941244661bf77cf07069e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aacdf44d8771941244661bf77cf07069e">EigenMatrixXf</a></td></tr>
<tr class="separator:aacdf44d8771941244661bf77cf07069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598c53efb66f9c18b8a6b5bcfbeaf8f3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a598c53efb66f9c18b8a6b5bcfbeaf8f3">EigenMatrixXcd</a></td></tr>
<tr class="separator:a598c53efb66f9c18b8a6b5bcfbeaf8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde89f3f1e4ba23ddf9ce7b6e2db088f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; float &gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adde89f3f1e4ba23ddf9ce7b6e2db088f">EigenMatrixXcf</a></td></tr>
<tr class="separator:adde89f3f1e4ba23ddf9ce7b6e2db088f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d1d4be6c1d3cef049c42490778da56"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae5d1d4be6c1d3cef049c42490778da56">EigenMatrixXi</a></td></tr>
<tr class="separator:ae5d1d4be6c1d3cef049c42490778da56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa83a358322961f1da1b50d5e28ae0ea"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afa83a358322961f1da1b50d5e28ae0ea">EigenMatrixXl</a></td></tr>
<tr class="separator:afa83a358322961f1da1b50d5e28ae0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa783ea4f581c1c1bb75f647d68c65a68"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa783ea4f581c1c1bb75f647d68c65a68">EigenVectorXd</a></td></tr>
<tr class="separator:aa783ea4f581c1c1bb75f647d68c65a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54f8e9145825b6155cf5389a9ee03a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; float, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0c54f8e9145825b6155cf5389a9ee03a">EigenVectorXf</a></td></tr>
<tr class="separator:a0c54f8e9145825b6155cf5389a9ee03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c2ebf917a509ec12deca6a13dd1904"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; double &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a19c2ebf917a509ec12deca6a13dd1904">EigenVectorXcd</a></td></tr>
<tr class="separator:a19c2ebf917a509ec12deca6a13dd1904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe17eddb0710849aa9af552f4f85098"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; std::complex&lt; float &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abfe17eddb0710849aa9af552f4f85098">EigenVectorXcf</a></td></tr>
<tr class="separator:abfe17eddb0710849aa9af552f4f85098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb38a6b56111826e5b451528b939eb60"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; int, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acb38a6b56111826e5b451528b939eb60">EigenVectorXi</a></td></tr>
<tr class="separator:acb38a6b56111826e5b451528b939eb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5f429338b7707830ce0339ebaf6274"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; long, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aec5f429338b7707830ce0339ebaf6274">EigenVectorXl</a></td></tr>
<tr class="separator:aec5f429338b7707830ce0339ebaf6274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35af09371a3551f27d53d90a059931fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range&gt; </td></tr>
<tr class="memitem:a35af09371a3551f27d53d90a059931fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, Range_ &gt;</td></tr>
<tr class="separator:a35af09371a3551f27d53d90a059931fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380d0c9b978b651c0e4af14e63baf2e0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_  = Range&gt; </td></tr>
<tr class="memitem:a380d0c9b978b651c0e4af14e63baf2e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; typename std::add_const&lt; T &gt;::type, Range_ &gt;</td></tr>
<tr class="separator:a380d0c9b978b651c0e4af14e63baf2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d2edc4ec73d986edc524386dab1f9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59d2edc4ec73d986edc524386dab1f9c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a59d2edc4ec73d986edc524386dab1f9c">TensorView</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;</td></tr>
<tr class="separator:a59d2edc4ec73d986edc524386dab1f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1950fa935cff5cb1415b58d822057f23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1950fa935cff5cb1415b58d822057f23"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1950fa935cff5cb1415b58d822057f23">TensorConstView</a> = <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; typename std::add_const&lt; T &gt;::type, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &gt;</td></tr>
<tr class="separator:a1950fa935cff5cb1415b58d822057f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a15302527b61f10109a44e76ea62d2"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gac0a15302527b61f10109a44e76ea62d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gac0a15302527b61f10109a44e76ea62d2">result_of_subt_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa">subt</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gac0a15302527b61f10109a44e76ea62d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb597ee654962821e46fe67505d9d82e"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gafb597ee654962821e46fe67505d9d82e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gafb597ee654962821e46fe67505d9d82e">result_of_subt_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">subt_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gafb597ee654962821e46fe67505d9d82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16021b6394d1bf4cb669cd411f75f84c"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga16021b6394d1bf4cb669cd411f75f84c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga16021b6394d1bf4cb669cd411f75f84c">result_of_mult_t</a> = decltype(<a class="el" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40">mult</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga16021b6394d1bf4cb669cd411f75f84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69682934d9dd00448f43db07be177be"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gad69682934d9dd00448f43db07be177be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gad69682934d9dd00448f43db07be177be">result_of_mult_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">mult_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gad69682934d9dd00448f43db07be177be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b695ca615c23ac38f3fcd53a905fc70"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga1b695ca615c23ac38f3fcd53a905fc70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1b695ca615c23ac38f3fcd53a905fc70">result_of_neg_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751">neg</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga1b695ca615c23ac38f3fcd53a905fc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a03566e3a493068e38d06c43cd4a8ab"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga3a03566e3a493068e38d06c43cd4a8ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga3a03566e3a493068e38d06c43cd4a8ab">result_of_neg_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">neg_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga3a03566e3a493068e38d06c43cd4a8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e359ae046dd03b00740c908258957dc"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9e359ae046dd03b00740c908258957dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9e359ae046dd03b00740c908258957dc">result_of_conj_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f">conj</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga9e359ae046dd03b00740c908258957dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf642faede431676d47b016bcf6a1fe6d"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gaf642faede431676d47b016bcf6a1fe6d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf642faede431676d47b016bcf6a1fe6d">result_of_conj_to_t</a> = decltype(<a class="el" href="group___tile_interface.html#gad2fd187f7e500ab8977032e67537b92a">conj_to</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:gaf642faede431676d47b016bcf6a1fe6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a9dc9a0def7d24cb5d5d223e7773b5"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga43a9dc9a0def7d24cb5d5d223e7773b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga43a9dc9a0def7d24cb5d5d223e7773b5">result_of_gemm_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238">gemm</a>(std::declval&lt; T &gt;()...))</td></tr>
<tr class="separator:ga43a9dc9a0def7d24cb5d5d223e7773b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd130a24d396bd69b954d553d1cb583"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaddd130a24d396bd69b954d553d1cb583"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaddd130a24d396bd69b954d553d1cb583">result_of_trace_t</a> = decltype(<a class="el" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40">mult</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gaddd130a24d396bd69b954d553d1cb583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9472ea3fc9c25a0df1ff1a8766de4a7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9472ea3fc9c25a0df1ff1a8766de4a7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9472ea3fc9c25a0df1ff1a8766de4a7e">result_of_sum_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga25d9a467ed3849aacaab335e5eb2ed57">sum</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga9472ea3fc9c25a0df1ff1a8766de4a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a39de86e7960d214f90d786236aed2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga99a39de86e7960d214f90d786236aed2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga99a39de86e7960d214f90d786236aed2">result_of_product_t</a> = decltype(<a class="el" href="group___tile_interface.html#gada89177095dd6a757f26e7c45f3798b0">product</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga99a39de86e7960d214f90d786236aed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99c917a22792c071cda35eea7c4b428"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa99c917a22792c071cda35eea7c4b428"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaa99c917a22792c071cda35eea7c4b428">result_of_squared_norm_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234">squared_norm</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gaa99c917a22792c071cda35eea7c4b428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf75f7ed43c11a853bfda4cfbeb0d9cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacf75f7ed43c11a853bfda4cfbeb0d9cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gacf75f7ed43c11a853bfda4cfbeb0d9cb">result_of_norm_t</a> = decltype(<a class="el" href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6">norm</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gacf75f7ed43c11a853bfda4cfbeb0d9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1babce417d8aec558a5fdc279f597787"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1babce417d8aec558a5fdc279f597787"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1babce417d8aec558a5fdc279f597787">result_of_max_t</a> = decltype(<a class="el" href="group___tile_interface.html#gace24afac354bfe849d2ca90df6ab8232">max</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga1babce417d8aec558a5fdc279f597787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa18ec76e56cfda0b79f797932c2825"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabaa18ec76e56cfda0b79f797932c2825"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gabaa18ec76e56cfda0b79f797932c2825">result_of_min_t</a> = decltype(<a class="el" href="group___tile_interface.html#gad4d977af50ab495f09a985dbfb871a3d">min</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gabaa18ec76e56cfda0b79f797932c2825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc6d1f58783873eada78cf1295a91ee1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadc6d1f58783873eada78cf1295a91ee1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gadc6d1f58783873eada78cf1295a91ee1">result_of_abs_max_t</a> = decltype(<a class="el" href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d">abs_max</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:gadc6d1f58783873eada78cf1295a91ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455f69411329a3f8e5019a2f6cfb5826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga455f69411329a3f8e5019a2f6cfb5826"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga455f69411329a3f8e5019a2f6cfb5826">result_of_abs_min_t</a> = decltype(<a class="el" href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd">abs_min</a>(std::declval&lt; T &gt;()))</td></tr>
<tr class="separator:ga455f69411329a3f8e5019a2f6cfb5826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f19ce3dee29789eb96536ff0e96d0ee"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga5f19ce3dee29789eb96536ff0e96d0ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5f19ce3dee29789eb96536ff0e96d0ee">result_of_dot_t</a> = decltype(<a class="el" href="namespace_tiled_array.html#a1e4ffd2673648a15c05d1380f0be0079">dot</a>(std::declval&lt; L &gt;(), std::declval&lt; R &gt;()))</td></tr>
<tr class="separator:ga5f19ce3dee29789eb96536ff0e96d0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a673c87e7624e63f641318f610a297"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; double, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac1a673c87e7624e63f641318f610a297">TensorD</a></td></tr>
<tr class="separator:ac1a673c87e7624e63f641318f610a297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58ff1caa878600bc482e36acb64060"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; int, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7f58ff1caa878600bc482e36acb64060">TensorI</a></td></tr>
<tr class="separator:a7f58ff1caa878600bc482e36acb64060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b4522d34881253139d842d7345dcbc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; float, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a43b4522d34881253139d842d7345dcbc">TensorF</a></td></tr>
<tr class="separator:a43b4522d34881253139d842d7345dcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940148a41f1a9b47fabd83511d0ad11f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; long, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a940148a41f1a9b47fabd83511d0ad11f">TensorL</a></td></tr>
<tr class="separator:a940148a41f1a9b47fabd83511d0ad11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4438e1e4fac9c7ed76af5bae4a6aff"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; std::complex&lt; double &gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; std::complex&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abe4438e1e4fac9c7ed76af5bae4a6aff">TensorZ</a></td></tr>
<tr class="separator:abe4438e1e4fac9c7ed76af5bae4a6aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac685ca67ab67879d908e57681834604c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; std::complex&lt; float &gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; std::complex&lt; float &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac685ca67ab67879d908e57681834604c">TensorC</a></td></tr>
<tr class="separator:ac685ca67ab67879d908e57681834604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14381436074bbf8eff68427766e395a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14381436074bbf8eff68427766e395a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; T &gt; &gt;, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;</td></tr>
<tr class="separator:a14381436074bbf8eff68427766e395a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25748e8f1dd4d7421925264bbe4905"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0b25748e8f1dd4d7421925264bbe4905">TArrayD</a></td></tr>
<tr class="separator:a0b25748e8f1dd4d7421925264bbe4905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6a345559008046e6785aee9d35f11d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2d6a345559008046e6785aee9d35f11d">TArrayI</a></td></tr>
<tr class="separator:a2d6a345559008046e6785aee9d35f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec85e445a8f0330f135292858a3cb4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aaeec85e445a8f0330f135292858a3cb4">TArrayF</a></td></tr>
<tr class="separator:aaeec85e445a8f0330f135292858a3cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99743650f2570e83f35a0ba1958c9569"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a99743650f2570e83f35a0ba1958c9569">TArrayL</a></td></tr>
<tr class="separator:a99743650f2570e83f35a0ba1958c9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa010edfe058bd83377e3790741e14dee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa010edfe058bd83377e3790741e14dee">TArrayZ</a></td></tr>
<tr class="separator:aa010edfe058bd83377e3790741e14dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea17c71440d5a58110b7ade911cf1102"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt; std::complex&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aea17c71440d5a58110b7ade911cf1102">TArrayC</a></td></tr>
<tr class="separator:aea17c71440d5a58110b7ade911cf1102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt; T &gt; &gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;</td></tr>
<tr class="separator:a0231c1beab8d7e7c31c19aeceede50fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0c4ccd3689f4dafb20c6d238690705"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TSpArrayD</a></td></tr>
<tr class="separator:abb0c4ccd3689f4dafb20c6d238690705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd7da1c48d18d477b9d0366e94d9b10"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4dd7da1c48d18d477b9d0366e94d9b10">TSpArrayI</a></td></tr>
<tr class="separator:a4dd7da1c48d18d477b9d0366e94d9b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd8165f08a44cf5a27efca786bee5ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a6bd8165f08a44cf5a27efca786bee5ac">TSpArrayF</a></td></tr>
<tr class="separator:a6bd8165f08a44cf5a27efca786bee5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e13a617d7cc592f38124462d5a853d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a51e13a617d7cc592f38124462d5a853d">TSpArrayL</a></td></tr>
<tr class="separator:a51e13a617d7cc592f38124462d5a853d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa157a11e4eb462e70e5fec1411acab8c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa157a11e4eb462e70e5fec1411acab8c">TSpArrayZ</a></td></tr>
<tr class="separator:aa157a11e4eb462e70e5fec1411acab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9caaa3d2c9f944690670df6a1a08ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt; std::complex&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#add9caaa3d2c9f944690670df6a1a08ed">TSpArrayC</a></td></tr>
<tr class="separator:add9caaa3d2c9f944690670df6a1a08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf28ccfd580f62de5342a9a1510e22e9"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int = 0, typename Tile  = Tensor&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;, typename Policy  = DensePolicy&gt; </td></tr>
<tr class="memitem:adf28ccfd580f62de5342a9a1510e22e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> = <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;</td></tr>
<tr class="separator:adf28ccfd580f62de5342a9a1510e22e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa1333af3bbdd6ac34ec64a4eef6e9e07"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> { <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c">ShapeReductionMethod::Union</a>, 
<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a>
 }</td></tr>
<tr class="separator:aa1333af3bbdd6ac34ec64a4eef6e9e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc51ed34e98a417052d745d91994de70"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:afc51ed34e98a417052d745d91994de70"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">size</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:afc51ed34e98a417052d745d91994de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b52c74197023a357e41e93efd8cf0a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a44b52c74197023a357e41e93efd8cf0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a44b52c74197023a357e41e93efd8cf0a">copy</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a44b52c74197023a357e41e93efd8cf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3558ec56f9d00590c35846d8f13c1b76"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a3558ec56f9d00590c35846d8f13c1b76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3558ec56f9d00590c35846d8f13c1b76">zero</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a3558ec56f9d00590c35846d8f13c1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4078d3b132757efef1b74e42575149"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:afc4078d3b132757efef1b74e42575149"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#afc4078d3b132757efef1b74e42575149">minabs_value</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:afc4078d3b132757efef1b74e42575149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8553a88a5735149954d4d04e491e7358"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a8553a88a5735149954d4d04e491e7358"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8553a88a5735149954d4d04e491e7358">maxabs_value</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:a8553a88a5735149954d4d04e491e7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297fc199c0e4a33cd3d6122b7c71f514"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a297fc199c0e4a33cd3d6122b7c71f514"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a297fc199c0e4a33cd3d6122b7c71f514">vec_multiply</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a1, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a2)</td></tr>
<tr class="separator:a297fc199c0e4a33cd3d6122b7c71f514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0b1ca917df616d05128c35276462fd"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:abc0b1ca917df616d05128c35276462fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc0b1ca917df616d05128c35276462fd">dot_product</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a1, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a2)</td></tr>
<tr class="separator:abc0b1ca917df616d05128c35276462fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4ffd2673648a15c05d1380f0be0079"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:a1e4ffd2673648a15c05d1380f0be0079"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait</a>&lt; Left &gt;::scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1e4ffd2673648a15c05d1380f0be0079">dot</a> (const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Left &gt; &amp;a1, const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Right &gt; &amp;a2)</td></tr>
<tr class="separator:a1e4ffd2673648a15c05d1380f0be0079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e2f4b420375c45a2c21049e27377aa"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a90e2f4b420375c45a2c21049e27377aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a90e2f4b420375c45a2c21049e27377aa">scale</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a, typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type scaling_factor)</td></tr>
<tr class="separator:a90e2f4b420375c45a2c21049e27377aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299983d3798619c4de88f351bbe369ae"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a299983d3798619c4de88f351bbe369ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a299983d3798619c4de88f351bbe369ae">axpy</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;y, typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type a, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;x)</td></tr>
<tr class="separator:a299983d3798619c4de88f351bbe369ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f28503ce59e167667a4d8259619bf0"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a59f28503ce59e167667a4d8259619bf0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a59f28503ce59e167667a4d8259619bf0">assign</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;m1, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;m2)</td></tr>
<tr class="separator:a59f28503ce59e167667a4d8259619bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad096df7fd3592ff4515f97a0fc3f98ef"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:ad096df7fd3592ff4515f97a0fc3f98ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::scalar_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad096df7fd3592ff4515f97a0fc3f98ef">norm2</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="separator:ad096df7fd3592ff4515f97a0fc3f98ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfd4a5d0073f766aeca78185b841a30"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:aadfd4a5d0073f766aeca78185b841a30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aadfd4a5d0073f766aeca78185b841a30">print</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a, const char *label)</td></tr>
<tr class="separator:aadfd4a5d0073f766aeca78185b841a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefa8ea4cb95ebb8c9d9b3809f12dc4d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ , typename Storage_ , typename Allocator_ &gt; </td></tr>
<tr class="memitem:aeefa8ea4cb95ebb8c9d9b3809f12dc4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aeefa8ea4cb95ebb8c9d9b3809f12dc4d">btas_subtensor_to_tensor</a> (const btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;src, <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, Allocator_ &gt; &amp;dst)</td></tr>
<tr class="memdesc:aeefa8ea4cb95ebb8c9d9b3809f12dc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a>.  <a href="#aeefa8ea4cb95ebb8c9d9b3809f12dc4d">More...</a><br /></td></tr>
<tr class="separator:aeefa8ea4cb95ebb8c9d9b3809f12dc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae862097c5ca7e7a8affa6275af008f63"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator_ , typename Range_ , typename Storage_ &gt; </td></tr>
<tr class="memitem:ae862097c5ca7e7a8affa6275af008f63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae862097c5ca7e7a8affa6275af008f63">tensor_to_btas_subtensor</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, Allocator_ &gt; &amp;src, btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;dst)</td></tr>
<tr class="memdesc:ae862097c5ca7e7a8affa6275af008f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a>.  <a href="#ae862097c5ca7e7a8affa6275af008f63">More...</a><br /></td></tr>
<tr class="separator:ae862097c5ca7e7a8affa6275af008f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="memTemplParams" colspan="2">template&lt;typename DistArray_ , typename T , typename Range , typename Storage &gt; </td></tr>
<tr class="memitem:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="memTemplItemLeft" align="right" valign="top">DistArray_&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa4eb781438f1d5ffec3f75b879ead8c0">btas_tensor_to_array</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;trange, const btas::Tensor&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, Storage &gt; &amp;src, bool replicated=false)</td></tr>
<tr class="memdesc:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a btas::Tensor object into a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a> object.  <a href="#aa4eb781438f1d5ffec3f75b879ead8c0">More...</a><br /></td></tr>
<tr class="separator:aa4eb781438f1d5ffec3f75b879ead8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692c0867d32b1147008f2bbe483168db"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a692c0867d32b1147008f2bbe483168db"><td class="memTemplItemLeft" align="right" valign="top">btas::Tensor&lt; typename Tile::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a692c0867d32b1147008f2bbe483168db">array_to_btas_tensor</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">TiledArray::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;src)</td></tr>
<tr class="memdesc:a692c0867d32b1147008f2bbe483168db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a> object into a btas::Tensor object.  <a href="#a692c0867d32b1147008f2bbe483168db">More...</a><br /></td></tr>
<tr class="separator:a692c0867d32b1147008f2bbe483168db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7c9fa503cbbd6e5627b1e1878cf51141">clone</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;arg)</td></tr>
<tr class="memdesc:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of an array.  <a href="#a7c9fa503cbbd6e5627b1e1878cf51141">More...</a><br /></td></tr>
<tr class="separator:a7c9fa503cbbd6e5627b1e1878cf51141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe2d157bfac3a81e84b52461e754c96"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a3fe2d157bfac3a81e84b52461e754c96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3fe2d157bfac3a81e84b52461e754c96">to_sparse</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;dense_array)</td></tr>
<tr class="memdesc:a3fe2d157bfac3a81e84b52461e754c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert a dense array into a block sparse array.  <a href="#a3fe2d157bfac3a81e84b52461e754c96">More...</a><br /></td></tr>
<tr class="separator:a3fe2d157bfac3a81e84b52461e754c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f448baf0d9da33c2112d366334c744a"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a9f448baf0d9da33c2112d366334c744a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f448baf0d9da33c2112d366334c744a">to_sparse</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;sparse_array)</td></tr>
<tr class="memdesc:a9f448baf0d9da33c2112d366334c744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the array is already sparse return a copy of the array.  <a href="#a9f448baf0d9da33c2112d366334c744a">More...</a><br /></td></tr>
<tr class="separator:a9f448baf0d9da33c2112d366334c744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af872c21673f2fd74250d0257fb80f2bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:af872c21673f2fd74250d0257fb80f2bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb">eigen_map</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t m, const std::size_t n)</td></tr>
<tr class="memdesc:af872c21673f2fd74250d0257fb80f2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#af872c21673f2fd74250d0257fb80f2bb">More...</a><br /></td></tr>
<tr class="separator:af872c21673f2fd74250d0257fb80f2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88684d17566e9778f88a27bb35f06a2a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a88684d17566e9778f88a27bb35f06a2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a88684d17566e9778f88a27bb35f06a2a">eigen_map</a> (<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t m, const std::size_t n)</td></tr>
<tr class="memdesc:a88684d17566e9778f88a27bb35f06a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#a88684d17566e9778f88a27bb35f06a2a">More...</a><br /></td></tr>
<tr class="separator:a88684d17566e9778f88a27bb35f06a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0362f265187dbcbec382fff3b76ccc2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a0362f265187dbcbec382fff3b76ccc2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, 1 &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0362f265187dbcbec382fff3b76ccc2d">eigen_map</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t n)</td></tr>
<tr class="memdesc:a0362f265187dbcbec382fff3b76ccc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#a0362f265187dbcbec382fff3b76ccc2d">More...</a><br /></td></tr>
<tr class="separator:a0362f265187dbcbec382fff3b76ccc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d234491688847706a6e1a1bd0c86319"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a0d234491688847706a6e1a1bd0c86319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, 1 &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0d234491688847706a6e1a1bd0c86319">eigen_map</a> (<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, const std::size_t n)</td></tr>
<tr class="memdesc:a0d234491688847706a6e1a1bd0c86319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#a0d234491688847706a6e1a1bd0c86319">More...</a><br /></td></tr>
<tr class="separator:a0d234491688847706a6e1a1bd0c86319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adfc30c5c9b3f17a6ab4d8b7a4b2a84b9">eigen_map</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor)</td></tr>
<tr class="memdesc:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#adfc30c5c9b3f17a6ab4d8b7a4b2a84b9">More...</a><br /></td></tr>
<tr class="separator:adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa6c8c7926367c10aaae6f056307b9d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:aeaa6c8c7926367c10aaae6f056307b9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;, Eigen::AutoAlign &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aeaa6c8c7926367c10aaae6f056307b9d">eigen_map</a> (<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor)</td></tr>
<tr class="memdesc:aeaa6c8c7926367c10aaae6f056307b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object.  <a href="#aeaa6c8c7926367c10aaae6f056307b9d">More...</a><br /></td></tr>
<tr class="separator:aeaa6c8c7926367c10aaae6f056307b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add789e43efcee8db349c7ec5c6218664"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename Derived &gt; </td></tr>
<tr class="memitem:add789e43efcee8db349c7ec5c6218664"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#add789e43efcee8db349c7ec5c6218664">eigen_submatrix_to_tensor</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor)</td></tr>
<tr class="memdesc:add789e43efcee8db349c7ec5c6218664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a block of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into a tensor.  <a href="#add789e43efcee8db349c7ec5c6218664">More...</a><br /></td></tr>
<tr class="separator:add789e43efcee8db349c7ec5c6218664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename Derived &gt; </td></tr>
<tr class="memitem:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a6a1e016346f447dcd7b5b4d7f29246b6">tensor_to_eigen_submatrix</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;tensor, Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the content of a tensor into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix block.  <a href="#a6a1e016346f447dcd7b5b4d7f29246b6">More...</a><br /></td></tr>
<tr class="separator:a6a1e016346f447dcd7b5b4d7f29246b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc20cb6cde49d2af9af3312a0309f540"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Derived &gt; </td></tr>
<tr class="memitem:acc20cb6cde49d2af9af3312a0309f540"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acc20cb6cde49d2af9af3312a0309f540">eigen_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix, bool replicated=false)</td></tr>
<tr class="memdesc:acc20cb6cde49d2af9af3312a0309f540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into an Array object.  <a href="#acc20cb6cde49d2af9af3312a0309f540">More...</a><br /></td></tr>
<tr class="separator:acc20cb6cde49d2af9af3312a0309f540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , unsigned int EigenStorageOrder = Eigen::ColMajor&gt; </td></tr>
<tr class="memitem:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt; typename Tile::value_type, Eigen::Dynamic, Eigen::Dynamic, EigenStorageOrder &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f">array_to_eigen</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;array)</td></tr>
<tr class="memdesc:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Array object into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix object.  <a href="#ad4ffc6de9b633a34e7d724191cd11f3f">More...</a><br /></td></tr>
<tr class="separator:ad4ffc6de9b633a34e7d724191cd11f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfba97f8c60f13c48f7adfcabc677b95"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:adfba97f8c60f13c48f7adfcabc677b95"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adfba97f8c60f13c48f7adfcabc677b95">row_major_buffer_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const typename A::value_type::value_type *buffer, const std::size_t m, const std::size_t n, const bool replicated=false)</td></tr>
<tr class="memdesc:adfba97f8c60f13c48f7adfcabc677b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a row-major matrix buffer into an Array object.  <a href="#adfba97f8c60f13c48f7adfcabc677b95">More...</a><br /></td></tr>
<tr class="separator:adfba97f8c60f13c48f7adfcabc677b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272240d40c483f779f8affc3c12c3285"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a272240d40c483f779f8affc3c12c3285"><td class="memTemplItemLeft" align="right" valign="top">A&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a272240d40c483f779f8affc3c12c3285">column_major_buffer_to_array</a> (World &amp;world, const typename A::trange_type &amp;trange, const typename A::value_type::value_type *buffer, const std::size_t m, const std::size_t n, const bool replicated=false)</td></tr>
<tr class="memdesc:a272240d40c483f779f8affc3c12c3285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a column-major matrix buffer into an Array object.  <a href="#a272240d40c483f779f8affc3c12c3285">More...</a><br /></td></tr>
<tr class="separator:a272240d40c483f779f8affc3c12c3285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9f9298465a3cb1b6e7a10d5c1cb6bc"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename ArgTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile,ArgTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0c9f9298465a3cb1b6e7a10d5c1cb6bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0c9f9298465a3cb1b6e7a10d5c1cb6bc">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a0c9f9298465a3cb1b6e7a10d5c1cb6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a dense Array.  <a href="#a0c9f9298465a3cb1b6e7a10d5c1cb6bc">More...</a><br /></td></tr>
<tr class="separator:a0c9f9298465a3cb1b6e7a10d5c1cb6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cf1d21760cdc032308a5045f0f4380"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op &gt; </td></tr>
<tr class="memitem:a33cf1d21760cdc032308a5045f0f4380"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a33cf1d21760cdc032308a5045f0f4380">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a33cf1d21760cdc032308a5045f0f4380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a dense Array.  <a href="#a33cf1d21760cdc032308a5045f0f4380">More...</a><br /></td></tr>
<tr class="separator:a33cf1d21760cdc032308a5045f0f4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf241d2417d9a9238d8ee8e28c775d1a"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op , typename  = typename std::enable_if&lt;! TiledArray::detail::is_array&lt;typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aaf241d2417d9a9238d8ee8e28c775d1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aaf241d2417d9a9238d8ee8e28c775d1a">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;arg, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:aaf241d2417d9a9238d8ee8e28c775d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify each tile of a dense Array.  <a href="#aaf241d2417d9a9238d8ee8e28c775d1a">More...</a><br /></td></tr>
<tr class="separator:aaf241d2417d9a9238d8ee8e28c775d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaefa05d5af04d159c459d3efbff5d6"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename ArgTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile,ArgTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3eaefa05d5af04d159c459d3efbff5d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3eaefa05d5af04d159c459d3efbff5d6">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a3eaefa05d5af04d159c459d3efbff5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a sparse Array.  <a href="#a3eaefa05d5af04d159c459d3efbff5d6">More...</a><br /></td></tr>
<tr class="separator:a3eaefa05d5af04d159c459d3efbff5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815db0400e14684f61c1e671d4bbe72d"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op &gt; </td></tr>
<tr class="memitem:a815db0400e14684f61c1e671d4bbe72d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a815db0400e14684f61c1e671d4bbe72d">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;arg, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a815db0400e14684f61c1e671d4bbe72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each tile of a sparse Array.  <a href="#a815db0400e14684f61c1e671d4bbe72d">More...</a><br /></td></tr>
<tr class="separator:a815db0400e14684f61c1e671d4bbe72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df16da578538bc1cb4fe3d513b064b4"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Op , typename  = typename std::enable_if&lt;! TiledArray::detail::is_array&lt;typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1df16da578538bc1cb4fe3d513b064b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1df16da578538bc1cb4fe3d513b064b4">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;arg, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:a1df16da578538bc1cb4fe3d513b064b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify each tile of a sparse Array.  <a href="#a1df16da578538bc1cb4fe3d513b064b4">More...</a><br /></td></tr>
<tr class="separator:a1df16da578538bc1cb4fe3d513b064b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c7caefcc685726b2e9b08b11647cf"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8e7c7caefcc685726b2e9b08b11647cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8e7c7caefcc685726b2e9b08b11647cf">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="separator:a8e7c7caefcc685726b2e9b08b11647cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48b2eeea37ab5747e688aa5737596da"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Op &gt; </td></tr>
<tr class="memitem:ad48b2eeea37ab5747e688aa5737596da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad48b2eeea37ab5747e688aa5737596da">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;right, Op &amp;&amp;op)</td></tr>
<tr class="separator:ad48b2eeea37ab5747e688aa5737596da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0657ef2c69d3fcd6354188a1538fbda"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Op &gt; </td></tr>
<tr class="memitem:ad0657ef2c69d3fcd6354188a1538fbda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad0657ef2c69d3fcd6354188a1538fbda">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;right, Op &amp;&amp;op, bool fence=true)</td></tr>
<tr class="memdesc:ad0657ef2c69d3fcd6354188a1538fbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two input tiles and put result into the left tile.  <a href="#ad0657ef2c69d3fcd6354188a1538fbda">More...</a><br /></td></tr>
<tr class="separator:ad0657ef2c69d3fcd6354188a1538fbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521d9d5e5c7f645f582f590f9c525d8b"><td class="memTemplParams" colspan="2">template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a521d9d5e5c7f645f582f590f9c525d8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a521d9d5e5c7f645f582f590f9c525d8b">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;right, Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction=<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a>)</td></tr>
<tr class="separator:a521d9d5e5c7f645f582f590f9c525d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5b3898764e80cf91a611a88660274b"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Op &gt; </td></tr>
<tr class="memitem:aad5b3898764e80cf91a611a88660274b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aad5b3898764e80cf91a611a88660274b">foreach</a> (const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;right, Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction=<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a>)</td></tr>
<tr class="separator:aad5b3898764e80cf91a611a88660274b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30755f37ccb7ea51d2c4fc3e66e4920a"><td class="memTemplParams" colspan="2">template&lt;typename LeftTile , typename RightTile , typename Op &gt; </td></tr>
<tr class="memitem:a30755f37ccb7ea51d2c4fc3e66e4920a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a30755f37ccb7ea51d2c4fc3e66e4920a">foreach_inplace</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;right, Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction=<a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a>, bool fence=true)</td></tr>
<tr class="memdesc:a30755f37ccb7ea51d2c4fc3e66e4920a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two input tiles and put result into the left tile.  <a href="#a30755f37ccb7ea51d2c4fc3e66e4920a">More...</a><br /></td></tr>
<tr class="separator:a30755f37ccb7ea51d2c4fc3e66e4920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Op , typename std::enable_if&lt; is_dense&lt; Array &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7cd3d9c18d8f36108c03e6ef9429144f">make_array</a> (World &amp;world, const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;trange, const std::shared_ptr&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">detail::pmap_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &gt; &amp;pmap, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct dense Array.  <a href="#a7cd3d9c18d8f36108c03e6ef9429144f">More...</a><br /></td></tr>
<tr class="separator:a7cd3d9c18d8f36108c03e6ef9429144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename Op &gt; </td></tr>
<tr class="memitem:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad73ea2d1e2e1b222f741f94a3f949e1c">make_array</a> (World &amp;world, const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;trange, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an Array.  <a href="#ad73ea2d1e2e1b222f741f94a3f949e1c">More...</a><br /></td></tr>
<tr class="separator:ad73ea2d1e2e1b222f741f94a3f949e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9380eed8edcb28bcde6b05f2a2e85f2"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:aa9380eed8edcb28bcde6b05f2a2e85f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa9380eed8edcb28bcde6b05f2a2e85f2">to_dense</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;sparse_array)</td></tr>
<tr class="separator:aa9380eed8edcb28bcde6b05f2a2e85f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d73428d629118ac2c9ab7f08b6ca180"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a3d73428d629118ac2c9ab7f08b6ca180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3d73428d629118ac2c9ab7f08b6ca180">to_dense</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;other)</td></tr>
<tr class="separator:a3d73428d629118ac2c9ab7f08b6ca180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c1ea27ad85cca7df258e71c7d9739"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy , typename Op &gt; </td></tr>
<tr class="memitem:a177c1ea27ad85cca7df258e71c7d9739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; typename std::result_of&lt; Op(<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>)&gt;::type, Policy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a177c1ea27ad85cca7df258e71c7d9739">to_new_tile_type</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;old_array, Op &amp;&amp;op)</td></tr>
<tr class="memdesc:a177c1ea27ad85cca7df258e71c7d9739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert an array to a new array with a different tile type.  <a href="#a177c1ea27ad85cca7df258e71c7d9739">More...</a><br /></td></tr>
<tr class="separator:a177c1ea27ad85cca7df258e71c7d9739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc763468b96a704d6b4efb628909485f"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:abc763468b96a704d6b4efb628909485f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc763468b96a704d6b4efb628909485f">truncate</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;array)</td></tr>
<tr class="memdesc:abc763468b96a704d6b4efb628909485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a dense Array.  <a href="#abc763468b96a704d6b4efb628909485f">More...</a><br /></td></tr>
<tr class="separator:abc763468b96a704d6b4efb628909485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="memTemplParams" colspan="2">template&lt;typename Tile &gt; </td></tr>
<tr class="memitem:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f42ee8853ef4f42c260f1a22ffc1eef">truncate</a> (<a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;array)</td></tr>
<tr class="memdesc:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a sparse Array.  <a href="#a9f42ee8853ef4f42c260f1a22ffc1eef">More...</a><br /></td></tr>
<tr class="separator:a9f42ee8853ef4f42c260f1a22ffc1eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de8bd808088bd6375c6dc8a9093b4b6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0de8bd808088bd6375c6dc8a9093b4b6">operator==</a> (const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;a, const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;b)</td></tr>
<tr class="separator:a0de8bd808088bd6375c6dc8a9093b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a725f292ae8f27a3d142e19bedca1e"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ab8a725f292ae8f27a3d142e19bedca1e">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;a, const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;b)</td></tr>
<tr class="separator:ab8a725f292ae8f27a3d142e19bedca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8044f7d779135e7bc782943d785a0fc5"><td class="memTemplParams" colspan="2">template&lt;typename Tile , typename Policy &gt; </td></tr>
<tr class="memitem:a8044f7d779135e7bc782943d785a0fc5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8044f7d779135e7bc782943d785a0fc5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;a)</td></tr>
<tr class="memdesc:a8044f7d779135e7bc782943d785a0fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> the tensor to an output stream.  <a href="#a8044f7d779135e7bc782943d785a0fc5">More...</a><br /></td></tr>
<tr class="separator:a8044f7d779135e7bc782943d785a0fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad641711c98c1b64bdf7ad28cccfae69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aad641711c98c1b64bdf7ad28cccfae69">exception_break</a> ()</td></tr>
<tr class="memdesc:aad641711c98c1b64bdf7ad28cccfae69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a break point on this function to stop before <a class="el" href="namespace_tiled_array.html">TiledArray</a> exceptions are thrown.  <a href="#aad641711c98c1b64bdf7ad28cccfae69">More...</a><br /></td></tr>
<tr class="separator:aad641711c98c1b64bdf7ad28cccfae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ce148a0f9ea7a739139fd97e16bc4c"><td class="memTemplParams" colspan="2">template&lt;typename Perm &gt; </td></tr>
<tr class="memitem:ad7ce148a0f9ea7a739139fd97e16bc4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad7ce148a0f9ea7a739139fd97e16bc4c">permute</a> (const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;r, const Perm &amp;p)</td></tr>
<tr class="separator:ad7ce148a0f9ea7a739139fd97e16bc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d81ab8db19341b018ee44dd5721d28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga82d81ab8db19341b018ee44dd5721d28">operator==</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:ga82d81ab8db19341b018ee44dd5721d28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> equality operator.  <a href="group__symmetry.html#ga82d81ab8db19341b018ee44dd5721d28">More...</a><br /></td></tr>
<tr class="separator:ga82d81ab8db19341b018ee44dd5721d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga64f168b5f03c8c2548c1b67a6509e9a4">operator&lt;&lt;</a> (std::ostream &amp;output, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p)</td></tr>
<tr class="memdesc:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> permutation to an output stream.  <a href="group__symmetry.html#ga64f168b5f03c8c2548c1b67a6509e9a4">More...</a><br /></td></tr>
<tr class="separator:ga64f168b5f03c8c2548c1b67a6509e9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586be997af3bd421583c8fd36c4e95f2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a586be997af3bd421583c8fd36c4e95f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a586be997af3bd421583c8fd36c4e95f2">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a586be997af3bd421583c8fd36c4e95f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile. ">Permute</a> a <code>std::array</code>.  <a href="#a586be997af3bd421583c8fd36c4e95f2">More...</a><br /></td></tr>
<tr class="separator:a586be997af3bd421583c8fd36c4e95f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84ce21d711a462da4a1b44a811a5a94"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae84ce21d711a462da4a1b44a811a5a94"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae84ce21d711a462da4a1b44a811a5a94">operator*=</a> (std::array&lt; T, N &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ae84ce21d711a462da4a1b44a811a5a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place permute a <code>std::array</code>.  <a href="#ae84ce21d711a462da4a1b44a811a5a94">More...</a><br /></td></tr>
<tr class="separator:ae84ce21d711a462da4a1b44a811a5a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db915cc9b57726c63e876d1260c50dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a3db915cc9b57726c63e876d1260c50dc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3db915cc9b57726c63e876d1260c50dc">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const std::vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a3db915cc9b57726c63e876d1260c50dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute a <code>std::vector&lt;T&gt;</code>  <a href="#a3db915cc9b57726c63e876d1260c50dc">More...</a><br /></td></tr>
<tr class="separator:a3db915cc9b57726c63e876d1260c50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4beab363e9a6e97343bc39965e548f95"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a4beab363e9a6e97343bc39965e548f95"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, A &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4beab363e9a6e97343bc39965e548f95">operator*=</a> (std::vector&lt; T, A &gt; &amp;v, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a4beab363e9a6e97343bc39965e548f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place permute a <code>std::array</code>.  <a href="#a4beab363e9a6e97343bc39965e548f95">More...</a><br /></td></tr>
<tr class="separator:a4beab363e9a6e97343bc39965e548f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cf85d544ef5cea5a232dc86766d80c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35cf85d544ef5cea5a232dc86766d80c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a35cf85d544ef5cea5a232dc86766d80c">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T *MADNESS_RESTRICT const ptr)</td></tr>
<tr class="memdesc:a35cf85d544ef5cea5a232dc86766d80c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile. ">Permute</a> a memory buffer.  <a href="#a35cf85d544ef5cea5a232dc86766d80c">More...</a><br /></td></tr>
<tr class="separator:a35cf85d544ef5cea5a232dc86766d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38342dbdaa26d0f24c1633f77c6555d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gab38342dbdaa26d0f24c1633f77c6555d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> inequality operator.  <a href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d">More...</a><br /></td></tr>
<tr class="separator:gab38342dbdaa26d0f24c1633f77c6555d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63845f58c204f812d564fa36d02103c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#ga63845f58c204f812d564fa36d02103c6">operator&lt;</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:ga63845f58c204f812d564fa36d02103c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> less-than operator.  <a href="group__symmetry.html#ga63845f58c204f812d564fa36d02103c6">More...</a><br /></td></tr>
<tr class="separator:ga63845f58c204f812d564fa36d02103c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gaeb2fae98580d4113b53ee2f7385c22fc">operator-</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse permutation operator.  <a href="group__symmetry.html#gaeb2fae98580d4113b53ee2f7385c22fc">More...</a><br /></td></tr>
<tr class="separator:gaeb2fae98580d4113b53ee2f7385c22fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35ad610b547911850e7ac729a08a917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gac35ad610b547911850e7ac729a08a917">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gac35ad610b547911850e7ac729a08a917"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permutation.html" title="Permutation of a sequence of objects indexed by base-0 indices. ">Permutation</a> multiplication operator.  <a href="group__symmetry.html#gac35ad610b547911850e7ac729a08a917">More...</a><br /></td></tr>
<tr class="separator:gac35ad610b547911850e7ac729a08a917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab001d09984e0b7c2bca406ea43b08078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gab001d09984e0b7c2bca406ea43b08078">operator*=</a> (<a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p1, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p2)</td></tr>
<tr class="memdesc:gab001d09984e0b7c2bca406ea43b08078"><td class="mdescLeft">&#160;</td><td class="mdescRight">return *this ^ other  <a href="group__symmetry.html#gab001d09984e0b7c2bca406ea43b08078">More...</a><br /></td></tr>
<tr class="separator:gab001d09984e0b7c2bca406ea43b08078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__symmetry.html#gaf1f4db587fe34281a4ffab0ca581d2b1">operator^</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, int n)</td></tr>
<tr class="memdesc:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise <code>perm</code> to the n-th power.  <a href="group__symmetry.html#gaf1f4db587fe34281a4ffab0ca581d2b1">More...</a><br /></td></tr>
<tr class="separator:gaf1f4db587fe34281a4ffab0ca581d2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a705b350b2dbf336a9cc24fb1d0f78fca">swap</a> (<a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1)</td></tr>
<tr class="memdesc:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the values of the give two ranges.  <a href="#a705b350b2dbf336a9cc24fb1d0f78fca">More...</a><br /></td></tr>
<tr class="separator:a705b350b2dbf336a9cc24fb1d0f78fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f80db611a7af38027953b96bc8f0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a678f80db611a7af38027953b96bc8f0d">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r)</td></tr>
<tr class="memdesc:a678f80db611a7af38027953b96bc8f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted range.  <a href="#a678f80db611a7af38027953b96bc8f0d">More...</a><br /></td></tr>
<tr class="separator:a678f80db611a7af38027953b96bc8f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac25a0fb0ad765d6c6a383c67d403fc57">operator==</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> equality comparison.  <a href="#ac25a0fb0ad765d6c6a383c67d403fc57">More...</a><br /></td></tr>
<tr class="separator:ac25a0fb0ad765d6c6a383c67d403fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc410382ebb92ab3373034a9b54a9a78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abc410382ebb92ab3373034a9b54a9a78">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:abc410382ebb92ab3373034a9b54a9a78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> inequality comparison.  <a href="#abc410382ebb92ab3373034a9b54a9a78">More...</a><br /></td></tr>
<tr class="separator:abc410382ebb92ab3373034a9b54a9a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a00568c34aef7e5f9b2802cbdd4382ea5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r)</td></tr>
<tr class="memdesc:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> output operator.  <a href="#a00568c34aef7e5f9b2802cbdd4382ea5">More...</a><br /></td></tr>
<tr class="separator:a00568c34aef7e5f9b2802cbdd4382ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9b4eb5173fc9dae94dd7a1a012f42b4d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a>&lt; T &gt; &amp;shape)</td></tr>
<tr class="memdesc:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> the shape to an output stream.  <a href="#a9b4eb5173fc9dae94dd7a1a012f42b4d">More...</a><br /></td></tr>
<tr class="separator:a9b4eb5173fc9dae94dd7a1a012f42b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddaca49af12c55a7e2087ad77aa8035"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ddaca49af12c55a7e2087ad77aa8035"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T &gt;, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1ddaca49af12c55a7e2087ad77aa8035">dense_diagonal_array</a> (World &amp;world, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, T val=1)</td></tr>
<tr class="separator:a1ddaca49af12c55a7e2087ad77aa8035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fd6c6add8ea900d7d2350fbe652390"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8fd6c6add8ea900d7d2350fbe652390"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T &gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae8fd6c6add8ea900d7d2350fbe652390">sparse_diagonal_array</a> (World &amp;world, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, T val=1)</td></tr>
<tr class="separator:ae8fd6c6add8ea900d7d2350fbe652390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba93db4bfabae38eb6d12fa6fcd62f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a8ba93db4bfabae38eb6d12fa6fcd62f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T &gt;, std::enable_if_t&lt; std::is_same&lt; Policy, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;::value, Policy &gt;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a8ba93db4bfabae38eb6d12fa6fcd62f0">diagonal_array</a> (World &amp;world, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, T val=1)</td></tr>
<tr class="separator:a8ba93db4bfabae38eb6d12fa6fcd62f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eb6ea8aa02524afe336384f717ec7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Policy &gt; </td></tr>
<tr class="memitem:a94eb6ea8aa02524afe336384f717ec7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T &gt;, std::enable_if_t&lt; std::is_same&lt; Policy, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;::value, Policy &gt;&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a94eb6ea8aa02524afe336384f717ec7a">diagonal_array</a> (World &amp;world, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, T val=1)</td></tr>
<tr class="separator:a94eb6ea8aa02524afe336384f717ec7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70044a879bcceefda052fe65023bb378"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a70044a879bcceefda052fe65023bb378"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a70044a879bcceefda052fe65023bb378">operator+</a> (const T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a70044a879bcceefda052fe65023bb378"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator.  <a href="#a70044a879bcceefda052fe65023bb378">More...</a><br /></td></tr>
<tr class="separator:a70044a879bcceefda052fe65023bb378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6846288ddd37fd160c0afcdf72ce03b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac6846288ddd37fd160c0afcdf72ce03b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac6846288ddd37fd160c0afcdf72ce03b">operator-</a> (const T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:ac6846288ddd37fd160c0afcdf72ce03b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator.  <a href="#ac6846288ddd37fd160c0afcdf72ce03b">More...</a><br /></td></tr>
<tr class="separator:ac6846288ddd37fd160c0afcdf72ce03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2b7b0326fbc5daaf9df0298d58e7df49">operator*</a> (const T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> multiplication operator.  <a href="#a2b7b0326fbc5daaf9df0298d58e7df49">More...</a><br /></td></tr>
<tr class="separator:a2b7b0326fbc5daaf9df0298d58e7df49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93accba5edcc96b461552d4a9483ec3d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a93accba5edcc96b461552d4a9483ec3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a93accba5edcc96b461552d4a9483ec3d">operator*</a> (const T &amp;left, N right)</td></tr>
<tr class="memdesc:a93accba5edcc96b461552d4a9483ec3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>left</code> that is scaled by <code>right</code>.  <a href="#a93accba5edcc96b461552d4a9483ec3d">More...</a><br /></td></tr>
<tr class="separator:a93accba5edcc96b461552d4a9483ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22953e4bba13494766ec2fc06ea1744"><td class="memTemplParams" colspan="2">template&lt;typename N , typename T , typename std::enable_if&lt; detail::is_numeric&lt; N &gt;::value &amp;&amp;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae22953e4bba13494766ec2fc06ea1744"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae22953e4bba13494766ec2fc06ea1744">operator*</a> (N left, const T &amp;right)</td></tr>
<tr class="memdesc:ae22953e4bba13494766ec2fc06ea1744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>right</code> that is scaled by <code>left</code>.  <a href="#ae22953e4bba13494766ec2fc06ea1744">More...</a><br /></td></tr>
<tr class="separator:ae22953e4bba13494766ec2fc06ea1744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac90b5d6c5aae4293d2b9d3456477aeba">operator-</a> (const T &amp;arg) -&gt; decltype(arg.neg())</td></tr>
<tr class="memdesc:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a negated copy of <code>arg</code>.  <a href="#ac90b5d6c5aae4293d2b9d3456477aeba">More...</a><br /></td></tr>
<tr class="separator:ac90b5d6c5aae4293d2b9d3456477aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b58b8591b03eebae61c177036697562"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5b58b8591b03eebae61c177036697562"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a5b58b8591b03eebae61c177036697562">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T &amp;arg)</td></tr>
<tr class="memdesc:a5b58b8591b03eebae61c177036697562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="#a5b58b8591b03eebae61c177036697562">More...</a><br /></td></tr>
<tr class="separator:a5b58b8591b03eebae61c177036697562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f076f0602b99660440a31b1290dcba7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9f076f0602b99660440a31b1290dcba7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f076f0602b99660440a31b1290dcba7">operator+=</a> (T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a9f076f0602b99660440a31b1290dcba7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator.  <a href="#a9f076f0602b99660440a31b1290dcba7">More...</a><br /></td></tr>
<tr class="separator:a9f076f0602b99660440a31b1290dcba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a21ca0c0a8f3a232c9d615ffd6e84e41f">operator-=</a> (T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator.  <a href="#a21ca0c0a8f3a232c9d615ffd6e84e41f">More...</a><br /></td></tr>
<tr class="separator:a21ca0c0a8f3a232c9d615ffd6e84e41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf25c7dbd596cf41749f0c284a09eafd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf25c7dbd596cf41749f0c284a09eafd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aaf25c7dbd596cf41749f0c284a09eafd">operator*=</a> (T1 &amp;left, const T2 &amp;right)</td></tr>
<tr class="memdesc:aaf25c7dbd596cf41749f0c284a09eafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor multiplication.  <a href="#aaf25c7dbd596cf41749f0c284a09eafd">More...</a><br /></td></tr>
<tr class="separator:aaf25c7dbd596cf41749f0c284a09eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868921cf563ff1fb9f3304bc314fec22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a868921cf563ff1fb9f3304bc314fec22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a868921cf563ff1fb9f3304bc314fec22">operator+=</a> (T &amp;left, N right)</td></tr>
<tr class="memdesc:a868921cf563ff1fb9f3304bc314fec22"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor add constant.  <a href="#a868921cf563ff1fb9f3304bc314fec22">More...</a><br /></td></tr>
<tr class="separator:a868921cf563ff1fb9f3304bc314fec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3890c67d7f105e091e0f6114b9c56c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acf3890c67d7f105e091e0f6114b9c56c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acf3890c67d7f105e091e0f6114b9c56c">operator-=</a> (T &amp;left, N right)</td></tr>
<tr class="memdesc:acf3890c67d7f105e091e0f6114b9c56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor subtract constant.  <a href="#acf3890c67d7f105e091e0f6114b9c56c">More...</a><br /></td></tr>
<tr class="separator:acf3890c67d7f105e091e0f6114b9c56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1493d57cb2d466240eeaef8e173cf6b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1493d57cb2d466240eeaef8e173cf6b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a1493d57cb2d466240eeaef8e173cf6b2">operator*=</a> (T &amp;left, N right)</td></tr>
<tr class="memdesc:a1493d57cb2d466240eeaef8e173cf6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">In place tensor scale.  <a href="#a1493d57cb2d466240eeaef8e173cf6b2">More...</a><br /></td></tr>
<tr class="separator:a1493d57cb2d466240eeaef8e173cf6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3ed423a0b023a4a5aadfb5012d968a4a">shift</a> (T &amp;tensor)</td></tr>
<tr class="memdesc:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> a tensor from one range to another.  <a href="#a3ed423a0b023a4a5aadfb5012d968a4a">More...</a><br /></td></tr>
<tr class="separator:a3ed423a0b023a4a5aadfb5012d968a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a62b1b3fec016be7c5ed4230f72e5b29d">shift</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> a tensor from one range to another.  <a href="#a62b1b3fec016be7c5ed4230f72e5b29d">More...</a><br /></td></tr>
<tr class="separator:a62b1b3fec016be7c5ed4230f72e5b29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15916eaafd6285509fe08919de285f23"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a15916eaafd6285509fe08919de285f23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a15916eaafd6285509fe08919de285f23">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;b)</td></tr>
<tr class="separator:a15916eaafd6285509fe08919de285f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3316fbfa5aa7fe5314bf54670d198bee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a3316fbfa5aa7fe5314bf54670d198bee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3316fbfa5aa7fe5314bf54670d198bee">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;b)</td></tr>
<tr class="separator:a3316fbfa5aa7fe5314bf54670d198bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a59d75845f7586427931c3d854e70e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:ac6a59d75845f7586427931c3d854e70e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac6a59d75845f7586427931c3d854e70e">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;, T *const, const Index &amp;, const Index &amp;)</td></tr>
<tr class="separator:ac6a59d75845f7586427931c3d854e70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a0cd1e1736b072b51f1d438c74575a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:a42a0cd1e1736b072b51f1d438c74575a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a42a0cd1e1736b072b51f1d438c74575a">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;, T *const, const Index &amp;, const Index &amp;)</td></tr>
<tr class="separator:a42a0cd1e1736b072b51f1d438c74575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d05db90b5aba567b8653f980ab3310"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34d05db90b5aba567b8653f980ab3310"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a34d05db90b5aba567b8653f980ab3310">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;, T *const, const std::initializer_list&lt; std::size_t &gt; &amp;, const std::initializer_list&lt; std::size_t &gt; &amp;)</td></tr>
<tr class="separator:a34d05db90b5aba567b8653f980ab3310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ca6dca916f81f03b3043771187db57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6ca6dca916f81f03b3043771187db57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ae6ca6dca916f81f03b3043771187db57">remap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;, T *const, const std::initializer_list&lt; std::size_t &gt; &amp;, const std::initializer_list&lt; std::size_t &gt; &amp;)</td></tr>
<tr class="separator:ae6ca6dca916f81f03b3043771187db57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3f6231b75b996d3fa766849f952eef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:a4b3f6231b75b996d3fa766849f952eef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4b3f6231b75b996d3fa766849f952eef">make_map</a> (T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a4b3f6231b75b996d3fa766849f952eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550c8b83d887c20998b7a696d3ee8111"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a550c8b83d887c20998b7a696d3ee8111"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a550c8b83d887c20998b7a696d3ee8111">make_map</a> (T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a550c8b83d887c20998b7a696d3ee8111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44f97290544cd48a481ff863d7ecdc8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ &gt; </td></tr>
<tr class="memitem:ac44f97290544cd48a481ff863d7ecdc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt; T, std::decay_t&lt; Range_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac44f97290544cd48a481ff863d7ecdc8">make_map</a> (T *const data, Range_ &amp;&amp;range)</td></tr>
<tr class="separator:ac44f97290544cd48a481ff863d7ecdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e69e843e127604a961c87e9c987cce6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:a9e69e843e127604a961c87e9c987cce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9e69e843e127604a961c87e9c987cce6">make_map</a> (const T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a9e69e843e127604a961c87e9c987cce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cce5a1ed8ed29fc23faee418274512"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78cce5a1ed8ed29fc23faee418274512"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a78cce5a1ed8ed29fc23faee418274512">make_map</a> (const T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a78cce5a1ed8ed29fc23faee418274512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7755dc3352169ae0eb14cf0b0cf11f1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ &gt; </td></tr>
<tr class="memitem:aa7755dc3352169ae0eb14cf0b0cf11f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T, std::decay_t&lt; Range_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa7755dc3352169ae0eb14cf0b0cf11f1">make_map</a> (const T *const data, Range_ &amp;&amp;range)</td></tr>
<tr class="separator:aa7755dc3352169ae0eb14cf0b0cf11f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3e7bc14ca6d99904ada555922fc391"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:ada3e7bc14ca6d99904ada555922fc391"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ada3e7bc14ca6d99904ada555922fc391">make_const_map</a> (const T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:ada3e7bc14ca6d99904ada555922fc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46acafb5a0d0468803cf0136997b0343"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46acafb5a0d0468803cf0136997b0343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a46acafb5a0d0468803cf0136997b0343">make_const_map</a> (const T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a46acafb5a0d0468803cf0136997b0343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7caf83be84a92371f88fa53b8e100317"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7caf83be84a92371f88fa53b8e100317"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7caf83be84a92371f88fa53b8e100317">make_const_map</a> (const T *const data, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;range)</td></tr>
<tr class="separator:a7caf83be84a92371f88fa53b8e100317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f982e077d43b36c87df64a39f807d47"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:a9f982e077d43b36c87df64a39f807d47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9f982e077d43b36c87df64a39f807d47">make_const_map</a> (T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:a9f982e077d43b36c87df64a39f807d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84f1b63afe58629a6631314d9e644b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad84f1b63afe58629a6631314d9e644b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ad84f1b63afe58629a6631314d9e644b9">make_const_map</a> (T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:ad84f1b63afe58629a6631314d9e644b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c66c80be76422ac5593f8c55264032"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Range_ &gt; </td></tr>
<tr class="memitem:a32c66c80be76422ac5593f8c55264032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T, std::decay_t&lt; Range_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a32c66c80be76422ac5593f8c55264032">make_const_map</a> (T *const data, Range_ &amp;&amp;range)</td></tr>
<tr class="separator:a32c66c80be76422ac5593f8c55264032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af647aa352f5f2099f6c4ee3ca8c1ba39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:af647aa352f5f2099f6c4ee3ca8c1ba39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#af647aa352f5f2099f6c4ee3ca8c1ba39">remap</a> (<a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt; T &gt; &amp;map, T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="memdesc:af647aa352f5f2099f6c4ee3ca8c1ba39"><td class="mdescLeft">&#160;</td><td class="mdescRight">For reusing map without allocating new ranges . . . maybe.  <a href="#af647aa352f5f2099f6c4ee3ca8c1ba39">More...</a><br /></td></tr>
<tr class="separator:af647aa352f5f2099f6c4ee3ca8c1ba39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a8861c632bb1899465cfc486b6e22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Index &gt; </td></tr>
<tr class="memitem:ac74a8861c632bb1899465cfc486b6e22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac74a8861c632bb1899465cfc486b6e22">remap</a> (<a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt; &amp;map, T *const data, const Index &amp;lower_bound, const Index &amp;upper_bound)</td></tr>
<tr class="separator:ac74a8861c632bb1899465cfc486b6e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25147c8d3ed11d8724a3092c745fa6e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25147c8d3ed11d8724a3092c745fa6e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a25147c8d3ed11d8724a3092c745fa6e3">remap</a> (<a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt; T &gt; &amp;map, T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a25147c8d3ed11d8724a3092c745fa6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dcfc333a6edc4f323691954f799699"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50dcfc333a6edc4f323691954f799699"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a50dcfc333a6edc4f323691954f799699">remap</a> (<a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt; &amp;map, T *const data, const std::initializer_list&lt; std::size_t &gt; &amp;lower_bound, const std::initializer_list&lt; std::size_t &gt; &amp;upper_bound)</td></tr>
<tr class="separator:a50dcfc333a6edc4f323691954f799699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d07017bf139b8ea4e344216443b372"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value &amp;&amp;detail::is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a67d07017bf139b8ea4e344216443b372"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a67d07017bf139b8ea4e344216443b372">operator&lt;&lt;</a> (std::ostream &amp;os, const T &amp;t)</td></tr>
<tr class="memdesc:a67d07017bf139b8ea4e344216443b372"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> output operator.  <a href="#a67d07017bf139b8ea4e344216443b372">More...</a><br /></td></tr>
<tr class="separator:a67d07017bf139b8ea4e344216443b372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1">clone</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gaec378f0f4b197546fb0b69f16748bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>arg</code>.  <a href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1">More...</a><br /></td></tr>
<tr class="separator:gaec378f0f4b197546fb0b69f16748bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gacd7e8d783c93f6a965a52cfc7124b6d0">empty</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that <code>arg</code> is empty (no data)  <a href="group___tile_interface.html#gacd7e8d783c93f6a965a52cfc7124b6d0">More...</a><br /></td></tr>
<tr class="separator:gacd7e8d783c93f6a965a52cfc7124b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49621c8ce21243534fb83247c3cfb6ea"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga49621c8ce21243534fb83247c3cfb6ea"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga49621c8ce21243534fb83247c3cfb6ea">permute</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga49621c8ce21243534fb83247c3cfb6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="group___tile_interface.html#ga49621c8ce21243534fb83247c3cfb6ea">More...</a><br /></td></tr>
<tr class="separator:ga49621c8ce21243534fb83247c3cfb6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b9ad4c6f5c4ce7928e61669c37844a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:ga91b9ad4c6f5c4ce7928e61669c37844a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga91b9ad4c6f5c4ce7928e61669c37844a">shift</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:ga91b9ad4c6f5c4ce7928e61669c37844a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of <code>arg</code>.  <a href="group___tile_interface.html#ga91b9ad4c6f5c4ce7928e61669c37844a">More...</a><br /></td></tr>
<tr class="separator:ga91b9ad4c6f5c4ce7928e61669c37844a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga2ead9e3d38c6a824d4dfe0beffddbcdf">shift_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of <code>arg</code> in place.  <a href="group___tile_interface.html#ga2ead9e3d38c6a824d4dfe0beffddbcdf">More...</a><br /></td></tr>
<tr class="separator:ga2ead9e3d38c6a824d4dfe0beffddbcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4f9977ff8130c6b95fc646e6a968f7a6">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> tile arguments.  <a href="group___tile_interface.html#ga4f9977ff8130c6b95fc646e6a968f7a6">More...</a><br /></td></tr>
<tr class="separator:ga4f9977ff8130c6b95fc646e6a968f7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac080bac89fc26e28adc8ce434f7098bd"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac080bac89fc26e28adc8ce434f7098bd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac080bac89fc26e28adc8ce434f7098bd">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:gac080bac89fc26e28adc8ce434f7098bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and scale tile arguments.  <a href="group___tile_interface.html#gac080bac89fc26e28adc8ce434f7098bd">More...</a><br /></td></tr>
<tr class="separator:gac080bac89fc26e28adc8ce434f7098bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c967bbb031db41e977b34a54a41559"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gac1c967bbb031db41e977b34a54a41559"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac1c967bbb031db41e977b34a54a41559">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gac1c967bbb031db41e977b34a54a41559"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and permute tile arguments.  <a href="group___tile_interface.html#gac1c967bbb031db41e977b34a54a41559">More...</a><br /></td></tr>
<tr class="separator:gac1c967bbb031db41e977b34a54a41559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga096c7cb92acf0ef994f83a426f5b3c04"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga096c7cb92acf0ef994f83a426f5b3c04"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga096c7cb92acf0ef994f83a426f5b3c04">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga096c7cb92acf0ef994f83a426f5b3c04"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a>, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga096c7cb92acf0ef994f83a426f5b3c04">More...</a><br /></td></tr>
<tr class="separator:ga096c7cb92acf0ef994f83a426f5b3c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacad2b52ab350044c8742ec1eef39a0b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaacad2b52ab350044c8742ec1eef39a0b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaacad2b52ab350044c8742ec1eef39a0b">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value)</td></tr>
<tr class="memdesc:gaacad2b52ab350044c8742ec1eef39a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> a constant scalar to tile argument.  <a href="group___tile_interface.html#gaacad2b52ab350044c8742ec1eef39a0b">More...</a><br /></td></tr>
<tr class="separator:gaacad2b52ab350044c8742ec1eef39a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ebf7e70f210f2b21cee72c55742682"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85ebf7e70f210f2b21cee72c55742682"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga85ebf7e70f210f2b21cee72c55742682">add</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga85ebf7e70f210f2b21cee72c55742682"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> a constant scalar and permute tile argument.  <a href="group___tile_interface.html#ga85ebf7e70f210f2b21cee72c55742682">More...</a><br /></td></tr>
<tr class="separator:ga85ebf7e70f210f2b21cee72c55742682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> to the result tile.  <a href="group___tile_interface.html#ga5eaf2e2efc1f2ca1fca6e5e2fcee256e">More...</a><br /></td></tr>
<tr class="separator:ga5eaf2e2efc1f2ca1fca6e5e2fcee256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dabb8dd35f758019c80da238cf50196"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6dabb8dd35f758019c80da238cf50196"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6dabb8dd35f758019c80da238cf50196">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga6dabb8dd35f758019c80da238cf50196"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and scale to the result tile.  <a href="group___tile_interface.html#ga6dabb8dd35f758019c80da238cf50196">More...</a><br /></td></tr>
<tr class="separator:ga6dabb8dd35f758019c80da238cf50196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0887904f4fbb716dec1467ff37bcdef6">add_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:ga0887904f4fbb716dec1467ff37bcdef6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> constant scalar to the result tile.  <a href="group___tile_interface.html#ga0887904f4fbb716dec1467ff37bcdef6">More...</a><br /></td></tr>
<tr class="separator:ga0887904f4fbb716dec1467ff37bcdef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d10685bc8b980fed30a5e64db19caa"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga58d10685bc8b980fed30a5e64db19caa"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga58d10685bc8b980fed30a5e64db19caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tile arguments.  <a href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa">More...</a><br /></td></tr>
<tr class="separator:ga58d10685bc8b980fed30a5e64db19caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad477a9e151bd7d6bb29dacda947c83aa"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gad477a9e151bd7d6bb29dacda947c83aa"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad477a9e151bd7d6bb29dacda947c83aa">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:gad477a9e151bd7d6bb29dacda947c83aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale tile arguments.  <a href="group___tile_interface.html#gad477a9e151bd7d6bb29dacda947c83aa">More...</a><br /></td></tr>
<tr class="separator:gad477a9e151bd7d6bb29dacda947c83aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6001c9bb75a0f12d0b5e5cb4375d068e"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga6001c9bb75a0f12d0b5e5cb4375d068e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6001c9bb75a0f12d0b5e5cb4375d068e">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga6001c9bb75a0f12d0b5e5cb4375d068e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and permute tile arguments.  <a href="group___tile_interface.html#ga6001c9bb75a0f12d0b5e5cb4375d068e">More...</a><br /></td></tr>
<tr class="separator:ga6001c9bb75a0f12d0b5e5cb4375d068e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b7a992252791394d580b193acb43b3"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga00b7a992252791394d580b193acb43b3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga00b7a992252791394d580b193acb43b3">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga00b7a992252791394d580b193acb43b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga00b7a992252791394d580b193acb43b3">More...</a><br /></td></tr>
<tr class="separator:ga00b7a992252791394d580b193acb43b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac48dff1fb3c32301f8a1d970dd28a447"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac48dff1fb3c32301f8a1d970dd28a447"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac48dff1fb3c32301f8a1d970dd28a447">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value)</td></tr>
<tr class="memdesc:gac48dff1fb3c32301f8a1d970dd28a447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar constant from the tile argument.  <a href="group___tile_interface.html#gac48dff1fb3c32301f8a1d970dd28a447">More...</a><br /></td></tr>
<tr class="separator:gac48dff1fb3c32301f8a1d970dd28a447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269c4639b855a71a8fb3571043f795e0"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga269c4639b855a71a8fb3571043f795e0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga269c4639b855a71a8fb3571043f795e0">subt</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga269c4639b855a71a8fb3571043f795e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant scalar and permute tile argument.  <a href="group___tile_interface.html#ga269c4639b855a71a8fb3571043f795e0">More...</a><br /></td></tr>
<tr class="separator:ga269c4639b855a71a8fb3571043f795e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b0fd498d81c2a5898673bcb0152934"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga67b0fd498d81c2a5898673bcb0152934"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga67b0fd498d81c2a5898673bcb0152934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from the result tile.  <a href="group___tile_interface.html#ga67b0fd498d81c2a5898673bcb0152934">More...</a><br /></td></tr>
<tr class="separator:ga67b0fd498d81c2a5898673bcb0152934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3857edf071769c169d08af65690063eb"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3857edf071769c169d08af65690063eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga3857edf071769c169d08af65690063eb">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga3857edf071769c169d08af65690063eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale from the result tile.  <a href="group___tile_interface.html#ga3857edf071769c169d08af65690063eb">More...</a><br /></td></tr>
<tr class="separator:ga3857edf071769c169d08af65690063eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7653e81aa69141646e7c93b916fadb"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gafc7653e81aa69141646e7c93b916fadb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gafc7653e81aa69141646e7c93b916fadb">subt_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:gafc7653e81aa69141646e7c93b916fadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract constant scalar from the result tile.  <a href="group___tile_interface.html#gafc7653e81aa69141646e7c93b916fadb">More...</a><br /></td></tr>
<tr class="separator:gafc7653e81aa69141646e7c93b916fadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication tile arguments.  <a href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40">More...</a><br /></td></tr>
<tr class="separator:gaf465d9c7b7f7d31918a6150c9d51ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga27e2e80dcf97b3ad64e8797e2226a432">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and scale tile arguments.  <a href="group___tile_interface.html#ga27e2e80dcf97b3ad64e8797e2226a432">More...</a><br /></td></tr>
<tr class="separator:ga27e2e80dcf97b3ad64e8797e2226a432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4099da80affc5df463c51f772f797d8"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gad4099da80affc5df463c51f772f797d8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad4099da80affc5df463c51f772f797d8">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gad4099da80affc5df463c51f772f797d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and permute tile arguments.  <a href="group___tile_interface.html#gad4099da80affc5df463c51f772f797d8">More...</a><br /></td></tr>
<tr class="separator:gad4099da80affc5df463c51f772f797d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ddd7a2825993e72a5bb1dc8a84df73"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga95ddd7a2825993e72a5bb1dc8a84df73"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga95ddd7a2825993e72a5bb1dc8a84df73">mult</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga95ddd7a2825993e72a5bb1dc8a84df73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication, scale, and permute tile arguments.  <a href="group___tile_interface.html#ga95ddd7a2825993e72a5bb1dc8a84df73">More...</a><br /></td></tr>
<tr class="separator:ga95ddd7a2825993e72a5bb1dc8a84df73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37039529fef4c507e5e5ecf379edf38"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:gad37039529fef4c507e5e5ecf379edf38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">mult_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gad37039529fef4c507e5e5ecf379edf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply to the result tile.  <a href="group___tile_interface.html#gad37039529fef4c507e5e5ecf379edf38">More...</a><br /></td></tr>
<tr class="separator:gad37039529fef4c507e5e5ecf379edf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaff6e36fcc141764f788ab1eb59965a8c">mult_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gaff6e36fcc141764f788ab1eb59965a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and scale to the result tile.  <a href="group___tile_interface.html#gaff6e36fcc141764f788ab1eb59965a8c">More...</a><br /></td></tr>
<tr class="separator:gaff6e36fcc141764f788ab1eb59965a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe37fcda193946fcc4501b42796e9cc"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaebe37fcda193946fcc4501b42796e9cc"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc">scale</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gaebe37fcda193946fcc4501b42796e9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar the tile argument.  <a href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc">More...</a><br /></td></tr>
<tr class="separator:gaebe37fcda193946fcc4501b42796e9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6392661ca9c2d8e995e3b9f77fa54d6b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6392661ca9c2d8e995e3b9f77fa54d6b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6392661ca9c2d8e995e3b9f77fa54d6b">scale</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga6392661ca9c2d8e995e3b9f77fa54d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> and permute tile argument.  <a href="group___tile_interface.html#ga6392661ca9c2d8e995e3b9f77fa54d6b">More...</a><br /></td></tr>
<tr class="separator:ga6392661ca9c2d8e995e3b9f77fa54d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga381f8c925fdcfdee5cfef07f66c4da25">scale_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> to the result tile.  <a href="group___tile_interface.html#ga381f8c925fdcfdee5cfef07f66c4da25">More...</a><br /></td></tr>
<tr class="separator:ga381f8c925fdcfdee5cfef07f66c4da25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd5665b8e247cd53460501c3f672751"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga6bd5665b8e247cd53460501c3f672751"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751">neg</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga6bd5665b8e247cd53460501c3f672751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the tile argument.  <a href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751">More...</a><br /></td></tr>
<tr class="separator:ga6bd5665b8e247cd53460501c3f672751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ae23d7dae957803f4d65404e15fc6a"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga58ae23d7dae957803f4d65404e15fc6a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga58ae23d7dae957803f4d65404e15fc6a">neg</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga58ae23d7dae957803f4d65404e15fc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate and permute tile argument.  <a href="group___tile_interface.html#ga58ae23d7dae957803f4d65404e15fc6a">More...</a><br /></td></tr>
<tr class="separator:ga58ae23d7dae957803f4d65404e15fc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">neg_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result)</td></tr>
<tr class="memdesc:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication constant scalar to a tile.  <a href="group___tile_interface.html#ga7f07b2f0fde49f0f04284bc3f6de3db4">More...</a><br /></td></tr>
<tr class="separator:ga7f07b2f0fde49f0f04284bc3f6de3db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of a tile.  <a href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f">More...</a><br /></td></tr>
<tr class="separator:ga4d7a9a1250ba51b27addd91171a1c77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18ac642dbdbed016061d5cc969ffa2a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac18ac642dbdbed016061d5cc969ffa2a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac18ac642dbdbed016061d5cc969ffa2a">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gac18ac642dbdbed016061d5cc969ffa2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of a tile.  <a href="group___tile_interface.html#gac18ac642dbdbed016061d5cc969ffa2a">More...</a><br /></td></tr>
<tr class="separator:gac18ac642dbdbed016061d5cc969ffa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab7e50a45bf9140894520762a2708a4"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga4ab7e50a45bf9140894520762a2708a4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4ab7e50a45bf9140894520762a2708a4">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga4ab7e50a45bf9140894520762a2708a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of a tile.  <a href="group___tile_interface.html#ga4ab7e50a45bf9140894520762a2708a4">More...</a><br /></td></tr>
<tr class="separator:ga4ab7e50a45bf9140894520762a2708a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae921c315aa207ef9c2359389e0d7bb4b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae921c315aa207ef9c2359389e0d7bb4b"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gae921c315aa207ef9c2359389e0d7bb4b">conj</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gae921c315aa207ef9c2359389e0d7bb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of a tile.  <a href="group___tile_interface.html#gae921c315aa207ef9c2359389e0d7bb4b">More...</a><br /></td></tr>
<tr class="separator:gae921c315aa207ef9c2359389e0d7bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fd187f7e500ab8977032e67537b92a"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:gad2fd187f7e500ab8977032e67537b92a"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad2fd187f7e500ab8977032e67537b92a">conj_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result)</td></tr>
<tr class="memdesc:gad2fd187f7e500ab8977032e67537b92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate a tile.  <a href="group___tile_interface.html#gad2fd187f7e500ab8977032e67537b92a">More...</a><br /></td></tr>
<tr class="separator:gad2fd187f7e500ab8977032e67537b92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf81db8c2648b13dd9ded3b54bcefa4e1">conj_to</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate and scale a tile.  <a href="group___tile_interface.html#gaf81db8c2648b13dd9ded3b54bcefa4e1">More...</a><br /></td></tr>
<tr class="separator:gaf81db8c2648b13dd9ded3b54bcefa4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3a08fa940b7d1c314327430c604238"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f3a08fa940b7d1c314327430c604238"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238">gemm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga1f3a08fa940b7d1c314327430c604238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments.  <a href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238">More...</a><br /></td></tr>
<tr class="separator:ga1f3a08fa940b7d1c314327430c604238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5cd5e3e8121313e9684e91cfa6230fd6">gemm</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Result &gt; &amp;result, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments to the result tile.  <a href="group___tile_interface.html#ga5cd5e3e8121313e9684e91cfa6230fd6">More...</a><br /></td></tr>
<tr class="separator:ga5cd5e3e8121313e9684e91cfa6230fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga72bc37c3b1bcb1f5bb7f630667243615">trace</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the hyper-diagonal elements a tile.  <a href="group___tile_interface.html#ga72bc37c3b1bcb1f5bb7f630667243615">More...</a><br /></td></tr>
<tr class="separator:ga72bc37c3b1bcb1f5bb7f630667243615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga25d9a467ed3849aacaab335e5eb2ed57">sum</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the elements of a tile.  <a href="group___tile_interface.html#ga25d9a467ed3849aacaab335e5eb2ed57">More...</a><br /></td></tr>
<tr class="separator:ga25d9a467ed3849aacaab335e5eb2ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada89177095dd6a757f26e7c45f3798b0"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gada89177095dd6a757f26e7c45f3798b0"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gada89177095dd6a757f26e7c45f3798b0">product</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gada89177095dd6a757f26e7c45f3798b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements of a tile.  <a href="group___tile_interface.html#gada89177095dd6a757f26e7c45f3798b0">More...</a><br /></td></tr>
<tr class="separator:gada89177095dd6a757f26e7c45f3798b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0367bc300cd4417138d2ac139048c234"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga0367bc300cd4417138d2ac139048c234"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234">squared_norm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga0367bc300cd4417138d2ac139048c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared vector 2-norm of the elements of a tile.  <a href="group___tile_interface.html#ga0367bc300cd4417138d2ac139048c234">More...</a><br /></td></tr>
<tr class="separator:ga0367bc300cd4417138d2ac139048c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6">norm</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6">More...</a><br /></td></tr>
<tr class="separator:gaf68ae245fa13091be35fcc8cad8b2ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace24afac354bfe849d2ca90df6ab8232"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gace24afac354bfe849d2ca90df6ab8232"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gace24afac354bfe849d2ca90df6ab8232">max</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gace24afac354bfe849d2ca90df6ab8232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element of a tile.  <a href="group___tile_interface.html#gace24afac354bfe849d2ca90df6ab8232">More...</a><br /></td></tr>
<tr class="separator:gace24afac354bfe849d2ca90df6ab8232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d977af50ab495f09a985dbfb871a3d"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gad4d977af50ab495f09a985dbfb871a3d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad4d977af50ab495f09a985dbfb871a3d">min</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gad4d977af50ab495f09a985dbfb871a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element of a tile.  <a href="group___tile_interface.html#gad4d977af50ab495f09a985dbfb871a3d">More...</a><br /></td></tr>
<tr class="separator:gad4d977af50ab495f09a985dbfb871a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86214f440122e8aac85a93dce17e0d7d"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga86214f440122e8aac85a93dce17e0d7d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d">abs_max</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:ga86214f440122e8aac85a93dce17e0d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element of a tile.  <a href="group___tile_interface.html#ga86214f440122e8aac85a93dce17e0d7d">More...</a><br /></td></tr>
<tr class="separator:ga86214f440122e8aac85a93dce17e0d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd">abs_min</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute mainimum element of a tile.  <a href="group___tile_interface.html#gac89ec1d5bad433cb8a9ee8612a6d88fd">More...</a><br /></td></tr>
<tr class="separator:gac89ec1d5bad433cb8a9ee8612a6d88fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71813b13896a29698efff4232719d70"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gaf71813b13896a29698efff4232719d70"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70">dot</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gaf71813b13896a29698efff4232719d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product of a tile.  <a href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70">More...</a><br /></td></tr>
<tr class="separator:gaf71813b13896a29698efff4232719d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dfbc65d2ed3c0ed3358380eba985255"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga3dfbc65d2ed3c0ed3358380eba985255"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga3dfbc65d2ed3c0ed3358380eba985255">operator+</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga3dfbc65d2ed3c0ed3358380eba985255"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> tiles operator.  <a href="group___tile_interface.html#ga3dfbc65d2ed3c0ed3358380eba985255">More...</a><br /></td></tr>
<tr class="separator:ga3dfbc65d2ed3c0ed3358380eba985255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7bcee0014e3c777ff47264fea368e2d"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gae7bcee0014e3c777ff47264fea368e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gae7bcee0014e3c777ff47264fea368e2d">operator+=</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gae7bcee0014e3c777ff47264fea368e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place add tile operator.  <a href="group___tile_interface.html#gae7bcee0014e3c777ff47264fea368e2d">More...</a><br /></td></tr>
<tr class="separator:gae7bcee0014e3c777ff47264fea368e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d64e9ef0fbeb7c776f5ce6a2d74d3e9"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga3d64e9ef0fbeb7c776f5ce6a2d74d3e9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga3d64e9ef0fbeb7c776f5ce6a2d74d3e9">operator-</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga3d64e9ef0fbeb7c776f5ce6a2d74d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tiles operator.  <a href="group___tile_interface.html#ga3d64e9ef0fbeb7c776f5ce6a2d74d3e9">More...</a><br /></td></tr>
<tr class="separator:ga3d64e9ef0fbeb7c776f5ce6a2d74d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga4f4e0878d1128d2b692b6a8e60113c28">operator-=</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place subtract tile operator.  <a href="group___tile_interface.html#ga4f4e0878d1128d2b692b6a8e60113c28">More...</a><br /></td></tr>
<tr class="separator:ga4f4e0878d1128d2b692b6a8e60113c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafac66355a32046043fc0d55da53486"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gacafac66355a32046043fc0d55da53486"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gacafac66355a32046043fc0d55da53486">operator*</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gacafac66355a32046043fc0d55da53486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product tiles operator.  <a href="group___tile_interface.html#gacafac66355a32046043fc0d55da53486">More...</a><br /></td></tr>
<tr class="separator:gacafac66355a32046043fc0d55da53486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad452632b571bcbcc3be78b202e8a0a75"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename std::enable_if&lt; detail::is_numeric&lt; Right &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gad452632b571bcbcc3be78b202e8a0a75"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gad452632b571bcbcc3be78b202e8a0a75">operator*</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const Right right)</td></tr>
<tr class="memdesc:gad452632b571bcbcc3be78b202e8a0a75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> tile operator.  <a href="group___tile_interface.html#gad452632b571bcbcc3be78b202e8a0a75">More...</a><br /></td></tr>
<tr class="separator:gad452632b571bcbcc3be78b202e8a0a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace4d1e1040c172349f20582057ab7114"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Left &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gace4d1e1040c172349f20582057ab7114"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gace4d1e1040c172349f20582057ab7114">operator*</a> (const Left left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:gace4d1e1040c172349f20582057ab7114"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> tile operator.  <a href="group___tile_interface.html#gace4d1e1040c172349f20582057ab7114">More...</a><br /></td></tr>
<tr class="separator:gace4d1e1040c172349f20582057ab7114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40462eb6de7951619ea2f31b310920de"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga40462eb6de7951619ea2f31b310920de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga40462eb6de7951619ea2f31b310920de">operator*=</a> (<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Left &gt; &amp;left, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:ga40462eb6de7951619ea2f31b310920de"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place product tile operator.  <a href="group___tile_interface.html#ga40462eb6de7951619ea2f31b310920de">More...</a><br /></td></tr>
<tr class="separator:ga40462eb6de7951619ea2f31b310920de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf4c181f142aaa5adb2057bfb8b6027"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaebf4c181f142aaa5adb2057bfb8b6027"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gaebf4c181f142aaa5adb2057bfb8b6027">operator-</a> (const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; &amp;arg)</td></tr>
<tr class="memdesc:gaebf4c181f142aaa5adb2057bfb8b6027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate tile operator.  <a href="group___tile_interface.html#gaebf4c181f142aaa5adb2057bfb8b6027">More...</a><br /></td></tr>
<tr class="separator:gaebf4c181f142aaa5adb2057bfb8b6027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5617e099b3bb93c7f6d0bf98e89e5a4e"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga5617e099b3bb93c7f6d0bf98e89e5a4e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#ga5617e099b3bb93c7f6d0bf98e89e5a4e">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; Arg &gt; const arg)</td></tr>
<tr class="memdesc:ga5617e099b3bb93c7f6d0bf98e89e5a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile. ">Permute</a> tile operator.  <a href="group___tile_interface.html#ga5617e099b3bb93c7f6d0bf98e89e5a4e">More...</a><br /></td></tr>
<tr class="separator:ga5617e099b3bb93c7f6d0bf98e89e5a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07ca3ab32da77765c0546689feb400f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac07ca3ab32da77765c0546689feb400f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tile_interface.html#gac07ca3ab32da77765c0546689feb400f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T &gt; &amp;tile)</td></tr>
<tr class="memdesc:gac07ca3ab32da77765c0546689feb400f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> output stream operator.  <a href="group___tile_interface.html#gac07ca3ab32da77765c0546689feb400f">More...</a><br /></td></tr>
<tr class="separator:gac07ca3ab32da77765c0546689feb400f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a87ca6bca2735b62e0eaf5cac4a3cba58">add</a> (const Left &amp;left, const Right &amp;right) -&gt; decltype(left.add(right))</td></tr>
<tr class="memdesc:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> tile arguments.  <a href="#a87ca6bca2735b62e0eaf5cac4a3cba58">More...</a><br /></td></tr>
<tr class="separator:a87ca6bca2735b62e0eaf5cac4a3cba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f55826b650600d7dbea2e362f5520c6"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3f55826b650600d7dbea2e362f5520c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3f55826b650600d7dbea2e362f5520c6">add</a> (const Left &amp;left, const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:a3f55826b650600d7dbea2e362f5520c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and scale tile arguments.  <a href="#a3f55826b650600d7dbea2e362f5520c6">More...</a><br /></td></tr>
<tr class="separator:a3f55826b650600d7dbea2e362f5520c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30324227880aa0d22114f89c3fafe96"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:aa30324227880aa0d22114f89c3fafe96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aa30324227880aa0d22114f89c3fafe96">add</a> (const Left &amp;left, const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aa30324227880aa0d22114f89c3fafe96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and permute tile arguments.  <a href="#aa30324227880aa0d22114f89c3fafe96">More...</a><br /></td></tr>
<tr class="separator:aa30324227880aa0d22114f89c3fafe96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860bc6cc248f9358d15b0989ef35350f"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a860bc6cc248f9358d15b0989ef35350f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a860bc6cc248f9358d15b0989ef35350f">add</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a860bc6cc248f9358d15b0989ef35350f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a>, scale, and permute tile arguments.  <a href="#a860bc6cc248f9358d15b0989ef35350f">More...</a><br /></td></tr>
<tr class="separator:a860bc6cc248f9358d15b0989ef35350f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b6f318b11b3abb7986751995a880d0"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:af7b6f318b11b3abb7986751995a880d0"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#af7b6f318b11b3abb7986751995a880d0">add_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:af7b6f318b11b3abb7986751995a880d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> to the result tile.  <a href="#af7b6f318b11b3abb7986751995a880d0">More...</a><br /></td></tr>
<tr class="separator:af7b6f318b11b3abb7986751995a880d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ec71822bfc6ea2da939913f8ee8f02"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a17ec71822bfc6ea2da939913f8ee8f02"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a17ec71822bfc6ea2da939913f8ee8f02">add_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:a17ec71822bfc6ea2da939913f8ee8f02"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and scale to the result tile.  <a href="#a17ec71822bfc6ea2da939913f8ee8f02">More...</a><br /></td></tr>
<tr class="separator:a17ec71822bfc6ea2da939913f8ee8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf3ee231866723665a23c1669e4c754"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Result  = typename TiledArray::eval_trait&lt;std::decay_t&lt;Arg&gt;&gt;::type&gt; </td></tr>
<tr class="memitem:a4bf3ee231866723665a23c1669e4c754"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4bf3ee231866723665a23c1669e4c754">invoke_cast</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a4bf3ee231866723665a23c1669e4c754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead4454c3584b960202d2390a0139c33"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aead4454c3584b960202d2390a0139c33"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#aead4454c3584b960202d2390a0139c33">clone</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:aead4454c3584b960202d2390a0139c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of <code>arg</code>.  <a href="#aead4454c3584b960202d2390a0139c33">More...</a><br /></td></tr>
<tr class="separator:aead4454c3584b960202d2390a0139c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d88c1636531adbd9b9aac5ead3f3e0e"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a9d88c1636531adbd9b9aac5ead3f3e0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9d88c1636531adbd9b9aac5ead3f3e0e">permute</a> (const Arg &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a9d88c1636531adbd9b9aac5ead3f3e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of <code>arg</code>.  <a href="#a9d88c1636531adbd9b9aac5ead3f3e0e">More...</a><br /></td></tr>
<tr class="separator:a9d88c1636531adbd9b9aac5ead3f3e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#acf92d0f99f726bc096fe6e7c6a6bee7b">scale</a> (const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar the tile argument.  <a href="#acf92d0f99f726bc096fe6e7c6a6bee7b">More...</a><br /></td></tr>
<tr class="separator:acf92d0f99f726bc096fe6e7c6a6bee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4cf3997e177142f13f593335352b48"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b4cf3997e177142f13f593335352b48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3b4cf3997e177142f13f593335352b48">scale</a> (const Arg &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:a3b4cf3997e177142f13f593335352b48"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> and permute tile argument.  <a href="#a3b4cf3997e177142f13f593335352b48">More...</a><br /></td></tr>
<tr class="separator:a3b4cf3997e177142f13f593335352b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10222cde45203777a4b3a6dc2d2d72d"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac10222cde45203777a4b3a6dc2d2d72d"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac10222cde45203777a4b3a6dc2d2d72d">scale_to</a> (Result &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ac10222cde45203777a4b3a6dc2d2d72d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> to the result tile.  <a href="#ac10222cde45203777a4b3a6dc2d2d72d">More...</a><br /></td></tr>
<tr class="separator:ac10222cde45203777a4b3a6dc2d2d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c36d711dfadf00bc96c9f10bde6776"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:a18c36d711dfadf00bc96c9f10bde6776"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a18c36d711dfadf00bc96c9f10bde6776">shift</a> (const Arg &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:a18c36d711dfadf00bc96c9f10bde6776"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of <code>arg</code>.  <a href="#a18c36d711dfadf00bc96c9f10bde6776">More...</a><br /></td></tr>
<tr class="separator:a18c36d711dfadf00bc96c9f10bde6776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3cfd4f0d7939415e0c5455f6dd36c2"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Index &gt; </td></tr>
<tr class="memitem:a7d3cfd4f0d7939415e0c5455f6dd36c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a7d3cfd4f0d7939415e0c5455f6dd36c2">shift_to</a> (Arg &amp;arg, const Index &amp;range_shift)</td></tr>
<tr class="memdesc:a7d3cfd4f0d7939415e0c5455f6dd36c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of <code>arg</code> in place.  <a href="#a7d3cfd4f0d7939415e0c5455f6dd36c2">More...</a><br /></td></tr>
<tr class="separator:a7d3cfd4f0d7939415e0c5455f6dd36c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e30a38677b11760448ab87f07ff0aed"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga9e30a38677b11760448ab87f07ff0aed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga9e30a38677b11760448ab87f07ff0aed">empty</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga9e30a38677b11760448ab87f07ff0aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that <code>arg</code> is empty (no data)  <a href="group___non_intrusive_tile_interface.html#ga9e30a38677b11760448ab87f07ff0aed">More...</a><br /></td></tr>
<tr class="separator:ga9e30a38677b11760448ab87f07ff0aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868fcf578c023fc98e1f46cd50266d04"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga868fcf578c023fc98e1f46cd50266d04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga868fcf578c023fc98e1f46cd50266d04">subt</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:ga868fcf578c023fc98e1f46cd50266d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga868fcf578c023fc98e1f46cd50266d04">More...</a><br /></td></tr>
<tr class="separator:ga868fcf578c023fc98e1f46cd50266d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gac59cfe02cb4e608cdaaa2beb43b97306">subt</a> (const Left &amp;left, const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#gac59cfe02cb4e608cdaaa2beb43b97306">More...</a><br /></td></tr>
<tr class="separator:gac59cfe02cb4e608cdaaa2beb43b97306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775aec1199baed6d38684898a9448c36"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga775aec1199baed6d38684898a9448c36"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga775aec1199baed6d38684898a9448c36">subt</a> (const Left &amp;left, const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga775aec1199baed6d38684898a9448c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga775aec1199baed6d38684898a9448c36">More...</a><br /></td></tr>
<tr class="separator:ga775aec1199baed6d38684898a9448c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d3fdaa3293d9115c0c3d4856b4a83f5"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1d3fdaa3293d9115c0c3d4856b4a83f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1d3fdaa3293d9115c0c3d4856b4a83f5">subt</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga1d3fdaa3293d9115c0c3d4856b4a83f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract, scale, and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga1d3fdaa3293d9115c0c3d4856b4a83f5">More...</a><br /></td></tr>
<tr class="separator:ga1d3fdaa3293d9115c0c3d4856b4a83f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0100e842082acfc8fba40823d1e29c93"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0100e842082acfc8fba40823d1e29c93"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga0100e842082acfc8fba40823d1e29c93">subt</a> (const Arg &amp;arg, const Scalar value)</td></tr>
<tr class="memdesc:ga0100e842082acfc8fba40823d1e29c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a scalar constant from the tile argument.  <a href="group___non_intrusive_tile_interface.html#ga0100e842082acfc8fba40823d1e29c93">More...</a><br /></td></tr>
<tr class="separator:ga0100e842082acfc8fba40823d1e29c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc3769b8e18ea4fb8924b8af774af12"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1bc3769b8e18ea4fb8924b8af774af12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1bc3769b8e18ea4fb8924b8af774af12">subt</a> (const Arg &amp;arg, const Scalar value, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga1bc3769b8e18ea4fb8924b8af774af12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract a constant scalar and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#ga1bc3769b8e18ea4fb8924b8af774af12">More...</a><br /></td></tr>
<tr class="separator:ga1bc3769b8e18ea4fb8924b8af774af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga6433ca823a7f563abbb980b72ee6dba3">subt_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga6433ca823a7f563abbb980b72ee6dba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract from the result tile.  <a href="group___non_intrusive_tile_interface.html#ga6433ca823a7f563abbb980b72ee6dba3">More...</a><br /></td></tr>
<tr class="separator:ga6433ca823a7f563abbb980b72ee6dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5666748f9fda3e3173eac160328bd5c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gab5666748f9fda3e3173eac160328bd5c"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gab5666748f9fda3e3173eac160328bd5c">subt_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:gab5666748f9fda3e3173eac160328bd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract and scale from the result tile.  <a href="group___non_intrusive_tile_interface.html#gab5666748f9fda3e3173eac160328bd5c">More...</a><br /></td></tr>
<tr class="separator:gab5666748f9fda3e3173eac160328bd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae3c0183d91fdc7febc0aac4e0f929d97">subt_to</a> (Result &amp;result, const Scalar value)</td></tr>
<tr class="memdesc:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract constant scalar from the result tile.  <a href="group___non_intrusive_tile_interface.html#gae3c0183d91fdc7febc0aac4e0f929d97">More...</a><br /></td></tr>
<tr class="separator:gae3c0183d91fdc7febc0aac4e0f929d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efde56a873ec888fe91db82e336ddff"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga2efde56a873ec888fe91db82e336ddff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga2efde56a873ec888fe91db82e336ddff">mult</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:ga2efde56a873ec888fe91db82e336ddff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga2efde56a873ec888fe91db82e336ddff">More...</a><br /></td></tr>
<tr class="separator:ga2efde56a873ec888fe91db82e336ddff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02de75c65c05021e1d3b65f60d839a80"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga02de75c65c05021e1d3b65f60d839a80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga02de75c65c05021e1d3b65f60d839a80">mult</a> (const Left &amp;left, const Right &amp;right, const Scalar factor)</td></tr>
<tr class="memdesc:ga02de75c65c05021e1d3b65f60d839a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga02de75c65c05021e1d3b65f60d839a80">More...</a><br /></td></tr>
<tr class="separator:ga02de75c65c05021e1d3b65f60d839a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad86cacb2ae3387c4f5b357288201cbd3"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gad86cacb2ae3387c4f5b357288201cbd3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gad86cacb2ae3387c4f5b357288201cbd3">mult</a> (const Left &amp;left, const Right &amp;right, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gad86cacb2ae3387c4f5b357288201cbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#gad86cacb2ae3387c4f5b357288201cbd3">More...</a><br /></td></tr>
<tr class="separator:gad86cacb2ae3387c4f5b357288201cbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ae9814b4ff080f0aa5b27ddfdbfb12"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga34ae9814b4ff080f0aa5b27ddfdbfb12"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga34ae9814b4ff080f0aa5b27ddfdbfb12">mult</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga34ae9814b4ff080f0aa5b27ddfdbfb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication, scale, and permute tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga34ae9814b4ff080f0aa5b27ddfdbfb12">More...</a><br /></td></tr>
<tr class="separator:ga34ae9814b4ff080f0aa5b27ddfdbfb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d5fd9f983b98c143a694fa82166585"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg &gt; </td></tr>
<tr class="memitem:gaf8d5fd9f983b98c143a694fa82166585"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaf8d5fd9f983b98c143a694fa82166585">mult_to</a> (Result &amp;result, const Arg &amp;arg)</td></tr>
<tr class="memdesc:gaf8d5fd9f983b98c143a694fa82166585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply to the result tile.  <a href="group___non_intrusive_tile_interface.html#gaf8d5fd9f983b98c143a694fa82166585">More...</a><br /></td></tr>
<tr class="separator:gaf8d5fd9f983b98c143a694fa82166585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5b9a07027db87b4785e7e9f2f31cc567">mult_to</a> (Result &amp;result, const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and scale to the result tile.  <a href="group___non_intrusive_tile_interface.html#ga5b9a07027db87b4785e7e9f2f31cc567">More...</a><br /></td></tr>
<tr class="separator:ga5b9a07027db87b4785e7e9f2f31cc567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga930711d2b817ac11c592fa3dd90fbbbb">neg</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate the tile argument.  <a href="group___non_intrusive_tile_interface.html#ga930711d2b817ac11c592fa3dd90fbbbb">More...</a><br /></td></tr>
<tr class="separator:ga930711d2b817ac11c592fa3dd90fbbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff50a32d372aa198ba0811cd03cb7bc1"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gaff50a32d372aa198ba0811cd03cb7bc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gaff50a32d372aa198ba0811cd03cb7bc1">neg</a> (const Arg &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gaff50a32d372aa198ba0811cd03cb7bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate and permute tile argument.  <a href="group___non_intrusive_tile_interface.html#gaff50a32d372aa198ba0811cd03cb7bc1">More...</a><br /></td></tr>
<tr class="separator:gaff50a32d372aa198ba0811cd03cb7bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga0983dfc5809ebfca2de350b5bf42dca0">neg_to</a> (Result &amp;result)</td></tr>
<tr class="memdesc:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication constant scalar to a tile.  <a href="group___non_intrusive_tile_interface.html#ga0983dfc5809ebfca2de350b5bf42dca0">More...</a><br /></td></tr>
<tr class="separator:ga0983dfc5809ebfca2de350b5bf42dca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada05b20133963ad39dd26f45588a69a3"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gada05b20133963ad39dd26f45588a69a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gada05b20133963ad39dd26f45588a69a3">conj</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gada05b20133963ad39dd26f45588a69a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated copy of a tile.  <a href="group___non_intrusive_tile_interface.html#gada05b20133963ad39dd26f45588a69a3">More...</a><br /></td></tr>
<tr class="separator:gada05b20133963ad39dd26f45588a69a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b703fbc17b07716f36468a174327013"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3b703fbc17b07716f36468a174327013"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga3b703fbc17b07716f36468a174327013">conj</a> (const Arg &amp;arg, const Scalar factor)</td></tr>
<tr class="memdesc:ga3b703fbc17b07716f36468a174327013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and scaled copy of a tile.  <a href="group___non_intrusive_tile_interface.html#ga3b703fbc17b07716f36468a174327013">More...</a><br /></td></tr>
<tr class="separator:ga3b703fbc17b07716f36468a174327013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148c8560d364697a4cb6b9c86faf4d75"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga148c8560d364697a4cb6b9c86faf4d75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga148c8560d364697a4cb6b9c86faf4d75">conj</a> (const Arg &amp;arg, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:ga148c8560d364697a4cb6b9c86faf4d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated and permuted copy of a tile.  <a href="group___non_intrusive_tile_interface.html#ga148c8560d364697a4cb6b9c86faf4d75">More...</a><br /></td></tr>
<tr class="separator:ga148c8560d364697a4cb6b9c86faf4d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c5e813908354faefc7b766d857b667"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:gad2c5e813908354faefc7b766d857b667"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gad2c5e813908354faefc7b766d857b667">conj</a> (const Arg &amp;arg, const Scalar factor, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:gad2c5e813908354faefc7b766d857b667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complex conjugated, scaled, and permuted copy of a tile.  <a href="group___non_intrusive_tile_interface.html#gad2c5e813908354faefc7b766d857b667">More...</a><br /></td></tr>
<tr class="separator:gad2c5e813908354faefc7b766d857b667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga65b3ee6f080b8a842bba1e7a56afb794">conj_to</a> (Result &amp;result)</td></tr>
<tr class="memdesc:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate a tile.  <a href="group___non_intrusive_tile_interface.html#ga65b3ee6f080b8a842bba1e7a56afb794">More...</a><br /></td></tr>
<tr class="separator:ga65b3ee6f080b8a842bba1e7a56afb794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5e2f551d8e19e04b8fa91c6a0da7d18c">conj_to</a> (Result &amp;result, const Scalar factor)</td></tr>
<tr class="memdesc:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place complex conjugate and scale a tile.  <a href="group___non_intrusive_tile_interface.html#ga5e2f551d8e19e04b8fa91c6a0da7d18c">More...</a><br /></td></tr>
<tr class="separator:ga5e2f551d8e19e04b8fa91c6a0da7d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga5e87c8a7fa49e53b50d97debf41e5d23">gemm</a> (const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments.  <a href="group___non_intrusive_tile_interface.html#ga5e87c8a7fa49e53b50d97debf41e5d23">More...</a><br /></td></tr>
<tr class="separator:ga5e87c8a7fa49e53b50d97debf41e5d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb5f80c0b106673576299ae702e129"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Left , typename Right , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7fcb5f80c0b106673576299ae702e129"><td class="memTemplItemLeft" align="right" valign="top">Result &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga7fcb5f80c0b106673576299ae702e129">gemm</a> (Result &amp;result, const Left &amp;left, const Right &amp;right, const Scalar factor, const <a class="el" href="class_tiled_array_1_1math_1_1_gemm_helper.html">math::GemmHelper</a> &amp;gemm_config)</td></tr>
<tr class="memdesc:ga7fcb5f80c0b106673576299ae702e129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and scale tile arguments to the result tile.  <a href="group___non_intrusive_tile_interface.html#ga7fcb5f80c0b106673576299ae702e129">More...</a><br /></td></tr>
<tr class="separator:ga7fcb5f80c0b106673576299ae702e129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27132e1a22dd756c661e1c4be64caca2"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga27132e1a22dd756c661e1c4be64caca2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga27132e1a22dd756c661e1c4be64caca2">trace</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga27132e1a22dd756c661e1c4be64caca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the hyper-diagonal elements a tile.  <a href="group___non_intrusive_tile_interface.html#ga27132e1a22dd756c661e1c4be64caca2">More...</a><br /></td></tr>
<tr class="separator:ga27132e1a22dd756c661e1c4be64caca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gae38e8020fe61d4fb17a6ce37af5a9c41">sum</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#gae38e8020fe61d4fb17a6ce37af5a9c41">More...</a><br /></td></tr>
<tr class="separator:gae38e8020fe61d4fb17a6ce37af5a9c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga194ee4ec9d248e4cb2a0e0965be39ad3">product</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#ga194ee4ec9d248e4cb2a0e0965be39ad3">More...</a><br /></td></tr>
<tr class="separator:ga194ee4ec9d248e4cb2a0e0965be39ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338752778aa1675bab78e615c71a578f"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga338752778aa1675bab78e615c71a578f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga338752778aa1675bab78e615c71a578f">squared_norm</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga338752778aa1675bab78e615c71a578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared vector 2-norm of the elements of a tile.  <a href="group___non_intrusive_tile_interface.html#ga338752778aa1675bab78e615c71a578f">More...</a><br /></td></tr>
<tr class="separator:ga338752778aa1675bab78e615c71a578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c1ad5b5a59b783da711eba292b33c5"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga79c1ad5b5a59b783da711eba292b33c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga79c1ad5b5a59b783da711eba292b33c5">norm</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga79c1ad5b5a59b783da711eba292b33c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector 2-norm of a tile.  <a href="group___non_intrusive_tile_interface.html#ga79c1ad5b5a59b783da711eba292b33c5">More...</a><br /></td></tr>
<tr class="separator:ga79c1ad5b5a59b783da711eba292b33c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef7824931c39eeba0ad4b394038d16a"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga1ef7824931c39eeba0ad4b394038d16a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga1ef7824931c39eeba0ad4b394038d16a">max</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga1ef7824931c39eeba0ad4b394038d16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga1ef7824931c39eeba0ad4b394038d16a">More...</a><br /></td></tr>
<tr class="separator:ga1ef7824931c39eeba0ad4b394038d16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga828782da9ce948aa72f353c5564025c8"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ga828782da9ce948aa72f353c5564025c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga828782da9ce948aa72f353c5564025c8">min</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:ga828782da9ce948aa72f353c5564025c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element of a tile.  <a href="group___non_intrusive_tile_interface.html#ga828782da9ce948aa72f353c5564025c8">More...</a><br /></td></tr>
<tr class="separator:ga828782da9ce948aa72f353c5564025c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb84a7965d7b1ce571419a811da3ed7f"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gafb84a7965d7b1ce571419a811da3ed7f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gafb84a7965d7b1ce571419a811da3ed7f">abs_max</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gafb84a7965d7b1ce571419a811da3ed7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute maximum element of a tile.  <a href="group___non_intrusive_tile_interface.html#gafb84a7965d7b1ce571419a811da3ed7f">More...</a><br /></td></tr>
<tr class="separator:gafb84a7965d7b1ce571419a811da3ed7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc14202de34a66f84701ddf89dd21c67"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:gadc14202de34a66f84701ddf89dd21c67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gadc14202de34a66f84701ddf89dd21c67">abs_min</a> (const Arg &amp;arg)</td></tr>
<tr class="memdesc:gadc14202de34a66f84701ddf89dd21c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute mainimum element of a tile.  <a href="group___non_intrusive_tile_interface.html#gadc14202de34a66f84701ddf89dd21c67">More...</a><br /></td></tr>
<tr class="separator:gadc14202de34a66f84701ddf89dd21c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdda011a05f7208b0dc83686a4eee2af"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:gabdda011a05f7208b0dc83686a4eee2af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#gabdda011a05f7208b0dc83686a4eee2af">dot</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:gabdda011a05f7208b0dc83686a4eee2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector dot product of two tiles.  <a href="group___non_intrusive_tile_interface.html#gabdda011a05f7208b0dc83686a4eee2af">More...</a><br /></td></tr>
<tr class="separator:gabdda011a05f7208b0dc83686a4eee2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga448de94236be83647ed7aa04ac8f3653"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:ga448de94236be83647ed7aa04ac8f3653"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___non_intrusive_tile_interface.html#ga448de94236be83647ed7aa04ac8f3653">inner_product</a> (const Left &amp;left, const Right &amp;right)</td></tr>
<tr class="memdesc:ga448de94236be83647ed7aa04ac8f3653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector inner product of two tiles.  <a href="group___non_intrusive_tile_interface.html#ga448de94236be83647ed7aa04ac8f3653">More...</a><br /></td></tr>
<tr class="separator:ga448de94236be83647ed7aa04ac8f3653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1fa4c93060bc503429e3527f2993ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a2b1fa4c93060bc503429e3527f2993ad">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;p, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r)</td></tr>
<tr class="memdesc:a2b1fa4c93060bc503429e3527f2993ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array. ">TiledRange</a> permutation operator.  <a href="#a2b1fa4c93060bc503429e3527f2993ad">More...</a><br /></td></tr>
<tr class="separator:a2b1fa4c93060bc503429e3527f2993ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0947b0d351b9ee0112b292eb869249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4b0947b0d351b9ee0112b292eb869249">swap</a> (<a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1)</td></tr>
<tr class="memdesc:a4b0947b0d351b9ee0112b292eb869249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the content of the two given <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array. ">TiledRange</a>'s.  <a href="#a4b0947b0d351b9ee0112b292eb869249">More...</a><br /></td></tr>
<tr class="separator:a4b0947b0d351b9ee0112b292eb869249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a1447230c9a5ca4906ee3684cbe890"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a95a1447230c9a5ca4906ee3684cbe890">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r2)</td></tr>
<tr class="memdesc:a95a1447230c9a5ca4906ee3684cbe890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when all tile and element ranges are the same.  <a href="#a95a1447230c9a5ca4906ee3684cbe890">More...</a><br /></td></tr>
<tr class="separator:a95a1447230c9a5ca4906ee3684cbe890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282e9e655ef9479b267ac1975d77eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a4282e9e655ef9479b267ac1975d77eb6">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;r2)</td></tr>
<tr class="separator:a4282e9e655ef9479b267ac1975d77eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42dd6da4a499c34371973b91d3529c0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ac42dd6da4a499c34371973b91d3529c0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;rng)</td></tr>
<tr class="separator:ac42dd6da4a499c34371973b91d3529c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#abe5632aeeaf569807a5e38b4ae1c5a98">swap</a> (<a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r0, <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1)</td></tr>
<tr class="memdesc:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the data of the two given ranges.  <a href="#abe5632aeeaf569807a5e38b4ae1c5a98">More...</a><br /></td></tr>
<tr class="separator:abe5632aeeaf569807a5e38b4ae1c5a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0508aa5150620ac2a2a5476c6c5612"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a9e0508aa5150620ac2a2a5476c6c5612">operator==</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:a9e0508aa5150620ac2a2a5476c6c5612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a9e0508aa5150620ac2a2a5476c6c5612">More...</a><br /></td></tr>
<tr class="separator:a9e0508aa5150620ac2a2a5476c6c5612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a49a6fdebe3f7dff3beb2637c2c48809f">operator!=</a> (const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;r2)</td></tr>
<tr class="memdesc:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a49a6fdebe3f7dff3beb2637c2c48809f">More...</a><br /></td></tr>
<tr class="separator:a49a6fdebe3f7dff3beb2637c2c48809f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3e4d830e8d3e6b0c3ef4db415eeed8f3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;rng)</td></tr>
<tr class="memdesc:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> ostream operator.  <a href="#a3e4d830e8d3e6b0c3ef4db415eeed8f3">More...</a><br /></td></tr>
<tr class="separator:a3e4d830e8d3e6b0c3ef4db415eeed8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">TiledArray initialization.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions initialize <a class="el" href="namespace_tiled_array.html">TiledArray</a> AND MADWorld runtime components. </p><dl class="section note"><dt>Note</dt><dd>the default World object is set to the object returned by these. </dd></dl>
</div></td></tr>
<tr class="memitem:a3ebd5da5a1a91c9a3864d2e02e5d3665"><td class="memItemLeft" align="right" valign="top">World &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a3ebd5da5a1a91c9a3864d2e02e5d3665">initialize</a> (int &amp;argc, char **&amp;argv, const SafeMPI::Intracomm &amp;comm)</td></tr>
<tr class="separator:a3ebd5da5a1a91c9a3864d2e02e5d3665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc942d955cabdb2d06716662c016fa4c"><td class="memItemLeft" align="right" valign="top">World &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#adc942d955cabdb2d06716662c016fa4c">initialize</a> (int &amp;argc, char **&amp;argv)</td></tr>
<tr class="separator:adc942d955cabdb2d06716662c016fa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0d8d494a8ba801d807d687d1135ef5"><td class="memItemLeft" align="right" valign="top">World &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#ade0d8d494a8ba801d807d687d1135ef5">initialize</a> (int &amp;argc, char **&amp;argv, const MPI_Comm &amp;comm)</td></tr>
<tr class="separator:ade0d8d494a8ba801d807d687d1135ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1265733604f5af60af78a9d7fa3ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array.html#a0f1265733604f5af60af78a9d7fa3ae4">finalize</a> ()</td></tr>
<tr class="separator:a0f1265733604f5af60af78a9d7fa3ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adf28ccfd580f62de5342a9a1510e22e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf28ccfd580f62de5342a9a1510e22e9">&#9670;&nbsp;</a></span>Array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int = 0, typename Tile  = Tensor&lt;T, Eigen::aligned_allocator&lt;T&gt; &gt;, typename Policy  = DensePolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">TiledArray::Array</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00077">77</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a598c53efb66f9c18b8a6b5bcfbeaf8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598c53efb66f9c18b8a6b5bcfbeaf8f3">&#9670;&nbsp;</a></span>EigenMatrixXcd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;double&gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#a598c53efb66f9c18b8a6b5bcfbeaf8f3">TiledArray::EigenMatrixXcd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00043">43</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="adde89f3f1e4ba23ddf9ce7b6e2db088f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde89f3f1e4ba23ddf9ce7b6e2db088f">&#9670;&nbsp;</a></span>EigenMatrixXcf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;float&gt;, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#adde89f3f1e4ba23ddf9ce7b6e2db088f">TiledArray::EigenMatrixXcf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00044">44</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ac5db88c965b8d32f1f72d37d3dc3561c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5db88c965b8d32f1f72d37d3dc3561c">&#9670;&nbsp;</a></span>EigenMatrixXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#ac5db88c965b8d32f1f72d37d3dc3561c">TiledArray::EigenMatrixXd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00041">41</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aacdf44d8771941244661bf77cf07069e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf44d8771941244661bf77cf07069e">&#9670;&nbsp;</a></span>EigenMatrixXf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#aacdf44d8771941244661bf77cf07069e">TiledArray::EigenMatrixXf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00042">42</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="ae5d1d4be6c1d3cef049c42490778da56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d1d4be6c1d3cef049c42490778da56">&#9670;&nbsp;</a></span>EigenMatrixXi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#ae5d1d4be6c1d3cef049c42490778da56">TiledArray::EigenMatrixXi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00045">45</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="afa83a358322961f1da1b50d5e28ae0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa83a358322961f1da1b50d5e28ae0ea">&#9670;&nbsp;</a></span>EigenMatrixXl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;long, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; <a class="el" href="namespace_tiled_array.html#afa83a358322961f1da1b50d5e28ae0ea">TiledArray::EigenMatrixXl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00046">46</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a19c2ebf917a509ec12deca6a13dd1904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c2ebf917a509ec12deca6a13dd1904">&#9670;&nbsp;</a></span>EigenVectorXcd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;double&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespace_tiled_array.html#a19c2ebf917a509ec12deca6a13dd1904">TiledArray::EigenVectorXcd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00049">49</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="abfe17eddb0710849aa9af552f4f85098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe17eddb0710849aa9af552f4f85098">&#9670;&nbsp;</a></span>EigenVectorXcf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;std::complex&lt;float&gt;, 1, Eigen::Dynamic&gt; <a class="el" href="namespace_tiled_array.html#abfe17eddb0710849aa9af552f4f85098">TiledArray::EigenVectorXcf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00050">50</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aa783ea4f581c1c1bb75f647d68c65a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa783ea4f581c1c1bb75f647d68c65a68">&#9670;&nbsp;</a></span>EigenVectorXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;double, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#aa783ea4f581c1c1bb75f647d68c65a68">TiledArray::EigenVectorXd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00047">47</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a0c54f8e9145825b6155cf5389a9ee03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c54f8e9145825b6155cf5389a9ee03a">&#9670;&nbsp;</a></span>EigenVectorXf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;float, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#a0c54f8e9145825b6155cf5389a9ee03a">TiledArray::EigenVectorXf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00048">48</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="acb38a6b56111826e5b451528b939eb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb38a6b56111826e5b451528b939eb60">&#9670;&nbsp;</a></span>EigenVectorXi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;int, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#acb38a6b56111826e5b451528b939eb60">TiledArray::EigenVectorXi</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00051">51</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="aec5f429338b7707830ce0339ebaf6274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5f429338b7707830ce0339ebaf6274">&#9670;&nbsp;</a></span>EigenVectorXl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;long, Eigen::Dynamic, 1&gt; <a class="el" href="namespace_tiled_array.html#aec5f429338b7707830ce0339ebaf6274">TiledArray::EigenVectorXl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00052">52</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>

</div>
</div>
<a id="a14381436074bbf8eff68427766e395a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14381436074bbf8eff68427766e395a2">&#9670;&nbsp;</a></span>TArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TiledArray::TArray</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;T&gt; &gt;, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00057">57</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aea17c71440d5a58110b7ade911cf1102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea17c71440d5a58110b7ade911cf1102">&#9670;&nbsp;</a></span>TArrayC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;std::complex&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#aea17c71440d5a58110b7ade911cf1102">TiledArray::TArrayC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00063">63</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a0b25748e8f1dd4d7421925264bbe4905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b25748e8f1dd4d7421925264bbe4905">&#9670;&nbsp;</a></span>TArrayD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;double&gt; <a class="el" href="namespace_tiled_array.html#a0b25748e8f1dd4d7421925264bbe4905">TiledArray::TArrayD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00058">58</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aaeec85e445a8f0330f135292858a3cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeec85e445a8f0330f135292858a3cb4">&#9670;&nbsp;</a></span>TArrayF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;float&gt; <a class="el" href="namespace_tiled_array.html#aaeec85e445a8f0330f135292858a3cb4">TiledArray::TArrayF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00060">60</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a2d6a345559008046e6785aee9d35f11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6a345559008046e6785aee9d35f11d">&#9670;&nbsp;</a></span>TArrayI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;int&gt; <a class="el" href="namespace_tiled_array.html#a2d6a345559008046e6785aee9d35f11d">TiledArray::TArrayI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00059">59</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a99743650f2570e83f35a0ba1958c9569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99743650f2570e83f35a0ba1958c9569">&#9670;&nbsp;</a></span>TArrayL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;long&gt; <a class="el" href="namespace_tiled_array.html#a99743650f2570e83f35a0ba1958c9569">TiledArray::TArrayL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00061">61</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aa010edfe058bd83377e3790741e14dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa010edfe058bd83377e3790741e14dee">&#9670;&nbsp;</a></span>TArrayZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a14381436074bbf8eff68427766e395a2">TArray</a>&lt;std::complex&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#aa010edfe058bd83377e3790741e14dee">TiledArray::TArrayZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00062">62</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="ac685ca67ab67879d908e57681834604c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac685ca67ab67879d908e57681834604c">&#9670;&nbsp;</a></span>TensorC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;std::complex&lt;float&gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;std::complex&lt;float&gt; &gt; &gt; <a class="el" href="namespace_tiled_array.html#ac685ca67ab67879d908e57681834604c">TiledArray::TensorC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00049">49</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a380d0c9b978b651c0e4af14e63baf2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380d0c9b978b651c0e4af14e63baf2e0">&#9670;&nbsp;</a></span>TensorConstMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TiledArray::TensorConstMap</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;typename std::add_const&lt;T&gt;::type, Range_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00048">48</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a1950fa935cff5cb1415b58d822057f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1950fa935cff5cb1415b58d822057f23">&#9670;&nbsp;</a></span>TensorConstView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a1950fa935cff5cb1415b58d822057f23">TiledArray::TensorConstView</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;typename std::add_const&lt;T&gt;::type, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00046">46</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac1a673c87e7624e63f641318f610a297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a673c87e7624e63f641318f610a297">&#9670;&nbsp;</a></span>TensorD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;double, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#ac1a673c87e7624e63f641318f610a297">TiledArray::TensorD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00042">42</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a43b4522d34881253139d842d7345dcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b4522d34881253139d842d7345dcbc">&#9670;&nbsp;</a></span>TensorF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;float, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#a43b4522d34881253139d842d7345dcbc">TiledArray::TensorF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00046">46</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a7f58ff1caa878600bc482e36acb64060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f58ff1caa878600bc482e36acb64060">&#9670;&nbsp;</a></span>TensorI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;int, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;int&gt; &gt; <a class="el" href="namespace_tiled_array.html#a7f58ff1caa878600bc482e36acb64060">TiledArray::TensorI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00045">45</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a940148a41f1a9b47fabd83511d0ad11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940148a41f1a9b47fabd83511d0ad11f">&#9670;&nbsp;</a></span>TensorL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;long, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;long&gt; &gt; <a class="el" href="namespace_tiled_array.html#a940148a41f1a9b47fabd83511d0ad11f">TiledArray::TensorL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00047">47</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a35af09371a3551f27d53d90a059931fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35af09371a3551f27d53d90a059931fd">&#9670;&nbsp;</a></span>TensorMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TiledArray::TensorMap</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, Range_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00044">44</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>

</div>
</div>
<a id="a59d2edc4ec73d986edc524386dab1f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d2edc4ec73d986edc524386dab1f9c">&#9670;&nbsp;</a></span>TensorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a59d2edc4ec73d986edc524386dab1f9c">TiledArray::TensorView</a> = typedef <a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt;T, <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00042">42</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="abe4438e1e4fac9c7ed76af5bae4a6aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4438e1e4fac9c7ed76af5bae4a6aff">&#9670;&nbsp;</a></span>TensorZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;std::complex&lt;double&gt;, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;std::complex&lt;double&gt; &gt; &gt; <a class="el" href="namespace_tiled_array.html#abe4438e1e4fac9c7ed76af5bae4a6aff">TiledArray::TensorZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00048">48</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a0231c1beab8d7e7c31c19aeceede50fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0231c1beab8d7e7c31c19aeceede50fd">&#9670;&nbsp;</a></span>TSpArray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TiledArray::TSpArray</a> = typedef <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T, <a class="el" href="class_eigen_1_1aligned__allocator.html">Eigen::aligned_allocator</a>&lt;T&gt; &gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00067">67</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="add9caaa3d2c9f944690670df6a1a08ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9caaa3d2c9f944690670df6a1a08ed">&#9670;&nbsp;</a></span>TSpArrayC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;std::complex&lt;float&gt; &gt; <a class="el" href="namespace_tiled_array.html#add9caaa3d2c9f944690670df6a1a08ed">TiledArray::TSpArrayC</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00073">73</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="abb0c4ccd3689f4dafb20c6d238690705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0c4ccd3689f4dafb20c6d238690705">&#9670;&nbsp;</a></span>TSpArrayD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;double&gt; <a class="el" href="namespace_tiled_array.html#abb0c4ccd3689f4dafb20c6d238690705">TiledArray::TSpArrayD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00068">68</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a6bd8165f08a44cf5a27efca786bee5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd8165f08a44cf5a27efca786bee5ac">&#9670;&nbsp;</a></span>TSpArrayF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;float&gt; <a class="el" href="namespace_tiled_array.html#a6bd8165f08a44cf5a27efca786bee5ac">TiledArray::TSpArrayF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00070">70</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a4dd7da1c48d18d477b9d0366e94d9b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd7da1c48d18d477b9d0366e94d9b10">&#9670;&nbsp;</a></span>TSpArrayI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;int&gt; <a class="el" href="namespace_tiled_array.html#a4dd7da1c48d18d477b9d0366e94d9b10">TiledArray::TSpArrayI</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00069">69</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="a51e13a617d7cc592f38124462d5a853d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e13a617d7cc592f38124462d5a853d">&#9670;&nbsp;</a></span>TSpArrayL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;long&gt; <a class="el" href="namespace_tiled_array.html#a51e13a617d7cc592f38124462d5a853d">TiledArray::TSpArrayL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00071">71</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<a id="aa157a11e4eb462e70e5fec1411acab8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa157a11e4eb462e70e5fec1411acab8c">&#9670;&nbsp;</a></span>TSpArrayZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_tiled_array.html#a0231c1beab8d7e7c31c19aeceede50fd">TSpArray</a>&lt;std::complex&lt;double&gt; &gt; <a class="el" href="namespace_tiled_array.html#aa157a11e4eb462e70e5fec1411acab8c">TiledArray::TSpArrayZ</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiledarray__fwd_8h_source.html#l00072">72</a> of file <a class="el" href="tiledarray__fwd_8h_source.html">tiledarray_fwd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa1333af3bbdd6ac34ec64a4eef6e9e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1333af3bbdd6ac34ec64a4eef6e9e07">&#9670;&nbsp;</a></span>ShapeReductionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">TiledArray::ShapeReductionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa1333af3bbdd6ac34ec64a4eef6e9e07aaef12e903e606a4895a16b393bfdec8c"></a>Union&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654"></a>Intersect&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00044">44</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a87ca6bca2735b62e0eaf5cac4a3cba58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca6bca2735b62e0eaf5cac4a3cba58">&#9670;&nbsp;</a></span>add() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(left.add(right))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>(left + right)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00042">42</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="a3f55826b650600d7dbea2e362f5520c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f55826b650600d7dbea2e362f5520c6">&#9670;&nbsp;</a></span>add() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and scale tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>(left + right) * factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00057">57</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="aa30324227880aa0d22114f89c3fafe96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30324227880aa0d22114f89c3fafe96">&#9670;&nbsp;</a></span>add() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and permute tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ (left + right)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00069">69</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="a860bc6cc248f9358d15b0989ef35350f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860bc6cc248f9358d15b0989ef35350f">&#9670;&nbsp;</a></span>add() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::add </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Right &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a>, scale, and permute tile arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tile type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand argument to be added </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand argument to be added </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ (left + right) * factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00084">84</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="af7b6f318b11b3abb7986751995a880d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b6f318b11b3abb7986751995a880d0">&#9670;&nbsp;</a></span>add_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&amp; TiledArray::add_to </td>
          <td>(</td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> to the result tile. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>The result tile type </td></tr>
    <tr><td class="paramname">Arg</td><td>The argument tile type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result tile </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to be added to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>result[i] += arg[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00096">96</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="a17ec71822bfc6ea2da939913f8ee8f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ec71822bfc6ea2da939913f8ee8f02">&#9670;&nbsp;</a></span>add_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Arg , typename Scalar , typename std::enable_if&lt; detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&amp; TiledArray::add_to </td>
          <td>(</td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> and scale to the result tile. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>The result tile type </td></tr>
    <tr><td class="paramname">Arg</td><td>The argument tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result tile </td></tr>
    <tr><td class="paramname">arg</td><td>The argument to be added to <code>result</code> </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>(result[i] += arg[i]) *= factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2add_8h_source.html#l00110">110</a> of file <a class="el" href="tile__interface_2add_8h_source.html">add.h</a>.</p>

</div>
</div>
<a id="a692c0867d32b1147008f2bbe483168db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692c0867d32b1147008f2bbe483168db">&#9670;&nbsp;</a></span>array_to_btas_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">btas::Tensor&lt;typename Tile::value_type&gt; TiledArray::array_to_btas_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">TiledArray::DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a> object into a btas::Tensor object. </p>
<p>This function will copy the contents of <code>src</code> into a <code>btas::Tensor</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>src</code> have been copied into the result array tiles. The size of <code>src.world()</code>.<a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">size()</a> must be equal to 1 or <code>src</code> must be a replicated <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a>. Usage: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TArrayD</a> array(world, trange);</div><div class="line"><span class="comment">// Set tiles of array ...</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> t = <a class="code" href="namespace_tiled_array.html#a692c0867d32b1147008f2bbe483168db">array_to_btas_tensor</a>(array);</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>the tile type of <code>src</code> </td></tr>
    <tr><td class="paramname">Policy</td><td>the policy type of <code>src</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The TiledArray::DistArray&lt;Tile,Policy&gt; object whose contents will be copied to the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>btas::Tensor</code> object that is a copy of <code>src</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 and <code>src</code> is not replicated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00259">259</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a692c0867d32b1147008f2bbe483168db_cgraph.png" border="0" usemap="#namespace_tiled_array_a692c0867d32b1147008f2bbe483168db_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a692c0867d32b1147008f2bbe483168db_cgraph" id="namespace_tiled_array_a692c0867d32b1147008f2bbe483168db_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor. " alt="" coords="191,5,335,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="191,68,335,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="191,131,335,169"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_dist_array.html#a2978e91e67813dcd47b83864865e9134" title="TiledArray::DistArray\l::size" alt="" coords="191,193,335,232"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="191,256,335,295"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_dist_array.html#af7f0a051f5aa4b8a01558bb022f15a71" title="Find local or remote tile. " alt="" coords="191,319,335,357"/>
</map>
</div>

</div>
</div>
<a id="ad4ffc6de9b633a34e7d724191cd11f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ffc6de9b633a34e7d724191cd11f3f">&#9670;&nbsp;</a></span>array_to_eigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , unsigned int EigenStorageOrder = Eigen::ColMajor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;typename Tile::value_type, Eigen::Dynamic, Eigen::Dynamic, EigenStorageOrder&gt; TiledArray::array_to_eigen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Array object into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix object. </p>
<p>This function will copy the content of an <code>Array</code> object into matrix. The copy operation is done in parallel, and this function will block until all elements of <code>array</code> have been copied into the result matrix. The size of world must be exactly equal to 1, or <code>array</code> must be a replicated object. Usage: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array(world, trange);</div><div class="line"><span class="comment">// Set tiles of array ...</span></div><div class="line"></div><div class="line">Eigen::MatrixXd m = <a class="code" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f">array_to_eigen</a>(array);</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The array tile type </td></tr>
    <tr><td class="paramname">EigenStorageOrder</td><td>The storage order of the resulting <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a> object; the default is Eigen::ColMajor, i.e. the column-major storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to be converted. It must be replicated if using 2 or more World ranks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix; it will contain same data on each World rank. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 and <code>array</code> is not replicated. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the number of dimensions of <code>array</code> is not equal to 1 or 2. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00436">436</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph.png" border="0" usemap="#namespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph" id="namespace_tiled_array_ad4ffc6de9b633a34e7d724191cd11f3f_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="191,5,335,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor. " alt="" coords="191,68,335,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="191,131,335,169"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_dist_array.html#a2978e91e67813dcd47b83864865e9134" title="TiledArray::DistArray\l::size" alt="" coords="191,193,335,232"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="191,256,335,295"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2" title="Task function for assigning a tensor to an Eigen submatrix. " alt="" coords="194,319,333,371"/>
<area shape="rect" id="node13" href="class_tiled_array_1_1_dist_array.html#af7f0a051f5aa4b8a01558bb022f15a71" title="Find local or remote tile. " alt="" coords="191,395,335,433"/>
<area shape="rect" id="node8" href="namespace_tiled_array.html#a6a1e016346f447dcd7b5b4d7f29246b6" title="Copy the content of a tensor into an Eigen matrix block. " alt="" coords="383,325,528,364"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="589,297,718,336"/>
<area shape="rect" id="node10" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="576,360,731,385"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="779,321,908,360"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="779,384,908,423"/>
</map>
</div>

</div>
</div>
<a id="a59f28503ce59e167667a4d8259619bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f28503ce59e167667a4d8259619bf0">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00123">123</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a59f28503ce59e167667a4d8259619bf0_icgraph.png" border="0" usemap="#namespace_tiled_array_a59f28503ce59e167667a4d8259619bf0_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a59f28503ce59e167667a4d8259619bf0_icgraph" id="namespace_tiled_array_a59f28503ce59e167667a4d8259619bf0_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="181,5,382,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_bitset_1_1reference.html#a97c0d8a36ab9041be869d1df05d7da67" title="TiledArray::detail\l::Bitset::reference\l::operator=" alt="" coords="218,68,344,120"/>
</map>
</div>

</div>
</div>
<a id="a299983d3798619c4de88f351bbe369ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299983d3798619c4de88f351bbe369ae">&#9670;&nbsp;</a></span>axpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::axpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00115">115</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_cgraph.png" border="0" usemap="#namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_cgraph" id="namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="171,5,313,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="171,68,314,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_icgraph.png" border="0" usemap="#namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_icgraph" id="namespace_tiled_array_a299983d3798619c4de88f351bbe369ae_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="407,5,608,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_d_i_i_s.html#a6fd568abd2246acbc0f6ea1ee6e20905" title="TiledArray::DIIS::extrapolate" alt="" coords="171,37,359,63"/>
<area shape="rect" id="node4" href="namespacebtas.html#aafe8c6db2e1b1dc51b57424a46b21b27" title="result[i] += arg[i] " alt="" coords="217,87,312,112"/>
</map>
</div>

</div>
</div>
<a id="aeefa8ea4cb95ebb8c9d9b3809f12dc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefa8ea4cb95ebb8c9d9b3809f12dc4d">&#9670;&nbsp;</a></span>btas_subtensor_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ , typename Storage_ , typename Allocator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::btas_subtensor_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, Allocator_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a>. </p>
<p>A block of btas::Tensor <code>src</code> will be copied into <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a> <code>dst</code>. The block dimensions will be determined by the dimensions of the range of <code>dst</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">Range_</td><td>The range type of the source btas::Tensor object </td></tr>
    <tr><td class="paramname">Storage_</td><td>The storage type of the source btas::Tensor object </td></tr>
    <tr><td class="paramname">Allocator_</td><td>The allocator type of the destination <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source object; its subblock defined by the {lower,upper} bounds <code>{dst.lobound()</code>,dst.upbound()} will be copied to <code>dst</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The object that will contain the contents of the corresponding subblock of src </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>src</code> and <code>dst</code> do not match. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00052">52</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_cgraph.png" border="0" usemap="#namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_cgraph" id="namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="266,5,395,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title="TiledArray::detail\l::make_ta_range" alt="" coords="270,68,391,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="263,131,398,169"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="483,216,604,255"/>
<area shape="rect" id="node7" href="namespace_tiled_array.html#ada3e7bc14ca6d99904ada555922fc391" title="TiledArray::make_const_map" alt="" coords="234,245,428,271"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="476,131,611,169"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_icgraph.png" border="0" usemap="#namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_icgraph" alt=""/></div>
<map name="namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_icgraph" id="namespace_tiled_array_aeefa8ea4cb95ebb8c9d9b3809f12dc4d_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a8aab6018796760c407b5cc53295568ed" title="Task function for converting btas::Tensor subblock to a TiledArray::DistArray. " alt="" coords="234,5,408,57"/>
</map>
</div>

</div>
</div>
<a id="aa4eb781438f1d5ffec3f75b879ead8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4eb781438f1d5ffec3f75b879ead8c0">&#9670;&nbsp;</a></span>btas_tensor_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DistArray_ , typename T , typename Range , typename Storage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DistArray_ TiledArray::btas_tensor_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const btas::Tensor&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a>, Storage &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a btas::Tensor object into a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a> object. </p>
<p>This function will copy the contents of <code>src</code> into a <code>DistArray_</code> object that is tiled according to the <code>trange</code> object. If the <code>DistArray_</code> object has sparse policy, a sparse map with large norm is created to ensure all the values from <code>src</code> copy to the <code>DistArray_</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>src</code> have been copied into the result array tiles. The size of <code><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">world.size()</a></code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in <code>src</code> is identical on all nodes. Upon completion, if the <code>DistArray_</code> object has sparse policy <a class="el" href="namespace_tiled_array.html#abc763468b96a704d6b4efb628909485f" title="Truncate a dense Array. ">truncate()</a> is called.<br />
Usage: </p><div class="fragment"><div class="line">btas::Tensor&lt;double&gt; src(100, 100, 100);</div><div class="line"><span class="comment">// Fill src with data ...</span></div><div class="line"></div><div class="line"><span class="comment">// Create a range for the new array object</span></div><div class="line">std::vector&lt;std::size_t&gt; blocks;</div><div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div><div class="line">  blocks.push_back(i);</div><div class="line">std::array&lt;TiledArray::TiledRange1, 3&gt; blocks3 =</div><div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div><div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div><div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div><div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks3.begin(), blocks3.end());</div><div class="line"></div><div class="line"><span class="comment">// Create an Array from the source btas::Tensor object</span></div><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TArrayD</a> array =</div><div class="line">    btas_tensor_to_array&lt;decltype(array)&gt;(world, trange, src);</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DistArray_</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a> type </td></tr>
    <tr><td class="paramname">TArgs</td><td>the type pack in type btas::Tensor&lt;TArgs...&gt; of <code>src</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">world</td><td>The world where the result array will live </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The btas::Tensor&lt;TArgs..&gt; object whose contents will be copied to the result. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>DistArray_</code> object that is a copy of <code>src</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If using 2 or more World ranks, set <code>replicated=true</code> and make sure <code>matrix</code> is the same on each rank! </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00186">186</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph.png" border="0" usemap="#namespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph" id="namespace_tiled_array_aa4eb781438f1d5ffec3f75b879ead8c0_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range. " alt="" coords="214,5,371,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="212,68,374,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range. " alt="" coords="214,117,371,156"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#adc6eb6d7ffa9defd3c7e6aae88080b2b" title="Range extent accessor. " alt="" coords="225,180,361,219"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_range.html#a63700b9c4ebc8c67f46325f77ed4cd2a" title="Range volume accessor. " alt="" coords="225,243,361,281"/>
<area shape="rect" id="node8" href="namespace_tiled_array.html#abc763468b96a704d6b4efb628909485f" title="Truncate a dense Array. " alt="" coords="224,305,361,331"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_range.html#afd7dd885ff139cc535b8f1e42a4442f3" title="Range extent data accessor. " alt="" coords="422,180,557,219"/>
</map>
</div>

</div>
</div>
<a id="aead4454c3584b960202d2390a0139c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead4454c3584b960202d2390a0139c33">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::clone </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A (deep) copy of <code>arg</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2clone_8h_source.html#l00040">40</a> of file <a class="el" href="tile__interface_2clone_8h_source.html">clone.h</a>.</p>

</div>
</div>
<a id="a7c9fa503cbbd6e5627b1e1878cf51141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9fa503cbbd6e5627b1e1878cf51141">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy&gt; TiledArray::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a deep copy of an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
    <tr><td class="paramname">Policy</td><td>The policy of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The array to be cloned </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2clone_8h_source.html#l00043">43</a> of file <a class="el" href="conversions_2clone_8h_source.html">clone.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph.png" border="0" usemap="#namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph" id="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="187,5,331,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="187,68,331,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_dist_array.html#a3140a5cda14c2ea5b5e7c654099f015d" title="Shape accessor. " alt="" coords="187,131,331,169"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor. " alt="" coords="187,193,331,232"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="187,256,331,295"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_dist_array.html#af7f0a051f5aa4b8a01558bb022f15a71" title="Find local or remote tile. " alt="" coords="187,319,331,357"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_dist_array.html#a791c7bfbb29bc9e7ebe2963125e5b2d9" title="Set a tile and fill it using a sequence. " alt="" coords="174,381,343,407"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph.png" border="0" usemap="#namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph" id="namespace_tiled_array_a7c9fa503cbbd6e5627b1e1878cf51141_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="174,5,375,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1tile__interface_1_1_clone.html#a376265d1f2ebd6ba898c665f269cae01" title="TiledArray::tile_interface\l::Clone\&lt; Result, Arg \&gt;::\loperator()" alt="" coords="192,68,357,120"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_dist_array.html#a7f1586d7c20390d1a25c9f2a4432731b" title="Create a deep copy of this array. " alt="" coords="203,144,347,183"/>
<area shape="rect" id="node5" href="group___tile_interface.html#gaec378f0f4b197546fb0b69f16748bfa1" title="Create a copy of arg. " alt="" coords="214,207,335,232"/>
</map>
</div>

</div>
</div>
<a id="a272240d40c483f779f8affc3c12c3285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272240d40c483f779f8affc3c12c3285">&#9670;&nbsp;</a></span>column_major_buffer_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::column_major_buffer_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::value_type::value_type *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a column-major matrix buffer into an Array object. </p>
<p>This function will copy the content of <code>buffer</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. The size of <code><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">world.size()</a></code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in <code>buffer</code> is identical on all nodes. Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span>* buffer = <span class="keyword">new</span> <span class="keywordtype">double</span>[100 * 100];</div><div class="line"><span class="comment">// Fill buffer with data ...</span></div><div class="line"></div><div class="line"><span class="comment">// Create a range for the new array object</span></div><div class="line">std::vector&lt;std::size_t&gt; blocks;</div><div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div><div class="line">  blocks.push_back(i);</div><div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div><div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div><div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div><div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div><div class="line"></div><div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div><div class="line">    column_major_buffer_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange, buffer, 100, 100);</div><div class="line"></div><div class="line"><span class="keyword">delete</span> [] buffer;</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">buffer</td><td>The row-major matrix buffer to be copied </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix </td></tr>
    <tr><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>m</code> and <code>n</code> are not equal to the number of rows or columns in tiled range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00576">576</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a272240d40c483f779f8affc3c12c3285_cgraph.png" border="0" usemap="#namespace_tiled_array_a272240d40c483f779f8affc3c12c3285_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a272240d40c483f779f8affc3c12c3285_cgraph" id="namespace_tiled_array_a272240d40c483f779f8affc3c12c3285_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#acc20cb6cde49d2af9af3312a0309f540" title="Convert an Eigen matrix into an Array object. " alt="" coords="213,5,353,44"/>
</map>
</div>

</div>
</div>
<a id="a44b52c74197023a357e41e93efd8cf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b52c74197023a357e41e93efd8cf0a">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt; TiledArray::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00058">58</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a44b52c74197023a357e41e93efd8cf0a_icgraph.png" border="0" usemap="#namespace_tiled_array_a44b52c74197023a357e41e93efd8cf0a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a44b52c74197023a357e41e93efd8cf0a_icgraph" id="namespace_tiled_array_a44b52c74197023a357e41e93efd8cf0a_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="171,5,371,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_bitset.html#a38a56b30d14da9ea70a90d6114e17cfe" title="Copy constructor for bitset. " alt="" coords="211,68,331,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_bitset.html#a74e819d5ddaaf4e60dd9b106181d1d60" title="Assignment operator. " alt="" coords="208,131,334,169"/>
<area shape="rect" id="node5" href="namespacebtas.html#a9d347f47ae661ba169686b9628a24ec2" title="Computes the result of applying permutation perm to arg. " alt="" coords="220,193,322,219"/>
<area shape="rect" id="node6" href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01_t_00_01_allocator_01_4_00_01btas_1_4609707baf645f507ebd5df14a7b8d69.html#af778f0942560d12842d5d00ce970abc4" title="TiledArray::Cast\&lt; TiledArray\l::Tensor\&lt; T, Allocator \&gt;,\l btas::Tensor\&lt; T, Range_,\l Storage \&gt; \&gt;::operator()" alt="" coords="177,243,365,308"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1symmetry_1_1detail.html#a79d915594a7860fbfbc8e3932586d47a" title="Create a permuted copy of an array. " alt="" coords="194,332,348,371"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1detail_1_1_size_array.html#a4bf1d9e0a2bc1e467774e5cb47a9412b" title="TiledArray::detail\l::SizeArray::operator=" alt="" coords="195,395,347,433"/>
<area shape="rect" id="node11" href="kronecker__delta_8h.html#ae33f74c464abec8b0dfb2318ccdc1ffb" title="gemm" alt="" coords="242,457,300,483"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1_irrep.html#a2e3fb129fdfd47fb66bab646854550f1" title="Irrep constructor. " alt="" coords="209,507,333,545"/>
<area shape="rect" id="node8" href="namespace_tiled_array_1_1symmetry.html#a38d5bea588dd95b365438ff224e1eec6" title="Permute a std::array. " alt="" coords="419,301,566,340"/>
<area shape="rect" id="node9" href="namespace_tiled_array_1_1symmetry.html#a1a3ed954f0a3662340c2888015b0798d" title="In&#45;place permute a std::array. " alt="" coords="419,364,566,403"/>
</map>
</div>

</div>
</div>
<a id="a1ddaca49af12c55a7e2087ad77aa8035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddaca49af12c55a7e2087ad77aa8035">&#9670;&nbsp;</a></span>dense_diagonal_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T&gt;,<a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::dense_diagonal_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a> with only diagonal elements, the expected behavior is that every element (n,n,n, ..., n) will be nonzero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world for the array </td></tr>
    <tr><td class="paramname">trange</td><td>The trange for the array </td></tr>
    <tr><td class="paramname">val</td><td>The value to be written along the diagonal elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00138">138</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1ddaca49af12c55a7e2087ad77aa8035_cgraph.png" border="0" usemap="#namespace_tiled_array_a1ddaca49af12c55a7e2087ad77aa8035_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a1ddaca49af12c55a7e2087ad77aa8035_cgraph" id="namespace_tiled_array_a1ddaca49af12c55a7e2087ad77aa8035_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a31b41f257f8f107174ffbfd3b9e7c0c3" title="TiledArray::detail\l::write_tiles_to_array" alt="" coords="237,163,381,201"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="441,5,585,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="TiledArray::detail\l::diagonal_range" alt="" coords="453,68,574,107"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_dist_array.html#a70e45de02ea9820e6546dc06521c76f0" title="Check if the tile at index i is stored locally. " alt="" coords="441,131,585,169"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="441,193,585,232"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="441,256,585,295"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1_dist_array.html#a791c7bfbb29bc9e7ebe2963125e5b2d9" title="Set a tile and fill it using a sequence. " alt="" coords="429,319,598,344"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="646,37,782,76"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_range.html#ad59f6239bab9c89dac6fcccd6dbf8505" title="Range upper bound accessor. " alt="" coords="646,100,782,139"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="830,37,965,76"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_range.html#af38569cb05cfd8691647b1be6c702a4b" title="Range upper bound data accessor. " alt="" coords="830,100,965,139"/>
</map>
</div>

</div>
</div>
<a id="a8ba93db4bfabae38eb6d12fa6fcd62f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba93db4bfabae38eb6d12fa6fcd62f0">&#9670;&nbsp;</a></span>diagonal_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T&gt;, std::enable_if_t&lt;std::is_same&lt;Policy, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt;::value, Policy&gt;&gt; TiledArray::diagonal_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00177">177</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>

</div>
</div>
<a id="a94eb6ea8aa02524afe336384f717ec7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94eb6ea8aa02524afe336384f717ec7a">&#9670;&nbsp;</a></span>diagonal_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Policy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T&gt;, std::enable_if_t&lt;std::is_same&lt;Policy, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt;::value, Policy&gt;&gt; TiledArray::diagonal_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00185">185</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>

</div>
</div>
<a id="a1e4ffd2673648a15c05d1380f0be0079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4ffd2673648a15c05d1380f0be0079">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_tiled_array_1_1expressions_1_1_expr_trait.html">TiledArray::expressions::ExprTrait</a>&lt;Left&gt;::scalar_type TiledArray::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Left &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1expressions_1_1_expr.html">TiledArray::expressions::Expr</a>&lt; Right &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00096">96</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_cgraph.png" border="0" usemap="#namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_cgraph" id="namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1expressions_1_1_expr.html#a3d15ad3768fa79ceae7b313b7084c0a7" title="TiledArray::expressions\l::Expr::dot" alt="" coords="161,5,321,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_icgraph.png" border="0" usemap="#namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_icgraph" id="namespace_tiled_array_a1e4ffd2673648a15c05d1380f0be0079_icgraph">
<area shape="rect" id="node2" href="group___tile_interface.html#gaf71813b13896a29698efff4232719d70" title="Vector dot product of a tile. " alt="" coords="192,5,300,31"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dot_reduction.html#ae9f6343d37bfa088e4a28896cac26f7a" title="TiledArray::DotReduction\l::operator()" alt="" coords="161,55,331,93"/>
</map>
</div>

</div>
</div>
<a id="abc0b1ca917df616d05128c35276462fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0b1ca917df616d05128c35276462fd">&#9670;&nbsp;</a></span>dot_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::element_type TiledArray::dot_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00089">89</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_cgraph.png" border="0" usemap="#namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_cgraph" alt=""/></div>
<map name="namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_cgraph" id="namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="214,5,356,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="213,68,357,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_icgraph.png" border="0" usemap="#namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_icgraph" alt=""/></div>
<map name="namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_icgraph" id="namespace_tiled_array_abc0b1ca917df616d05128c35276462fd_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="677,5,878,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_d_i_i_s.html#adba4b9aeb0b361453aeb9c48c1dd992a" title="TiledArray::DIIS::compute\l_extrapolation_parameters" alt="" coords="213,35,393,73"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_d_i_i_s.html#a6fd568abd2246acbc0f6ea1ee6e20905" title="TiledArray::DIIS::extrapolate" alt="" coords="441,37,629,63"/>
</map>
</div>

</div>
</div>
<a id="af872c21673f2fd74250d0257fb80f2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af872c21673f2fd74250d0257fb80f2bb">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the result matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An m x n <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00066">66</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_cgraph.png" border="0" usemap="#namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_cgraph" alt=""/></div>
<map name="namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_cgraph" id="namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="208,5,337,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="208,68,337,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_icgraph.png" border="0" usemap="#namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_icgraph" alt=""/></div>
<map name="namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_icgraph" id="namespace_tiled_array_af872c21673f2fd74250d0257fb80f2bb_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#adfc30c5c9b3f17a6ab4d8b7a4b2a84b9" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="224,5,379,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#add789e43efcee8db349c7ec5c6218664" title="Copy a block of an Eigen matrix into a tensor. " alt="" coords="208,55,395,93"/>
<area shape="rect" id="node5" href="namespace_tiled_array.html#a6a1e016346f447dcd7b5b4d7f29246b6" title="Copy the content of a tensor into an Eigen matrix block. " alt="" coords="229,120,374,159"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#af50d31c15b208288edec33a0129649b0" title="Task function for converting Eigen submatrix to a tensor. " alt="" coords="443,44,625,96"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2" title="Task function for assigning a tensor to an Eigen submatrix. " alt="" coords="464,120,603,172"/>
<area shape="rect" id="node7" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f" title="Convert an Array object into an Eigen matrix object. " alt="" coords="673,127,811,165"/>
</map>
</div>

</div>
</div>
<a id="a88684d17566e9778f88a27bb35f06a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88684d17566e9778f88a27bb35f06a2a">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;<a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the result matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An m x n <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00084">84</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a88684d17566e9778f88a27bb35f06a2a_cgraph.png" border="0" usemap="#namespace_tiled_array_a88684d17566e9778f88a27bb35f06a2a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a88684d17566e9778f88a27bb35f06a2a_cgraph" id="namespace_tiled_array_a88684d17566e9778f88a27bb35f06a2a_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="208,5,337,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="208,68,337,107"/>
</map>
</div>

</div>
</div>
<a id="a0362f265187dbcbec382fff3b76ccc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0362f265187dbcbec382fff3b76ccc2d">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, 1&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An n element <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> vector map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00101">101</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a0362f265187dbcbec382fff3b76ccc2d_cgraph.png" border="0" usemap="#namespace_tiled_array_a0362f265187dbcbec382fff3b76ccc2d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a0362f265187dbcbec382fff3b76ccc2d_cgraph" id="namespace_tiled_array_a0362f265187dbcbec382fff3b76ccc2d_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="208,5,337,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="208,68,337,107"/>
</map>
</div>

</div>
</div>
<a id="a0d234491688847706a6e1a1bd0c86319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d234491688847706a6e1a1bd0c86319">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;<a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, 1&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the result matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An n element <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> vector map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When m * n is not equal to <code>tensor</code> size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00118">118</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a0d234491688847706a6e1a1bd0c86319_cgraph.png" border="0" usemap="#namespace_tiled_array_a0d234491688847706a6e1a1bd0c86319_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a0d234491688847706a6e1a1bd0c86319_cgraph" id="namespace_tiled_array_a0d234491688847706a6e1a1bd0c86319_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="208,5,337,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="208,68,337,107"/>
</map>
</div>

</div>
</div>
<a id="adfc30c5c9b3f17a6ab4d8b7a4b2a84b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc30c5c9b3f17a6ab4d8b7a4b2a84b9">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;const <a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<p>The dimensions of the result tensor </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>tensor</code> dimensions are not equal to 2 or 1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00135">135</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_adfc30c5c9b3f17a6ab4d8b7a4b2a84b9_cgraph.png" border="0" usemap="#namespace_tiled_array_adfc30c5c9b3f17a6ab4d8b7a4b2a84b9_cgraph" alt=""/></div>
<map name="namespace_tiled_array_adfc30c5c9b3f17a6ab4d8b7a4b2a84b9_cgraph" id="namespace_tiled_array_adfc30c5c9b3f17a6ab4d8b7a4b2a84b9_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="221,5,350,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="208,68,363,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="411,29,540,68"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="411,92,540,131"/>
</map>
</div>

</div>
</div>
<a id="aeaa6c8c7926367c10aaae6f056307b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa6c8c7926367c10aaae6f056307b9d">&#9670;&nbsp;</a></span>eigen_map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt;<a class="el" href="class_eigen_1_1_matrix.html">Eigen::Matrix</a>&lt;T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;, Eigen::AutoAlign&gt; TiledArray::eigen_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a> object for a given <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix map for <code>tensor</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">When</td><td><code>tensor</code> dimensions are not equal to 2 or 1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00151">151</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aeaa6c8c7926367c10aaae6f056307b9d_cgraph.png" border="0" usemap="#namespace_tiled_array_aeaa6c8c7926367c10aaae6f056307b9d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aeaa6c8c7926367c10aaae6f056307b9d_cgraph" id="namespace_tiled_array_aeaa6c8c7926367c10aaae6f056307b9d_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="221,5,350,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="208,68,363,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="411,29,540,68"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="411,92,540,131"/>
</map>
</div>

</div>
</div>
<a id="add789e43efcee8db349c7ec5c6218664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add789e43efcee8db349c7ec5c6218664">&#9670;&nbsp;</a></span>eigen_submatrix_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::eigen_submatrix_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a block of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into a tensor. </p>
<p>A block of <code>matrix</code> will be copied into <code>tensor</code>. The block dimensions will be determined by the dimensions of the tensor's range. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
    <tr><td class="paramname">Derived</td><td>The derived type of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The object that will be assigned the content of <code>tensor</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tensor</td><td>The object that will be assigned the content of <code>matrix</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>tensor</code> are not equal to 1 or 2. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of <code>tensor</code> is outside the range of <code>matrix</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00172">172</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_cgraph.png" border="0" usemap="#namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_cgraph" alt=""/></div>
<map name="namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_cgraph" id="namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="253,5,382,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="240,68,395,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="443,29,572,68"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="443,92,572,131"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_icgraph.png" border="0" usemap="#namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_icgraph" alt=""/></div>
<map name="namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_icgraph" id="namespace_tiled_array_add789e43efcee8db349c7ec5c6218664_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af50d31c15b208288edec33a0129649b0" title="Task function for converting Eigen submatrix to a tensor. " alt="" coords="240,5,422,57"/>
</map>
</div>

</div>
</div>
<a id="acc20cb6cde49d2af9af3312a0309f540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc20cb6cde49d2af9af3312a0309f540">&#9670;&nbsp;</a></span>eigen_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::eigen_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix into an Array object. </p>
<p>This function will copy the content of <code>matrix</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. The size of <code><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">world.size()</a></code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in matrix is identical on all nodes. Usage: </p><div class="fragment"><div class="line">Eigen::MatrixXd m(100, 100);</div><div class="line"><span class="comment">// Fill m with data ...</span></div><div class="line"></div><div class="line"><span class="comment">// Create a range for the new array object</span></div><div class="line">std::vector&lt;std::size_t&gt; blocks;</div><div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div><div class="line">  blocks.push_back(i);</div><div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div><div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div><div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div><div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div><div class="line"></div><div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div><div class="line">    eigen_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange, m);</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
    <tr><td class="paramname">Derived</td><td>The <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix derived type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">matrix</td><td>The <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix to be copied </td></tr>
    <tr><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When world size is greater than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If using 2 or more World ranks, set <code>replicated=true</code> and make sure <code>matrix</code> is the same on each rank! </dd></dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00361">361</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_acc20cb6cde49d2af9af3312a0309f540_icgraph.png" border="0" usemap="#namespace_tiled_array_acc20cb6cde49d2af9af3312a0309f540_icgraph" alt=""/></div>
<map name="namespace_tiled_array_acc20cb6cde49d2af9af3312a0309f540_icgraph" id="namespace_tiled_array_acc20cb6cde49d2af9af3312a0309f540_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#adfba97f8c60f13c48f7adfcabc677b95" title="Convert a row&#45;major matrix buffer into an Array object. " alt="" coords="198,5,349,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#a272240d40c483f779f8affc3c12c3285" title="Convert a column&#45;major matrix buffer into an Array object. " alt="" coords="194,68,353,107"/>
</map>
</div>

</div>
</div>
<a id="aad641711c98c1b64bdf7ad28cccfae69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad641711c98c1b64bdf7ad28cccfae69">&#9670;&nbsp;</a></span>exception_break()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::exception_break </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place a break point on this function to stop before <a class="el" href="namespace_tiled_array.html">TiledArray</a> exceptions are thrown. </p>

<p class="definition">Definition at line <a class="el" href="error_8h_source.html#l00063">63</a> of file <a class="el" href="error_8h_source.html">error.h</a>.</p>

</div>
</div>
<a id="a0f1265733604f5af60af78a9d7fa3ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1265733604f5af60af78a9d7fa3ae4">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00143">143</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>

</div>
</div>
<a id="a0c9f9298465a3cb1b6e7a10d5c1cb6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9f9298465a3cb1b6e7a10d5c1cb6bc">&#9670;&nbsp;</a></span>foreach() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename ArgTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile,ArgTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a dense Array. </p>
<p>This function uses an <code>Array</code> object to generate a new <code>Array</code> where the output tiles are a function of the input tiles. Users must provide a function/functor that initializes the tiles for the new <code>Array</code> object. For example, if we want to create a new array with were each element is equal to the square root of the corresponding element of the original array: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;2, double&gt;</a> out_array =</div><div class="line">    <span class="keywordflow">foreach</span>(in_array, [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; out_tile,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; in_tile) {</div><div class="line">      out_tile = in_tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a436d7001abd661cec40f412138d6defd">unary</a>([=] (<span class="keyword">const</span> <span class="keywordtype">double</span> value) -&gt; <span class="keywordtype">double</span></div><div class="line">          { <span class="keywordflow">return</span> std::sqrt(value); });</div><div class="line">    });</div></div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(      <span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;ResultTile,DensePolicy&gt;::value_type</a>&amp; result_tile,</div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;ArgTile,DensePolicy&gt;::value_type</a>&amp; arg_tile);</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
    <tr><td class="paramname">ResultTile</td><td>The tile type of the result array </td></tr>
    <tr><td class="paramname">ArgTile</td><td>The tile type of <code>arg</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00288">288</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a33cf1d21760cdc032308a5045f0f4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cf1d21760cdc032308a5045f0f4380">&#9670;&nbsp;</a></span>foreach() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a dense Array. </p>
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00298">298</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a3eaefa05d5af04d159c459d3efbff5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaefa05d5af04d159c459d3efbff5d6">&#9670;&nbsp;</a></span>foreach() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename ArgTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile,ArgTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a sparse Array. </p>
<p>This function uses an <code>Array</code> object to generate a new <code>Array</code> where the output tiles are a function of the input tiles. Users must provide a function/functor that initializes the tiles for the new <code>Array</code> object. For example, if we want to create a new array with were each element is equal to the square root of the corresponding element of the original array: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;2, double, Tensor&lt;double&gt;</a>, SparsePolicy&gt; out_array =</div><div class="line">    <span class="keywordflow">foreach</span>(in_array, [] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; out_tile,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; in_tile) -&gt; <span class="keywordtype">float</span></div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> norm_squared = 0.0;</div><div class="line">      out_tile = in_tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a436d7001abd661cec40f412138d6defd">unary</a>([&amp;] (<span class="keyword">const</span> <span class="keywordtype">double</span> value) -&gt; <span class="keywordtype">double</span> {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> result = std::sqrt(value);</div><div class="line">        norm_squared += result * result;</div><div class="line">        <span class="keywordflow">return</span> result;</div><div class="line">      });</div><div class="line">      <span class="keywordflow">return</span> std::sqrt(norm_squared);</div><div class="line">    });</div></div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> op(<span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,SparsePolicy&gt;::value_type</a>&amp; result_tile,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,SparsePolicy&gt;::value_type</a>&amp; arg_tile);</div></div><!-- fragment --><p> where the return value of <code>op</code> is the 2-norm (Frobenius norm) of the result tile. </p><dl class="section note"><dt>Note</dt><dd>This function should not be used to initialize the tiles of an array object. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00382">382</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a815db0400e14684f61c1e671d4bbe72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815db0400e14684f61c1e671d4bbe72d">&#9670;&nbsp;</a></span>foreach() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each tile of a sparse Array. </p>
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00392">392</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a8e7c7caefcc685726b2e9b08b11647cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7c7caefcc685726b2e9b08b11647cf">&#9670;&nbsp;</a></span>foreach() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to each tile of dense Arrays The following function takes two input tiles </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00455">455</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="ad48b2eeea37ab5747e688aa5737596da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48b2eeea37ab5747e688aa5737596da">&#9670;&nbsp;</a></span>foreach() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00465">465</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="a521d9d5e5c7f645f582f590f9c525d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521d9d5e5c7f645f582f590f9c525d8b">&#9670;&nbsp;</a></span>foreach() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultTile , typename LeftTile , typename RightTile , typename Op , typename  = typename std::enable_if&lt;!std::is_same&lt;ResultTile, LeftTile&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em> = <code><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to each tile of sparse Arrays The following function takes two input tiles </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00490">490</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="aad5b3898764e80cf91a611a88660274b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5b3898764e80cf91a611a88660274b">&#9670;&nbsp;</a></span>foreach() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::foreach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em> = <code><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of foreach&lt;ResultTile,ArgTile,Op&gt; for the case <code>ResultTile</code> == <code>ArgTile</code> </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00501">501</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>

</div>
</div>
<a id="aaf241d2417d9a9238d8ee8e28c775d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf241d2417d9a9238d8ee8e28c775d1a">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op , typename  = typename std::enable_if&lt;! TiledArray::detail::is_array&lt;typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify each tile of a dense Array. </p>
<p>This function modifies the tile data of <code>Array</code> object. Users must provide a function/functor that modifies the tile data. For example, if we want to modify the elements of the array to be equal to the square root of the original value: </p><div class="fragment"><div class="line"><span class="keywordflow">foreach</span>(array, [] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::TensorD</a>&amp; tile) {</div><div class="line">  tile.<a class="code" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a>([&amp;] (<span class="keywordtype">double</span>&amp; value) { value = std::sqrt(value); });</div><div class="line">});</div></div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(<span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,DensePolicy&gt;::value_type</a>&amp; tile);</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>Mutating tile operation </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The mutating tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array to be modified </td></tr>
    <tr><td class="paramname">fence</td><td>A flag that indicates fencing behavior. If <code>true</code> this function will fence before data is modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function fences by default to avoid data race conditions. Only disable the fence if you can ensure, the data is not being read by another thread. </dd>
<dd>
If there is a another copy of <code>arg</code> that was created via (or arg was created by) the <code>Array</code> copy constructor or copy assignment operator, this function will modify the data of that array since the data of a tile is held in a <code>std::shared_ptr</code>. If you need to ensure other copies of the data are not modified or this behavior causes problems in your application, use the <code><a class="el" href="namespace_tiled_array.html#a0c9f9298465a3cb1b6e7a10d5c1cb6bc" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a></code> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00335">335</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aaf241d2417d9a9238d8ee8e28c775d1a_cgraph.png" border="0" usemap="#namespace_tiled_array_aaf241d2417d9a9238d8ee8e28c775d1a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aaf241d2417d9a9238d8ee8e28c775d1a_cgraph" id="namespace_tiled_array_aaf241d2417d9a9238d8ee8e28c775d1a_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="187,5,331,44"/>
</map>
</div>

</div>
</div>
<a id="a1df16da578538bc1cb4fe3d513b064b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df16da578538bc1cb4fe3d513b064b4">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Op , typename  = typename std::enable_if&lt;! TiledArray::detail::is_array&lt;typename std::decay&lt;Op&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify each tile of a sparse Array. </p>
<p>This function modifies the tile data of <code>Array</code> object. Users must provide a function/functor that modifies the tile data in place. For example, if we want to modify the elements of the array to be equal to the square root of the original value: </p><div class="fragment"><div class="line"><span class="keywordflow">foreach</span>(array, [] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile) -&gt; <span class="keywordtype">float</span> {</div><div class="line">  <span class="keywordtype">double</span> norm_squared = 0.0;</div><div class="line">  tile.<a class="code" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a">inplace_unary</a>([&amp;] (<span class="keywordtype">double</span>&amp; value) {</div><div class="line">    norm_squared += value; <span class="comment">// Assume value &gt;= 0</span></div><div class="line">    value = std::sqrt(value);</div><div class="line">  });</div><div class="line">  <span class="keywordflow">return</span> std::sqrt(norm_squared);</div><div class="line">});</div></div><!-- fragment --><p> The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> op(<span class="keyword">typename</span> <a class="code" href="class_tiled_array_1_1_tile.html">TiledArray::DistArray&lt;Tile,SparsePolicy&gt;::value_type</a>&amp; tile);</div></div><!-- fragment --><p> where the return value of <code>op</code> is the 2-norm (Fibrinous norm) of the tile. </p><dl class="section note"><dt>Note</dt><dd>This function should not be used to initialize the tiles of an array object. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The mutating tile function </td></tr>
    <tr><td class="paramname">arg</td><td>The argument array to be modified </td></tr>
    <tr><td class="paramname">fence</td><td>A flag that indicates fencing behavior. If <code>true</code> this function will fence before data is modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function fences by default to avoid data race conditions. Only disable the fence if you can ensure, the data is not being read by another thread. </dd>
<dd>
If there is a another copy of <code>arg</code> that was created via (or arg was created by) the <code>Array</code> copy constructor or copy assignment operator, this function will modify the data of that array since the data of a tile is held in a <code>std::shared_ptr</code>. If you need to ensure other copies of the data are not modified or this behavior causes problems in your application, use the <code><a class="el" href="namespace_tiled_array.html#a0c9f9298465a3cb1b6e7a10d5c1cb6bc" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a></code> function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00439">439</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a1df16da578538bc1cb4fe3d513b064b4_cgraph.png" border="0" usemap="#namespace_tiled_array_a1df16da578538bc1cb4fe3d513b064b4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a1df16da578538bc1cb4fe3d513b064b4_cgraph" id="namespace_tiled_array_a1df16da578538bc1cb4fe3d513b064b4_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="187,5,331,44"/>
</map>
</div>

</div>
</div>
<a id="ad0657ef2c69d3fcd6354188a1538fbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0657ef2c69d3fcd6354188a1538fbda">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes two input tiles and put result into the left tile. </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00474">474</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad0657ef2c69d3fcd6354188a1538fbda_cgraph.png" border="0" usemap="#namespace_tiled_array_ad0657ef2c69d3fcd6354188a1538fbda_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad0657ef2c69d3fcd6354188a1538fbda_cgraph" id="namespace_tiled_array_ad0657ef2c69d3fcd6354188a1538fbda_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="187,5,331,44"/>
</map>
</div>

</div>
</div>
<a id="a30755f37ccb7ea51d2c4fc3e66e4920a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30755f37ccb7ea51d2c4fc3e66e4920a">&#9670;&nbsp;</a></span>foreach_inplace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeftTile , typename RightTile , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::foreach_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; LeftTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; RightTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em> = <code><a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07a6faa907d79c8bb46a12bea5c8de76654">ShapeReductionMethod::Intersect</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fence</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes two input tiles and put result into the left tile. </p>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00511">511</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a30755f37ccb7ea51d2c4fc3e66e4920a_cgraph.png" border="0" usemap="#namespace_tiled_array_a30755f37ccb7ea51d2c4fc3e66e4920a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a30755f37ccb7ea51d2c4fc3e66e4920a_cgraph" id="namespace_tiled_array_a30755f37ccb7ea51d2c4fc3e66e4920a_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="187,5,331,44"/>
</map>
</div>

</div>
</div>
<a id="a3ebd5da5a1a91c9a3864d2e02e5d3665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebd5da5a1a91c9a3864d2e02e5d3665">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">World&amp; TiledArray::initialize </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SafeMPI::Intracomm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00129">129</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_cgraph.png" border="0" usemap="#namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_cgraph" id="namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#ade0d8d494a8ba801d807d687d1135ef5" title="TiledArray::initialize" alt="" coords="190,5,326,31"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_icgraph.png" border="0" usemap="#namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_icgraph" id="namespace_tiled_array_a3ebd5da5a1a91c9a3864d2e02e5d3665_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#adc942d955cabdb2d06716662c016fa4c" title="TiledArray::initialize" alt="" coords="190,5,326,31"/>
</map>
</div>

</div>
</div>
<a id="adc942d955cabdb2d06716662c016fa4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc942d955cabdb2d06716662c016fa4c">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">World&amp; TiledArray::initialize </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00135">135</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_adc942d955cabdb2d06716662c016fa4c_cgraph.png" border="0" usemap="#namespace_tiled_array_adc942d955cabdb2d06716662c016fa4c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_adc942d955cabdb2d06716662c016fa4c_cgraph" id="namespace_tiled_array_adc942d955cabdb2d06716662c016fa4c_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a3ebd5da5a1a91c9a3864d2e02e5d3665" title="TiledArray::initialize" alt="" coords="190,5,326,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#ade0d8d494a8ba801d807d687d1135ef5" title="TiledArray::initialize" alt="" coords="374,5,511,31"/>
</map>
</div>

</div>
</div>
<a id="ade0d8d494a8ba801d807d687d1135ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0d8d494a8ba801d807d687d1135ef5">&#9670;&nbsp;</a></span>initialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">World&amp; TiledArray::initialize </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="madness_8h_source.html#l00139">139</a> of file <a class="el" href="madness_8h_source.html">madness.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_cgraph.png" border="0" usemap="#namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_cgraph" id="namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a3ebd5da5a1a91c9a3864d2e02e5d3665" title="TiledArray::initialize" alt="" coords="190,5,326,31"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_icgraph.png" border="0" usemap="#namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_icgraph" id="namespace_tiled_array_ade0d8d494a8ba801d807d687d1135ef5_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a3ebd5da5a1a91c9a3864d2e02e5d3665" title="TiledArray::initialize" alt="" coords="190,5,326,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#adc942d955cabdb2d06716662c016fa4c" title="TiledArray::initialize" alt="" coords="374,5,511,31"/>
</map>
</div>

</div>
</div>
<a id="a4bf3ee231866723665a23c1669e4c754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf3ee231866723665a23c1669e4c754">&#9670;&nbsp;</a></span>invoke_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Result  = typename TiledArray::eval_trait&lt;std::decay_t&lt;Arg&gt;&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::invoke_cast </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invokes <a class="el" href="class_tiled_array_1_1_cast.html" title="Tile cast operation. ">TiledArray::Cast</a> to cast/convert the argument to type Result. The operation may be nonblocking, if needed. The cast may involve zero, one, or more conversions, depending on the implementation of Cast&lt;&gt;, and the properties of types Arg and Result. </p>

<p class="definition">Definition at line <a class="el" href="cast_8h_source.html#l00178">178</a> of file <a class="el" href="cast_8h_source.html">cast.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph.png" border="0" usemap="#namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph" id="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1meta.html#a7e24a3a0114c0167e9023e781f5de64b" title="TiledArray::meta::invoke" alt="" coords="213,5,377,31"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph.png" border="0" usemap="#namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph" id="namespace_tiled_array_a4bf3ee231866723665a23c1669e4c754_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_binary_wrapper.html#afb1011caf19968139b97d806150370f5" title="Evaluate two lazy tiles. " alt="" coords="213,5,396,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_unary_wrapper.html#aec85c9c535243c6a7abf1bad6fa53930" title="Evaluate a lazy tile. " alt="" coords="214,68,395,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_unary_wrapper.html#a4ab57577339f9b945fc7a1d95bf78909" title="Consume a lazy tile. " alt="" coords="216,131,393,169"/>
</map>
</div>

</div>
</div>
<a id="a7cd3d9c18d8f36108c03e6ef9429144f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd3d9c18d8f36108c03e6ef9429144f">&#9670;&nbsp;</a></span>make_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Op , typename std::enable_if&lt; is_dense&lt; Array &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> TiledArray::make_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">detail::pmap_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct dense Array. </p>
<p>Construct sparse Array.</p>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> object. Users must provide a world object, tiled range object, and function/functor that generates the tiles for the new array object. For example, if we want to create an array with were the elements are equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TArray&lt;double&gt;</a> out_array =</div><div class="line">    make_array&lt;TiledArray::TArray&lt;double&gt; &gt;(world, trange, pmap,</div><div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; range) {</div><div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div><div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div><div class="line">              *it = 1;</div><div class="line">          });</div></div><!-- fragment --><p> Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object. The expected signature of the tile operation is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div></div><!-- fragment --><p> where <code>tile_t</code> and <code>range_t</code> are your tile type and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code></dd></dl>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> object. Users must provide a world object, tiled range object, process map, and function/ functor that generates the tiles for the new array object. For example, if we want to create an array with all elements equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TSpArray&lt;double&gt;</a> array =</div><div class="line">    make_array&lt;TiledArray::TSpArray&lt;double&gt; &gt;(world, trange, pmap,</div><div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; range) -&gt; <span class="keywordtype">double</span> {</div><div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div><div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div><div class="line">              *it = 1;</div><div class="line">            <span class="keywordflow">return</span> tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a5ab1632ba7a9f67bf9332c521bffff4e">norm</a>();</div><div class="line">          });</div></div><!-- fragment --><p> You may choose not to initialize a tile inside the tile initialization function (not shown in the example) by returning <code>0</code> for the tile norm. Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object unless the returned tile norm is zero. The expected signature of the tile operation is: </p><div class="fragment"><div class="line">value_t op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div></div><!-- fragment --><p> where <code>value_t</code>, <code>tile_t</code> and <code>range_t</code> are your tile value type, tile type, and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">pmap</td><td>A shared pointer to the array process map </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="make__array_8h_source.html#l00071">71</a> of file <a class="el" href="make__array_8h_source.html">make_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph.png" border="0" usemap="#namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph" id="namespace_tiled_array_a7cd3d9c18d8f36108c03e6ef9429144f_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor. " alt="" coords="225,5,369,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a791c7bfbb29bc9e7ebe2963125e5b2d9" title="Set a tile and fill it using a sequence. " alt="" coords="213,68,382,93"/>
</map>
</div>

</div>
</div>
<a id="ad73ea2d1e2e1b222f741f94a3f949e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73ea2d1e2e1b222f741f94a3f949e1c">&#9670;&nbsp;</a></span>make_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> TiledArray::make_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">detail::trange_t</a>&lt; <a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an Array. </p>
<p>This function is used to construct a <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> object. Users must provide a world object, tiled range object, and function/functor that generates the tiles for the new array object. For example, if we want to create an array with were the elements are equal to <code>1</code>: </p><div class="fragment"><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::TSpArray&lt;double&gt;</a> array =</div><div class="line">    make_array&lt;TiledArray::TSpArray&lt;double&gt; &gt;(world, trange,</div><div class="line">          [=] (<a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>&amp; tile, <span class="keyword">const</span> <a class="code" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; range) -&gt; <span class="keywordtype">double</span> {</div><div class="line">            tile = <a class="code" href="class_tiled_array_1_1_tensor.html">TiledArray::Tensor&lt;double&gt;</a>(range);</div><div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; it : tile)</div><div class="line">              *it = 1;</div><div class="line">            <span class="keywordflow">return</span> tile.<a class="code" href="class_tiled_array_1_1_tensor.html#a5ab1632ba7a9f67bf9332c521bffff4e">norm</a>();</div><div class="line">          });</div></div><!-- fragment --><p> For sparse arrays, you may choose not to initialize a tile inside the tile initialization (not shown in the example) by returning <code>0</code> for the tile norm. Note that the result is default constructed before (contains no data) and must be initialized inside the function/functor with the provided range object unless the returned tile norm is zero. The expected signature of the tile operation is: </p><div class="fragment"><div class="line">value_t op(tile_t&amp; tile, <span class="keyword">const</span> range_t&amp; range);</div></div><!-- fragment --><p> where <code>value_t</code>, <code>tile_t</code> and <code>range_t</code> are your tile value type, tile type, and tile range type, respectively. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td>The <code><a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a></code> type </td></tr>
    <tr><td class="paramname">Op</td><td><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the array </td></tr>
    <tr><td class="paramname">op</td><td>The tile function/functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array object of type <code>Array</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="make__array_8h_source.html#l00219">219</a> of file <a class="el" href="make__array_8h_source.html">make_array.h</a>.</p>

</div>
</div>
<a id="ada3e7bc14ca6d99904ada555922fc391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3e7bc14ca6d99904ada555922fc391">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00083">83</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_cgraph.png" border="0" usemap="#namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_cgraph" id="namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="248,5,368,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_icgraph.png" border="0" usemap="#namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_icgraph" id="namespace_tiled_array_ada3e7bc14ca6d99904ada555922fc391_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#aeefa8ea4cb95ebb8c9d9b3809f12dc4d" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="248,12,428,51"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a8aab6018796760c407b5cc53295568ed" title="Task function for converting btas::Tensor subblock to a TiledArray::DistArray. " alt="" coords="476,5,651,57"/>
</map>
</div>

</div>
</div>
<a id="a46acafb5a0d0468803cf0136997b0343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46acafb5a0d0468803cf0136997b0343">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00089">89</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a46acafb5a0d0468803cf0136997b0343_cgraph.png" border="0" usemap="#namespace_tiled_array_a46acafb5a0d0468803cf0136997b0343_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a46acafb5a0d0468803cf0136997b0343_cgraph" id="namespace_tiled_array_a46acafb5a0d0468803cf0136997b0343_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="248,5,368,44"/>
</map>
</div>

</div>
</div>
<a id="a7caf83be84a92371f88fa53b8e100317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7caf83be84a92371f88fa53b8e100317">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00095">95</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a7caf83be84a92371f88fa53b8e100317_cgraph.png" border="0" usemap="#namespace_tiled_array_a7caf83be84a92371f88fa53b8e100317_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a7caf83be84a92371f88fa53b8e100317_cgraph" id="namespace_tiled_array_a7caf83be84a92371f88fa53b8e100317_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="248,5,368,44"/>
</map>
</div>

</div>
</div>
<a id="a9f982e077d43b36c87df64a39f807d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f982e077d43b36c87df64a39f807d47">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00099">99</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9f982e077d43b36c87df64a39f807d47_cgraph.png" border="0" usemap="#namespace_tiled_array_a9f982e077d43b36c87df64a39f807d47_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a9f982e077d43b36c87df64a39f807d47_cgraph" id="namespace_tiled_array_a9f982e077d43b36c87df64a39f807d47_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="248,5,368,44"/>
</map>
</div>

</div>
</div>
<a id="ad84f1b63afe58629a6631314d9e644b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84f1b63afe58629a6631314d9e644b9">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T&gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00105">105</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad84f1b63afe58629a6631314d9e644b9_cgraph.png" border="0" usemap="#namespace_tiled_array_ad84f1b63afe58629a6631314d9e644b9_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad84f1b63afe58629a6631314d9e644b9_cgraph" id="namespace_tiled_array_ad84f1b63afe58629a6631314d9e644b9_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="248,5,368,44"/>
</map>
</div>

</div>
</div>
<a id="a32c66c80be76422ac5593f8c55264032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c66c80be76422ac5593f8c55264032">&#9670;&nbsp;</a></span>make_const_map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T, std::decay_t&lt;Range_&gt; &gt; TiledArray::make_const_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00111">111</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a32c66c80be76422ac5593f8c55264032_cgraph.png" border="0" usemap="#namespace_tiled_array_a32c66c80be76422ac5593f8c55264032_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a32c66c80be76422ac5593f8c55264032_cgraph" id="namespace_tiled_array_a32c66c80be76422ac5593f8c55264032_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="248,5,368,44"/>
</map>
</div>

</div>
</div>
<a id="a4b3f6231b75b996d3fa766849f952eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3f6231b75b996d3fa766849f952eef">&#9670;&nbsp;</a></span>make_map() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00051">51</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_cgraph.png" border="0" usemap="#namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_cgraph" id="namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="208,5,329,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_icgraph.png" border="0" usemap="#namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_icgraph" id="namespace_tiled_array_a4b3f6231b75b996d3fa766849f952eef_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#ae862097c5ca7e7a8affa6275af008f63" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="208,12,347,51"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix. " alt="" coords="395,5,534,57"/>
</map>
</div>

</div>
</div>
<a id="a550c8b83d887c20998b7a696d3ee8111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550c8b83d887c20998b7a696d3ee8111">&#9670;&nbsp;</a></span>make_map() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00056">56</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a550c8b83d887c20998b7a696d3ee8111_cgraph.png" border="0" usemap="#namespace_tiled_array_a550c8b83d887c20998b7a696d3ee8111_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a550c8b83d887c20998b7a696d3ee8111_cgraph" id="namespace_tiled_array_a550c8b83d887c20998b7a696d3ee8111_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="208,5,329,44"/>
</map>
</div>

</div>
</div>
<a id="ac44f97290544cd48a481ff863d7ecdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44f97290544cd48a481ff863d7ecdc8">&#9670;&nbsp;</a></span>make_map() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt;T, std::decay_t&lt;Range_&gt; &gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00062">62</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac44f97290544cd48a481ff863d7ecdc8_cgraph.png" border="0" usemap="#namespace_tiled_array_ac44f97290544cd48a481ff863d7ecdc8_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac44f97290544cd48a481ff863d7ecdc8_cgraph" id="namespace_tiled_array_ac44f97290544cd48a481ff863d7ecdc8_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="208,5,329,44"/>
</map>
</div>

</div>
</div>
<a id="a9e69e843e127604a961c87e9c987cce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e69e843e127604a961c87e9c987cce6">&#9670;&nbsp;</a></span>make_map() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00066">66</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9e69e843e127604a961c87e9c987cce6_cgraph.png" border="0" usemap="#namespace_tiled_array_a9e69e843e127604a961c87e9c987cce6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a9e69e843e127604a961c87e9c987cce6_cgraph" id="namespace_tiled_array_a9e69e843e127604a961c87e9c987cce6_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="208,5,329,44"/>
</map>
</div>

</div>
</div>
<a id="a78cce5a1ed8ed29fc23faee418274512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78cce5a1ed8ed29fc23faee418274512">&#9670;&nbsp;</a></span>make_map() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T&gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00072">72</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a78cce5a1ed8ed29fc23faee418274512_cgraph.png" border="0" usemap="#namespace_tiled_array_a78cce5a1ed8ed29fc23faee418274512_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a78cce5a1ed8ed29fc23faee418274512_cgraph" id="namespace_tiled_array_a78cce5a1ed8ed29fc23faee418274512_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="208,5,329,44"/>
</map>
</div>

</div>
</div>
<a id="aa7755dc3352169ae0eb14cf0b0cf11f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7755dc3352169ae0eb14cf0b0cf11f1">&#9670;&nbsp;</a></span>make_map() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Range_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt;T, std::decay_t&lt;Range_&gt; &gt; TiledArray::make_map </td>
          <td>(</td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Range_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00078">78</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa7755dc3352169ae0eb14cf0b0cf11f1_cgraph.png" border="0" usemap="#namespace_tiled_array_aa7755dc3352169ae0eb14cf0b0cf11f1_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa7755dc3352169ae0eb14cf0b0cf11f1_cgraph" id="namespace_tiled_array_aa7755dc3352169ae0eb14cf0b0cf11f1_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="208,5,329,44"/>
</map>
</div>

</div>
</div>
<a id="a8553a88a5735149954d4d04e491e7358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8553a88a5735149954d4d04e491e7358">&#9670;&nbsp;</a></span>maxabs_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::element_type TiledArray::maxabs_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00076">76</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_cgraph.png" border="0" usemap="#namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_cgraph" id="namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="190,5,332,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="189,68,333,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_icgraph.png" border="0" usemap="#namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_icgraph" id="namespace_tiled_array_a8553a88a5735149954d4d04e491e7358_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="189,5,390,44"/>
</map>
</div>

</div>
</div>
<a id="afc4078d3b132757efef1b74e42575149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4078d3b132757efef1b74e42575149">&#9670;&nbsp;</a></span>minabs_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::element_type TiledArray::minabs_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00070">70</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_afc4078d3b132757efef1b74e42575149_cgraph.png" border="0" usemap="#namespace_tiled_array_afc4078d3b132757efef1b74e42575149_cgraph" alt=""/></div>
<map name="namespace_tiled_array_afc4078d3b132757efef1b74e42575149_cgraph" id="namespace_tiled_array_afc4078d3b132757efef1b74e42575149_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="186,5,328,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="185,68,329,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_afc4078d3b132757efef1b74e42575149_icgraph.png" border="0" usemap="#namespace_tiled_array_afc4078d3b132757efef1b74e42575149_icgraph" alt=""/></div>
<map name="namespace_tiled_array_afc4078d3b132757efef1b74e42575149_icgraph" id="namespace_tiled_array_afc4078d3b132757efef1b74e42575149_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="185,5,386,44"/>
</map>
</div>

</div>
</div>
<a id="ad096df7fd3592ff4515f97a0fc3f98ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad096df7fd3592ff4515f97a0fc3f98ef">&#9670;&nbsp;</a></span>norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>,Policy&gt;::scalar_type TiledArray::norm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00130">130</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_cgraph.png" border="0" usemap="#namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_cgraph" id="namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="181,5,323,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="180,68,324,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_icgraph.png" border="0" usemap="#namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_icgraph" id="namespace_tiled_array_ad096df7fd3592ff4515f97a0fc3f98ef_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="180,5,381,44"/>
</map>
</div>

</div>
</div>
<a id="ab8a725f292ae8f27a3d142e19bedca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a725f292ae8f27a3d142e19bedca1e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dense__shape_8h_source.html#l00179">179</a> of file <a class="el" href="dense__shape_8h_source.html">dense_shape.h</a>.</p>

</div>
</div>
<a id="a49a6fdebe3f7dff3beb2637c2c48809f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a6fdebe3f7dff3beb2637c2c48809f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00231">231</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph.png" border="0" usemap="#namespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph" id="namespace_tiled_array_a49a6fdebe3f7dff3beb2637c2c48809f_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a0de8bd808088bd6375c6dc8a9093b4b6" title="TiledArray::operator==" alt="" coords="203,5,358,31"/>
</map>
</div>

</div>
</div>
<a id="a4282e9e655ef9479b267ac1975d77eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4282e9e655ef9479b267ac1975d77eb6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00305">305</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph.png" border="0" usemap="#namespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph" id="namespace_tiled_array_a4282e9e655ef9479b267ac1975d77eb6_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a0de8bd808088bd6375c6dc8a9093b4b6" title="TiledArray::operator==" alt="" coords="203,5,358,31"/>
</map>
</div>

</div>
</div>
<a id="abc410382ebb92ab3373034a9b54a9a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc410382ebb92ab3373034a9b54a9a78">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> inequality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first range to be compared </td></tr>
    <tr><td class="paramname">r2</td><td>The second range to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>r1</code> does not represent the same range as <code>r2</code>, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01078">1078</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph.png" border="0" usemap="#namespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph" alt=""/></div>
<map name="namespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph" id="namespace_tiled_array_abc410382ebb92ab3373034a9b54a9a78_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="203,5,365,31"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="216,55,352,93"/>
</map>
</div>

</div>
</div>
<a id="a3316fbfa5aa7fe5314bf54670d198bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3316fbfa5aa7fe5314bf54670d198bee">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01489">1489</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a586be997af3bd421583c8fd36c4e95f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586be997af3bd421583c8fd36c4e95f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile. ">Permute</a> a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the array </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">a</td><td>The array to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>a</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00484">484</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph.png" border="0" usemap="#namespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph" id="namespace_tiled_array_a586be997af3bd421583c8fd36c4e95f2_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="197,5,387,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b" title="Create a permuted copy of an array. " alt="" coords="232,55,353,93"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="435,55,556,93"/>
</map>
</div>

</div>
</div>
<a id="a3db915cc9b57726c63e876d1260c50dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db915cc9b57726c63e876d1260c50dc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>permute a <code>std::vector&lt;T&gt;</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00518">518</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph.png" border="0" usemap="#namespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph" id="namespace_tiled_array_a3db915cc9b57726c63e876d1260c50dc_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="197,5,387,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b" title="Create a permuted copy of an array. " alt="" coords="232,55,353,93"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="435,55,556,93"/>
</map>
</div>

</div>
</div>
<a id="a35cf85d544ef5cea5a232dc86766d80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cf85d544ef5cea5a232dc86766d80c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_permute.html" title="Permute a tile. ">Permute</a> a memory buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the memory buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to the memory buffer to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of the memory buffer as a <code>std::vector</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00548">548</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph.png" border="0" usemap="#namespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph" id="namespace_tiled_array_a35cf85d544ef5cea5a232dc86766d80c_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="197,5,387,31"/>
</map>
</div>

</div>
</div>
<a id="a2b7b0326fbc5daaf9df0298d58e7df49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7b0326fbc5daaf9df0298d58e7df49">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> multiplication operator. </p>
<p>Element-wise multiplication of two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] * right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00080">80</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a93accba5edcc96b461552d4a9483ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93accba5edcc96b461552d4a9483ec3d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>left</code> that is scaled by <code>right</code>. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> a tensor </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code> left[i] * right </code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00097">97</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="ae22953e4bba13494766ec2fc06ea1744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22953e4bba13494766ec2fc06ea1744">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N , typename T , typename std::enable_if&lt; detail::is_numeric&lt; N &gt;::value &amp;&amp;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of <code>right</code> that is scaled by <code>left</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>A numeric type </td></tr>
    <tr><td class="paramname">T</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand scalar argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code> left * right[i] </code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00112">112</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a5b58b8591b03eebae61c177036697562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b58b8591b03eebae61c177036697562">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The argument tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>arg</code> </td></tr>
    <tr><td class="paramname">arg</td><td>The argument tensor to be permuted </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00137">137</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a2b1fa4c93060bc503429e3527f2993ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1fa4c93060bc503429e3527f2993ad">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array. ">TiledRange</a> permutation operator. </p>
<p>This function will permute the range. Note: only tiles that are not being used by other objects will be permuted. The owner of those objects are </p>

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00288">288</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph.png" border="0" usemap="#namespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph" id="namespace_tiled_array_a2b1fa4c93060bc503429e3527f2993ad_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range. " alt="" coords="214,5,370,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="211,68,373,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="197,117,387,143"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="232,167,353,205"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tiled_range.html#a9ab6d42af2997036d41180dfd5439544" title="Tile dimension boundary array accessor. " alt="" coords="214,229,370,268"/>
</map>
</div>

</div>
</div>
<a id="a678f80db611a7af38027953b96bc8f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f80db611a7af38027953b96bc8f0d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the range </td></tr>
    <tr><td class="paramname">r</td><td>The range to be permuted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A permuted copy of <code>r</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01058">1058</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>

</div>
</div>
<a id="ae84ce21d711a462da4a1b44a811a5a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84ce21d711a462da4a1b44a811a5a94">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; &amp; TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place permute a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the array </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>The array to be permuted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>a</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00501">501</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph.png" border="0" usemap="#namespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph" id="namespace_tiled_array_ae84ce21d711a462da4a1b44a811a5a94_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="205,5,395,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b" title="Create a permuted copy of an array. " alt="" coords="239,55,360,93"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="443,55,564,93"/>
</map>
</div>

</div>
</div>
<a id="a4beab363e9a6e97343bc39965e548f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4beab363e9a6e97343bc39965e548f95">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T, A &gt; &amp; TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place permute a <code>std::array</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the vector </td></tr>
    <tr><td class="paramname">A</td><td>The allocator type of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The vector to be permuted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>v</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimension of the permutation is not equal to the size of <code>v</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00535">535</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph.png" border="0" usemap="#namespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph" id="namespace_tiled_array_a4beab363e9a6e97343bc39965e548f95_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b" title="Create a permuted copy of an array. " alt="" coords="205,5,326,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="374,5,495,44"/>
</map>
</div>

</div>
</div>
<a id="aaf25c7dbd596cf41749f0c284a09eafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf25c7dbd596cf41749f0c284a09eafd">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor multiplication. </p>
<p>Multiply the elements of left by that of right </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00185">185</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a1493d57cb2d466240eeaef8e173cf6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493d57cb2d466240eeaef8e173cf6b2">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator*= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor scale. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00234">234</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a70044a879bcceefda052fe65023bb378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70044a879bcceefda052fe65023bb378">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator. </p>
<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] + right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00048">48</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a9f076f0602b99660440a31b1290dcba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f076f0602b99660440a31b1290dcba7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> plus operator. </p>
<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> the elements of <code>right</code> to that of <code>left</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] + right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00153">153</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a868921cf563ff1fb9f3304bc314fec22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868921cf563ff1fb9f3304bc314fec22">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator+= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor add constant. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00202">202</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="ac6846288ddd37fd160c0afcdf72ce03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6846288ddd37fd160c0afcdf72ce03b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator- </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator. </p>
<p>Subtract two tensors </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>left[i] - right[i]</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00064">64</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="ac90b5d6c5aae4293d2b9d3456477aeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90b5d6c5aae4293d2b9d3456477aeba">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; decltype(arg.neg())
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a negated copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of <code>arg</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The argument tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor where element <code>i</code> is equal to <code>-arg</code>[i] </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00124">124</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a21ca0c0a8f3a232c9d615ffd6e84e41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ca0c0a8f3a232c9d615ffd6e84e41f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt; detail::is_tensor&lt; T1, T2 &gt;::value||detail::is_tensor_of_tensor&lt; T1, T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> minus operator. </p>
<p>Subtract the elements of <code>right</code> from that of <code>left</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00169">169</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="acf3890c67d7f105e091e0f6114b9c56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3890c67d7f105e091e0f6114b9c56c">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename N , typename std::enable_if&lt;(detail::is_tensor&lt; T &gt;::value||detail::is_tensor_of_tensor&lt; T &gt;::value) &amp;&amp;detail::is_numeric&lt; N &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::operator-= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In place tensor subtract constant. </p>
<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> the elements of <code>left</code> by <code>right</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">N</td><td>Numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor argument </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand scalar argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>left</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="operators_8h_source.html#l00218">218</a> of file <a class="el" href="operators_8h_source.html">operators.h</a>.</p>

</div>
</div>
<a id="a67d07017bf139b8ea4e344216443b372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d07017bf139b8ea4e344216443b372">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; detail::is_tensor&lt; T &gt;::value &amp;&amp;detail::is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> output operator. </p>
<p>Output tensor <code>t</code> to the output stream, <code>os</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">t</td><td>The tensor to be output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00060">60</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a3e4d830e8d3e6b0c3ef4db415eeed8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4d830e8d3e6b0c3ef4db415eeed8f3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> ostream operator. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00236">236</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph.png" border="0" usemap="#namespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph" id="namespace_tiled_array_a3e4d830e8d3e6b0c3ef4db415eeed8f3_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range1.html#a5d8f926b068df683395ba689aa587a9d" title="Tile range accessor. " alt="" coords="208,5,372,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tiled_range1.html#aca8acf1ed5dc95ace1edbab47487f6e3" title="Elements range accessor. " alt="" coords="208,68,372,107"/>
</map>
</div>

</div>
</div>
<a id="ac42dd6da4a499c34371973b91d3529c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42dd6da4a499c34371973b91d3529c0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00309">309</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph.png" border="0" usemap="#namespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph" id="namespace_tiled_array_ac42dd6da4a499c34371973b91d3529c0_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range. " alt="" coords="208,5,364,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range. " alt="" coords="208,68,364,107"/>
</map>
</div>

</div>
</div>
<a id="a8044f7d779135e7bc782943d785a0fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8044f7d779135e7bc782943d785a0fc5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> the tensor to an output stream. </p>
<p>This function will iterate through all tiles on node 0 and print non-zero tiles. It will wait for each tile to be evaluated (i.e. it is a blocking function). Tasks will continue to be processed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of Array </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The <a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array to be put in the output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="dist__array_8h_source.html#l00853">853</a> of file <a class="el" href="dist__array_8h_source.html">dist_array.h</a>.</p>

</div>
</div>
<a id="a00568c34aef7e5f9b2802cbdd4382ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00568c34aef7e5f9b2802cbdd4382ea5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> output operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream that will be used to print <code>r</code> </td></tr>
    <tr><td class="paramname">r</td><td>The range to be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01088">1088</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph.png" border="0" usemap="#namespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph" id="namespace_tiled_array_a00568c34aef7e5f9b2802cbdd4382ea5_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object. " alt="" coords="228,5,349,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="221,68,356,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="208,131,369,156"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#af38569cb05cfd8691647b1be6c702a4b" title="Range upper bound data accessor. " alt="" coords="221,180,356,219"/>
</map>
</div>

</div>
</div>
<a id="a9b4eb5173fc9dae94dd7a1a012f42b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4eb5173fc9dae94dd7a1a012f42b4d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_sparse_shape.html">SparseShape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_add.html" title="Add tile operation. ">Add</a> the shape to an output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the numeric type supporting the type of <code>shape</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">shape</td><td>the SparseShape&lt;T&gt; object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the output stream </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__shape_8h_source.html#l01158">1158</a> of file <a class="el" href="sparse__shape_8h_source.html">sparse_shape.h</a>.</p>

</div>
</div>
<a id="a0de8bd808088bd6375c6dc8a9093b4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de8bd808088bd6375c6dc8a9093b4b6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dense_shape.html">DenseShape</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dense__shape_8h_source.html#l00178">178</a> of file <a class="el" href="dense__shape_8h_source.html">dense_shape.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a0de8bd808088bd6375c6dc8a9093b4b6_icgraph.png" border="0" usemap="#namespace_tiled_array_a0de8bd808088bd6375c6dc8a9093b4b6_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a0de8bd808088bd6375c6dc8a9093b4b6_icgraph" id="namespace_tiled_array_a0de8bd808088bd6375c6dc8a9093b4b6_icgraph">
<area shape="rect" id="node2" href="group__symmetry.html#gab38342dbdaa26d0f24c1633f77c6555d" title="Permutation inequality operator. " alt="" coords="208,5,358,31"/>
</map>
</div>

</div>
</div>
<a id="a9e0508aa5150620ac2a2a5476c6c5612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0508aa5150620ac2a2a5476c6c5612">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00225">225</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph.png" border="0" usemap="#namespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph" id="namespace_tiled_array_a9e0508aa5150620ac2a2a5476c6c5612_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range1.html#a804300d74a4872393801144e33ad9963" title="Returns an iterator to the first tile in the range. " alt="" coords="222,5,387,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tiled_range1.html#a7325e80dbe95df50fbee3baa8669f54a" title="Returns an iterator to the end of the range. " alt="" coords="208,68,401,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tiled_range1.html#a5d8f926b068df683395ba689aa587a9d" title="Tile range accessor. " alt="" coords="222,117,387,156"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tiled_range1.html#aca8acf1ed5dc95ace1edbab47487f6e3" title="Elements range accessor. " alt="" coords="222,180,387,219"/>
</map>
</div>

</div>
</div>
<a id="a95a1447230c9a5ca4906ee3684cbe890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a1447230c9a5ca4906ee3684cbe890">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true when all tile and element ranges are the same. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00299">299</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph.png" border="0" usemap="#namespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph" id="namespace_tiled_array_a95a1447230c9a5ca4906ee3684cbe890_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range. " alt="" coords="210,5,367,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="208,68,369,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range. " alt="" coords="210,117,367,156"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tiled_range.html#a9ab6d42af2997036d41180dfd5439544" title="Tile dimension boundary array accessor. " alt="" coords="210,180,367,219"/>
</map>
</div>

</div>
</div>
<a id="ac25a0fb0ad765d6c6a383c67d403fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25a0fb0ad765d6c6a383c67d403fc57">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> equality comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first range to be compared </td></tr>
    <tr><td class="paramname">r2</td><td>The second range to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>r1</code> represents the same range as <code>r2</code>, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01068">1068</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph.png" border="0" usemap="#namespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph" id="namespace_tiled_array_ac25a0fb0ad765d6c6a383c67d403fc57_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="208,5,369,31"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="221,55,356,93"/>
</map>
</div>

</div>
</div>
<a id="a15916eaafd6285509fe08919de285f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15916eaafd6285509fe08919de285f23">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_2tensor_8h_source.html#l01485">1485</a> of file <a class="el" href="tensor_2tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9d88c1636531adbd9b9aac5ead3f3e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d88c1636531adbd9b9aac5ead3f3e0e">&#9670;&nbsp;</a></span>permute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::permute </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be permuted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ arg</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2permute_8h_source.html#l00043">43</a> of file <a class="el" href="tile__interface_2permute_8h_source.html">permute.h</a>.</p>

</div>
</div>
<a id="ad7ce148a0f9ea7a739139fd97e16bc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ce148a0f9ea7a739139fd97e16bc4c">&#9670;&nbsp;</a></span>permute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Perm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> TiledArray::permute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00285">285</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ad7ce148a0f9ea7a739139fd97e16bc4c_icgraph.png" border="0" usemap="#namespace_tiled_array_ad7ce148a0f9ea7a739139fd97e16bc4c_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ad7ce148a0f9ea7a739139fd97e16bc4c_icgraph" id="namespace_tiled_array_ad7ce148a0f9ea7a739139fd97e16bc4c_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1tile__interface_1_1_permute.html#a71242190a31dfc7bea92e1a78159f509" title="TiledArray::tile_interface\l::Permute\&lt; Result, Arg \&gt;\l::operator()" alt="" coords="204,5,372,57"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1tile__interface_1_1_permute_3_01_result_00_01_arg_00_01typename_01std_1_1en812316f74441eca8e20a0e4b131d53a4.html#af08af1ff540dd0d9ed89bf6e362f5377" title="TiledArray::tile_interface\l::Permute\&lt; Result, Arg,\l typename std::enable_if\l\&lt; ! std::is_same\&lt; Result,\l result_of_permute_t\&lt; Arg \&gt;\l \&gt;::value \&gt;::type \&gt;::operator()" alt="" coords="191,81,385,173"/>
<area shape="rect" id="node4" href="group___tile_interface.html#ga49621c8ce21243534fb83247c3cfb6ea" title="Create a permuted copy of arg. " alt="" coords="219,197,357,223"/>
<area shape="rect" id="node5" href="group___tile_interface.html#ga5617e099b3bb93c7f6d0bf98e89e5a4e" title="Permute tile operator. " alt="" coords="216,247,360,272"/>
</map>
</div>

</div>
</div>
<a id="aadfd4a5d0073f766aeca78185b841a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfd4a5d0073f766aeca78185b841a30">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00135">135</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a id="ac6a59d75845f7586427931c3d854e70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a59d75845f7586427931c3d854e70e">&#9670;&nbsp;</a></span>remap() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42a0cd1e1736b072b51f1d438c74575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a0cd1e1736b072b51f1d438c74575a">&#9670;&nbsp;</a></span>remap() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34d05db90b5aba567b8653f980ab3310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d05db90b5aba567b8653f980ab3310">&#9670;&nbsp;</a></span>remap() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6ca6dca916f81f03b3043771187db57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ca6dca916f81f03b3043771187db57">&#9670;&nbsp;</a></span>remap() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">detail::TensorInterface</a>&lt; const T, <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af647aa352f5f2099f6c4ee3ca8c1ba39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af647aa352f5f2099f6c4ee3ca8c1ba39">&#9670;&nbsp;</a></span>remap() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For reusing map without allocating new ranges . . . maybe. </p>

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00116">116</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_af647aa352f5f2099f6c4ee3ca8c1ba39_cgraph.png" border="0" usemap="#namespace_tiled_array_af647aa352f5f2099f6c4ee3ca8c1ba39_cgraph" alt=""/></div>
<map name="namespace_tiled_array_af647aa352f5f2099f6c4ee3ca8c1ba39_cgraph" id="namespace_tiled_array_af647aa352f5f2099f6c4ee3ca8c1ba39_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="180,5,301,44"/>
</map>
</div>

</div>
</div>
<a id="ac74a8861c632bb1899465cfc486b6e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74a8861c632bb1899465cfc486b6e22">&#9670;&nbsp;</a></span>remap() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00124">124</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ac74a8861c632bb1899465cfc486b6e22_cgraph.png" border="0" usemap="#namespace_tiled_array_ac74a8861c632bb1899465cfc486b6e22_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ac74a8861c632bb1899465cfc486b6e22_cgraph" id="namespace_tiled_array_ac74a8861c632bb1899465cfc486b6e22_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="180,5,301,44"/>
</map>
</div>

</div>
</div>
<a id="a25147c8d3ed11d8724a3092c745fa6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25147c8d3ed11d8724a3092c745fa6e3">&#9670;&nbsp;</a></span>remap() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a35af09371a3551f27d53d90a059931fd">TensorMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00131">131</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a25147c8d3ed11d8724a3092c745fa6e3_cgraph.png" border="0" usemap="#namespace_tiled_array_a25147c8d3ed11d8724a3092c745fa6e3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a25147c8d3ed11d8724a3092c745fa6e3_cgraph" id="namespace_tiled_array_a25147c8d3ed11d8724a3092c745fa6e3_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="180,5,301,44"/>
</map>
</div>

</div>
</div>
<a id="a50dcfc333a6edc4f323691954f799699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dcfc333a6edc4f323691954f799699">&#9670;&nbsp;</a></span>remap() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::remap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#a380d0c9b978b651c0e4af14e63baf2e0">TensorConstMap</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor__map_8h_source.html#l00140">140</a> of file <a class="el" href="tensor__map_8h_source.html">tensor_map.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a50dcfc333a6edc4f323691954f799699_cgraph.png" border="0" usemap="#namespace_tiled_array_a50dcfc333a6edc4f323691954f799699_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a50dcfc333a6edc4f323691954f799699_cgraph" id="namespace_tiled_array_a50dcfc333a6edc4f323691954f799699_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="180,5,301,44"/>
</map>
</div>

</div>
</div>
<a id="adfba97f8c60f13c48f7adfcabc677b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfba97f8c60f13c48f7adfcabc677b95">&#9670;&nbsp;</a></span>row_major_buffer_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">A TiledArray::row_major_buffer_to_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::trange_type &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::value_type::value_type *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>replicated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a row-major matrix buffer into an Array object. </p>
<p>This function will copy the content of <code>buffer</code> into an <code>Array</code> object that is tiled according to the <code>trange</code> object. The copy operation is done in parallel, and this function will block until all elements of <code>matrix</code> have been copied into the result array tiles. The size of <code><a class="el" href="namespace_tiled_array.html#afc51ed34e98a417052d745d91994de70">world.size()</a></code> must be equal to 1 or <code>replicate</code> must be equal to <code>true</code> . If <code>replicate</code> is <code>true</code>, it is your responsibility to ensure that the data in <code>buffer</code> is identical on all nodes. Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span>* buffer = <span class="keyword">new</span> <span class="keywordtype">double</span>[100 * 100];</div><div class="line"><span class="comment">// Fill buffer with data ...</span></div><div class="line"></div><div class="line"><span class="comment">// Create a range for the new array object</span></div><div class="line">std::vector&lt;std::size_t&gt; blocks;</div><div class="line"><span class="keywordflow">for</span>(std::size_t i = 0ul; i &lt;= 100ul; i += 10ul)</div><div class="line">  blocks.push_back(i);</div><div class="line">std::array&lt;TiledArray::TiledRange1, 2&gt; blocks2 =</div><div class="line">    {{ <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()),</div><div class="line">       <a class="code" href="class_tiled_array_1_1_tiled_range1.html">TiledArray::TiledRange1</a>(blocks.begin(), blocks.end()) }};</div><div class="line"><a class="code" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> trange(blocks2.begin(), blocks2.end());</div><div class="line"></div><div class="line"><span class="comment">// Create an Array from an Eigen matrix.</span></div><div class="line"><a class="code" href="class_tiled_array_1_1_dist_array.html">TiledArray::Array&lt;double, 2&gt;</a> array =</div><div class="line">    row_major_buffer_to_array&lt;TiledArray::Array&lt;double, 2&gt; &gt;(world, trange, buffer, 100, 100);</div><div class="line"></div><div class="line"><span class="keyword">delete</span> [] buffer;</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world where the array will live </td></tr>
    <tr><td class="paramname">trange</td><td>The tiled range of the new array </td></tr>
    <tr><td class="paramname">buffer</td><td>The row-major matrix buffer to be copied </td></tr>
    <tr><td class="paramname">m</td><td>The number of rows in the matrix </td></tr>
    <tr><td class="paramname">n</td><td>The number of columns in the matrix </td></tr>
    <tr><td class="paramname">replicated</td><td><code>true</code> indicates that the result array should be a replicated array [default = false]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <code>Array</code> object that is a copy of <code>matrix</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When <code>m</code> and <code>n</code> are not equal to the number of rows or columns in tiled range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00520">520</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_adfba97f8c60f13c48f7adfcabc677b95_cgraph.png" border="0" usemap="#namespace_tiled_array_adfba97f8c60f13c48f7adfcabc677b95_cgraph" alt=""/></div>
<map name="namespace_tiled_array_adfba97f8c60f13c48f7adfcabc677b95_cgraph" id="namespace_tiled_array_adfba97f8c60f13c48f7adfcabc677b95_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#acc20cb6cde49d2af9af3312a0309f540" title="Convert an Eigen matrix into an Array object. " alt="" coords="205,5,345,44"/>
</map>
</div>

</div>
</div>
<a id="acf92d0f99f726bc096fe6e7c6a6bee7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92d0f99f726bc096fe6e7c6a6bee7b">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::scale </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar the tile argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The left-hand argument to be scaled </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>arg * factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale_8h_source.html#l00044">44</a> of file <a class="el" href="scale_8h_source.html">scale.h</a>.</p>

</div>
</div>
<a id="a3b4cf3997e177142f13f593335352b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4cf3997e177142f13f593335352b48">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::scale </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> and permute tile argument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The left-hand argument to be scaled </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>perm ^ (arg * factor)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale_8h_source.html#l00057">57</a> of file <a class="el" href="scale_8h_source.html">scale.h</a>.</p>

</div>
</div>
<a id="a90e2f4b420375c45a2c21049e27377aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e2f4b420375c45a2c21049e27377aa">&#9670;&nbsp;</a></span>scale() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt;::element_type&#160;</td>
          <td class="paramname"><em>scaling_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00108">108</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_cgraph.png" border="0" usemap="#namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_cgraph" id="namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="174,5,316,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="173,68,317,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_icgraph.png" border="0" usemap="#namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_icgraph" id="namespace_tiled_array_a90e2f4b420375c45a2c21049e27377aa_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="654,37,855,76"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_d_i_i_s.html#adba4b9aeb0b361453aeb9c48c1dd992a" title="TiledArray::DIIS::compute\l_extrapolation_parameters" alt="" coords="182,68,362,107"/>
<area shape="rect" id="node5" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc" title="Scalar the tile argument. " alt="" coords="212,131,332,156"/>
<area shape="rect" id="node6" href="group___tile_interface.html#gad452632b571bcbcc3be78b202e8a0a75" title="Scale tile operator. " alt="" coords="200,180,344,205"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1tile__interface_1_1_scale.html#a6399e0a5c2048cfcbd4332b0d8bf2f42" title="TiledArray::tile_interface\l::Scale\&lt; Result, Arg, Scalar\l \&gt;::operator()" alt="" coords="180,229,364,281"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1tile__interface_1_1_scale_3_01_result_00_01_arg_00_01_scalar_00_01typename_fbbb6b916c02e7c08977e87d208f321e.html#abcea4ac4ba21d246fade20533a526e70" title="TiledArray::tile_interface\l::Scale\&lt; Result, Arg, Scalar,\l typename std::enable_if\&lt; !\l std::is_same\&lt; Result, result\l_of_scale_t\&lt; Arg, Scalar \&gt; \&gt;::\lvalue \&gt;::type \&gt;::operator()" alt="" coords="173,305,370,397"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1detail_1_1_scal_shift.html#a47e1706841cce77ac84f234c6f80312c" title="TiledArray::detail\l::ScalShift::eval" alt="" coords="211,421,332,460"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_d_i_i_s.html#a6fd568abd2246acbc0f6ea1ee6e20905" title="TiledArray::DIIS::extrapolate" alt="" coords="418,72,606,97"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1detail_1_1_scal_shift.html#ad1bc34cea69e4271db8b2bb42a966959" title="Shift and permute operator. " alt="" coords="439,421,586,460"/>
</map>
</div>

</div>
</div>
<a id="ac10222cde45203777a4b3a6dc2d2d72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10222cde45203777a4b3a6dc2d2d72d">&#9670;&nbsp;</a></span>scale_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Scalar , typename std::enable_if&lt; TiledArray::detail::is_numeric&lt; Scalar &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result&amp; TiledArray::scale_to </td>
          <td>(</td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_scale.html" title="Scale tile. ">Scale</a> to the result tile. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>The result tile type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The result tile to be scaled </td></tr>
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that is equal to <code>result *= factor</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale_8h_source.html#l00069">69</a> of file <a class="el" href="scale_8h_source.html">scale.h</a>.</p>

</div>
</div>
<a id="a18c36d711dfadf00bc96c9f10bde6776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c36d711dfadf00bc96c9f10bde6776">&#9670;&nbsp;</a></span>shift() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>range_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of <code>arg</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Index</td><td>An array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be shifted </td></tr>
    <tr><td class="paramname">range_shift</td><td>The offset to be applied to the argument range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tile with a new range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2shift_8h_source.html#l00042">42</a> of file <a class="el" href="tile__interface_2shift_8h_source.html">shift.h</a>.</p>

</div>
</div>
<a id="a3ed423a0b023a4a5aadfb5012d968a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed423a0b023a4a5aadfb5012d968a4a">&#9670;&nbsp;</a></span>shift() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt;T&gt; TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> a tensor from one range to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted tensor object </dd></dl>

<p class="definition">Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00136">136</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph.png" border="0" usemap="#namespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph" id="namespace_tiled_array_a3ed423a0b023a4a5aadfb5012d968a4a_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1expressions_1_1_expr.html#a10319000c0fd7c82c1428782621df81b" title="Evaluate this object and assign it to tsr. " alt="" coords="179,5,360,57"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_sparse_shape.html#a549436f74139ee1b7bcdfbe50b1fafc2" title="Create a copy of a sub&#45;block of the shape. " alt="" coords="184,81,354,120"/>
<area shape="rect" id="node5" href="group___tile_interface.html#ga91b9ad4c6f5c4ce7928e61669c37844a" title="Shift the range of arg. " alt="" coords="213,144,326,169"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1tile__interface_1_1_shift.html#ae41095dcbe777304303fc0baef920ab3" title="TiledArray::tile_interface\l::Shift\&lt; Result, Arg \&gt;::\loperator()" alt="" coords="187,193,352,245"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1tile__interface_1_1_shift_3_01_result_00_01_arg_00_01typename_01std_1_1enaba1f16f35b49d9bf454dc63eca4f57dd4.html#a28c60f6bf6db66a86c9a30eeb5dcdc8d" title="TiledArray::tile_interface\l::Shift\&lt; Result, Arg, typename\l std::enable_if\&lt; ! std::is_same\l\&lt; Result, result_of_shift_t\&lt; Arg\l \&gt; \&gt;::value \&gt;::type \&gt;::operator()" alt="" coords="167,269,372,348"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_sparse_shape.html#ac31c86f6d199f7a5ee8cef404de0c449" title="Create a copy of a sub&#45;block of the shape. " alt="" coords="420,81,590,120"/>
</map>
</div>

</div>
</div>
<a id="a62b1b3fec016be7c5ed4230f72e5b29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b1b3fec016be7c5ed4230f72e5b29d">&#9670;&nbsp;</a></span>shift() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">detail::ShiftWrapper</a>&lt;const T&gt; TiledArray::shift </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> a tensor from one range to another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor object to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shifted tensor object </dd></dl>

<p class="definition">Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00147">147</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>

</div>
</div>
<a id="a7d3cfd4f0d7939415e0c5455f6dd36c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3cfd4f0d7939415e0c5455f6dd36c2">&#9670;&nbsp;</a></span>shift_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::shift_to </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>range_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_shift.html" title="Shift the range of tile. ">Shift</a> the range of <code>arg</code> in place. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The tile argument type </td></tr>
    <tr><td class="paramname">Index</td><td>An array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The tile argument to be shifted </td></tr>
    <tr><td class="paramname">range_shift</td><td>The offset to be applied to the argument range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the tile with a new range </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile__interface_2shift_8h_source.html#l00054">54</a> of file <a class="el" href="tile__interface_2shift_8h_source.html">shift.h</a>.</p>

</div>
</div>
<a id="afc51ed34e98a417052d745d91994de70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc51ed34e98a417052d745d91994de70">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t TiledArray::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00049">49</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_afc51ed34e98a417052d745d91994de70_cgraph.png" border="0" usemap="#namespace_tiled_array_afc51ed34e98a417052d745d91994de70_cgraph" alt=""/></div>
<map name="namespace_tiled_array_afc51ed34e98a417052d745d91994de70_cgraph" id="namespace_tiled_array_afc51ed34e98a417052d745d91994de70_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a2978e91e67813dcd47b83864865e9134" title="TiledArray::DistArray\l::size" alt="" coords="166,5,310,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="166,68,310,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_afc51ed34e98a417052d745d91994de70_icgraph.png" border="0" usemap="#namespace_tiled_array_afc51ed34e98a417052d745d91994de70_icgraph" alt=""/></div>
<map name="namespace_tiled_array_afc51ed34e98a417052d745d91994de70_icgraph" id="namespace_tiled_array_afc51ed34e98a417052d745d91994de70_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="166,5,367,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_block_range.html#a05bebb6ba9b6cfbbc3c1215b45d6a102" title="calculate the coordinate index of the ordinal index, index. " alt="" coords="186,68,347,107"/>
<area shape="rect" id="node4" href="namespacebtas.html#a78a456bd67717bd0752681a9dc5f000b" title="btas::squared_norm" alt="" coords="197,131,336,156"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1math_1_1_matrix_block_task.html#a452518cd6c715380db1a21d408fb8d74" title="TiledArray::math::Matrix\lBlockTask::result" alt="" coords="185,180,348,219"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_dense_policy.html#a2fee774f3a4b7b5d3c9aba3ea8af7c3f" title="Create a default process map. " alt="" coords="185,243,348,281"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_sparse_policy.html#a94a435055f28049a34bf37fc563882d7" title="Create a default process map. " alt="" coords="183,305,350,344"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_range.html#ae5e7eefde499cee60bc2bd63c47f63bb" title="calculate the coordinate index of the ordinal index, index. " alt="" coords="190,368,343,393"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_sparse_shape.html#a6e638781d0d2ec4347947b7ed627b9e5" title="TiledArray::SparseShape::add" alt="" coords="167,417,366,443"/>
</map>
</div>

</div>
</div>
<a id="ae8fd6c6add8ea900d7d2350fbe652390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fd6c6add8ea900d7d2350fbe652390">&#9670;&nbsp;</a></span>sparse_diagonal_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;T&gt;, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::sparse_diagonal_array </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">DistArray</a> with only diagonal elements, the expected behavior is that every element (n,n,n, ..., n) will be nonzero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">world</td><td>The world for the array </td></tr>
    <tr><td class="paramname">trange</td><td>The trange for the array </td></tr>
    <tr><td class="paramname">val</td><td>The value to be written along the diagonal elements </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00158">158</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae8fd6c6add8ea900d7d2350fbe652390_cgraph.png" border="0" usemap="#namespace_tiled_array_ae8fd6c6add8ea900d7d2350fbe652390_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae8fd6c6add8ea900d7d2350fbe652390_cgraph" id="namespace_tiled_array_ae8fd6c6add8ea900d7d2350fbe652390_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699" title="TiledArray::detail\l::diagonal_shape" alt="" coords="193,194,316,233"/>
<area shape="rect" id="node16" href="namespace_tiled_array_1_1detail.html#a31b41f257f8f107174ffbfd3b9e7c0c3" title="TiledArray::detail\l::write_tiles_to_array" alt="" coords="182,468,327,506"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range. " alt="" coords="594,41,751,80"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range. " alt="" coords="381,40,538,78"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#adc6eb6d7ffa9defd3c7e6aae88080b2b" title="Range extent accessor. " alt="" coords="391,165,527,204"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_tiled_range.html#ac8c1d53822fd3da51824e4d97a11dd2a" title="The rank accessor. " alt="" coords="594,226,751,265"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_tiled_range.html#a86b5cfd5057656694062f4498d548be8" title="Convert an element index to a tile index. " alt="" coords="381,280,538,318"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1_tiled_range.html#a7d6579a946eb52c648b440a5f7d087d8" title="Construct a range for the tile indexed by the given ordinal index. " alt="" coords="381,102,538,141"/>
<area shape="rect" id="node11" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="TiledArray::detail\l::diagonal_range" alt="" coords="399,342,520,381"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_range.html#afd7dd885ff139cc535b8f1e42a4442f3" title="Range extent data accessor. " alt="" coords="605,164,740,202"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="592,289,753,314"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="605,341,740,380"/>
<area shape="rect" id="node14" href="class_tiled_array_1_1_range.html#ad59f6239bab9c89dac6fcccd6dbf8505" title="Range upper bound accessor. " alt="" coords="605,404,740,442"/>
<area shape="rect" id="node13" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="801,341,937,380"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1_range.html#af38569cb05cfd8691647b1be6c702a4b" title="Range upper bound data accessor. " alt="" coords="801,404,937,442"/>
<area shape="rect" id="node17" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="387,405,531,444"/>
<area shape="rect" id="node18" href="class_tiled_array_1_1_dist_array.html#a70e45de02ea9820e6546dc06521c76f0" title="Check if the tile at index i is stored locally. " alt="" coords="387,468,531,506"/>
<area shape="rect" id="node19" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="387,530,531,569"/>
<area shape="rect" id="node20" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="387,593,531,632"/>
<area shape="rect" id="node21" href="class_tiled_array_1_1_dist_array.html#a791c7bfbb29bc9e7ebe2963125e5b2d9" title="Set a tile and fill it using a sequence. " alt="" coords="375,656,544,681"/>
</map>
</div>

</div>
</div>
<a id="abe5632aeeaf569807a5e38b4ae1c5a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5632aeeaf569807a5e38b4ae1c5a98">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range1.html">TiledRange1</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the data of the two given ranges. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range1_8h_source.html#l00220">220</a> of file <a class="el" href="tiled__range1_8h_source.html">tiled_range1.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph.png" border="0" usemap="#namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph" alt=""/></div>
<map name="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph" id="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range1.html#a6cceff1ac7cf448502e83993911e24a6" title="TiledArray::TiledRange1\l::swap" alt="" coords="173,5,338,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph.png" border="0" usemap="#namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph" alt=""/></div>
<map name="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph" id="namespace_tiled_array_abe5632aeeaf569807a5e38b4ae1c5a98_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range1.html#a6cceff1ac7cf448502e83993911e24a6" title="TiledArray::TiledRange1\l::swap" alt="" coords="173,5,338,44"/>
</map>
</div>

</div>
</div>
<a id="a4b0947b0d351b9ee0112b292eb869249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0947b0d351b9ee0112b292eb869249">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the content of the two given <a class="el" href="class_tiled_array_1_1_tiled_range.html" title="Range data of a tiled array. ">TiledRange</a>'s. </p>

<p class="definition">Definition at line <a class="el" href="tiled__range_8h_source.html#l00296">296</a> of file <a class="el" href="tiled__range_8h_source.html">tiled_range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph.png" border="0" usemap="#namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph" id="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range.html#a348bcd96541cb2bc8588cfc333778455" title="TiledArray::TiledRange\l::swap" alt="" coords="173,5,330,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#ad5c630210968ab837a58bedcb3b29442" title="TiledArray::Range::swap" alt="" coords="378,12,545,37"/>
<area shape="rect" id="node4" href="namespace_tiled_array.html#a705b350b2dbf336a9cc24fb1d0f78fca" title="Exchange the values of the give two ranges. " alt="" coords="593,12,713,37"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph.png" border="0" usemap="#namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph" id="namespace_tiled_array_a4b0947b0d351b9ee0112b292eb869249_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range.html#a348bcd96541cb2bc8588cfc333778455" title="TiledArray::TiledRange\l::swap" alt="" coords="173,37,330,76"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tiled_range.html#ab90bd6a088860c5ab99398dafe2be406" title="TiledRange assignment operator. " alt="" coords="378,5,535,44"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tiled_range.html#a4042a84850edf247c847082a1248cb45" title="In place permutation of this range. " alt="" coords="378,68,535,107"/>
</map>
</div>

</div>
</div>
<a id="a705b350b2dbf336a9cc24fb1d0f78fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b350b2dbf336a9cc24fb1d0f78fca">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchange the values of the give two ranges. </p>

<p class="definition">Definition at line <a class="el" href="range_8h_source.html#l01048">1048</a> of file <a class="el" href="range_8h_source.html">range.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph.png" border="0" usemap="#namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph" id="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_range.html#ad5c630210968ab837a58bedcb3b29442" title="TiledArray::Range::swap" alt="" coords="173,5,340,31"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph.png" border="0" usemap="#namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph" id="namespace_tiled_array_a705b350b2dbf336a9cc24fb1d0f78fca_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_range.html#ad5c630210968ab837a58bedcb3b29442" title="TiledArray::Range::swap" alt="" coords="173,72,340,97"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_block_range.html#aa8e883ff57e15866ee27e8e07dc60b90" title="TiledArray::BlockRange\l::swap" alt="" coords="388,33,549,72"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tiled_range.html#a348bcd96541cb2bc8588cfc333778455" title="TiledArray::TiledRange\l::swap" alt="" coords="390,96,547,135"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tiled_range.html#ab90bd6a088860c5ab99398dafe2be406" title="TiledRange assignment operator. " alt="" coords="597,5,754,44"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tiled_range.html#a4042a84850edf247c847082a1248cb45" title="In place permutation of this range. " alt="" coords="597,68,754,107"/>
<area shape="rect" id="node7" href="namespace_tiled_array.html#a4b0947b0d351b9ee0112b292eb869249" title="Exchange the content of the two given TiledRange&#39;s. " alt="" coords="615,131,736,156"/>
</map>
</div>

</div>
</div>
<a id="ae862097c5ca7e7a8affa6275af008f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae862097c5ca7e7a8affa6275af008f63">&#9670;&nbsp;</a></span>tensor_to_btas_subtensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator_ , typename Range_ , typename Storage_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::tensor_to_btas_subtensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, Allocator_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btas::Tensor&lt; T, Range_, Storage_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a block of a btas::Tensor into a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a>. </p>
<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a> <code>src</code> will be copied into a block of btas::Tensor <code>dst</code>. The block dimensions will be determined by the dimensions of the range of <code>src</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">Allocator_</td><td>The allocator type of the source <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a> object </td></tr>
    <tr><td class="paramname">Range_</td><td>The range type of the destination btas::Tensor object </td></tr>
    <tr><td class="paramname">Storage_</td><td>The storage type of the destination btas::Tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source object whose contents will be copied into a subblock of <code>dst</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The destination object; its subblock defined by the {lower,upper} bounds <code>{src.lobound()</code>,src.upbound()} will be overwritten with the content of <code>src</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>src</code> and <code>dst</code> do not match. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00076">76</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_cgraph.png" border="0" usemap="#namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_cgraph" alt=""/></div>
<map name="namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_cgraph" id="namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="205,5,334,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title="TiledArray::detail\l::make_ta_range" alt="" coords="209,68,330,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="201,131,337,169"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="402,216,523,255"/>
<area shape="rect" id="node7" href="namespace_tiled_array.html#a4b3f6231b75b996d3fa766849f952eef" title="TiledArray::make_map" alt="" coords="192,245,347,271"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="395,131,530,169"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_icgraph.png" border="0" usemap="#namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_icgraph" alt=""/></div>
<map name="namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_icgraph" id="namespace_tiled_array_ae862097c5ca7e7a8affa6275af008f63_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix. " alt="" coords="192,5,331,57"/>
</map>
</div>

</div>
</div>
<a id="a6a1e016346f447dcd7b5b4d7f29246b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1e016346f447dcd7b5b4d7f29246b6">&#9670;&nbsp;</a></span>tensor_to_eigen_submatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A , typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::tensor_to_eigen_submatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the content of a tensor into an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix block. </p>
<p>The content of tensor will be copied into a block of matrix. The block dimensions will be determined by the dimensions of the tensor's range. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor element type </td></tr>
    <tr><td class="paramname">A</td><td>The tensor allocator type </td></tr>
    <tr><td class="paramname">Derived</td><td>The derived type of an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td>The object that will be copied to <code>matrix</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The object that will be assigned the content of <code>tensor</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the dimensions of <code>tensor</code> are not equal to 1 or 2. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>When the range of <code>tensor</code> is outside the range of <code>matrix</code> . </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00236">236</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_cgraph.png" border="0" usemap="#namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_cgraph" id="namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="211,5,340,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="198,68,353,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="401,29,530,68"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="401,92,530,131"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_icgraph.png" border="0" usemap="#namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_icgraph" id="namespace_tiled_array_a6a1e016346f447dcd7b5b4d7f29246b6_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2" title="Task function for assigning a tensor to an Eigen submatrix. " alt="" coords="198,5,338,57"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f" title="Convert an Array object into an Eigen matrix object. " alt="" coords="386,12,524,51"/>
</map>
</div>

</div>
</div>
<a id="aa9380eed8edcb28bcde6b05f2a2e85f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9380eed8edcb28bcde6b05f2a2e85f2">&#9670;&nbsp;</a></span>to_dense() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__to__dense_8h_source.html#l00035">35</a> of file <a class="el" href="sparse__to__dense_8h_source.html">sparse_to_dense.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_aa9380eed8edcb28bcde6b05f2a2e85f2_cgraph.png" border="0" usemap="#namespace_tiled_array_aa9380eed8edcb28bcde6b05f2a2e85f2_cgraph" alt=""/></div>
<map name="namespace_tiled_array_aa9380eed8edcb28bcde6b05f2a2e85f2_cgraph" id="namespace_tiled_array_aa9380eed8edcb28bcde6b05f2a2e85f2_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="197,5,341,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="197,68,341,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor. " alt="" coords="197,131,341,169"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="197,193,341,232"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_dist_array.html#af7f0a051f5aa4b8a01558bb022f15a71" title="Find local or remote tile. " alt="" coords="197,256,341,295"/>
</map>
</div>

</div>
</div>
<a id="a3d73428d629118ac2c9ab7f08b6ca180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d73428d629118ac2c9ab7f08b6ca180">&#9670;&nbsp;</a></span>to_dense() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::to_dense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__to__dense_8h_source.html#l00064">64</a> of file <a class="el" href="sparse__to__dense_8h_source.html">sparse_to_dense.h</a>.</p>

</div>
</div>
<a id="a177c1ea27ad85cca7df258e71c7d9739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c1ea27ad85cca7df258e71c7d9739">&#9670;&nbsp;</a></span>to_new_tile_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy , typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;typename std::result_of&lt;Op(<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>)&gt;::type, Policy&gt; TiledArray::to_new_tile_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; const &amp;&#160;</td>
          <td class="paramname"><em>old_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to convert an array to a new array with a different tile type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The array tile type </td></tr>
    <tr><td class="paramname">Policy</td><td>The array policy type </td></tr>
    <tr><td class="paramname">Op</td><td>The tile conversion operation type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to be converted </td></tr>
    <tr><td class="paramname">op</td><td>The tile type conversion operation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__new__tile__type_8h_source.html#l00042">42</a> of file <a class="el" href="to__new__tile__type_8h_source.html">to_new_tile_type.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a177c1ea27ad85cca7df258e71c7d9739_cgraph.png" border="0" usemap="#namespace_tiled_array_a177c1ea27ad85cca7df258e71c7d9739_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a177c1ea27ad85cca7df258e71c7d9739_cgraph" id="namespace_tiled_array_a177c1ea27ad85cca7df258e71c7d9739_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="185,5,329,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="185,68,329,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_dist_array.html#a3140a5cda14c2ea5b5e7c654099f015d" title="Shape accessor. " alt="" coords="185,131,329,169"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_dist_array.html#a26ad3fc01bc940ec5be321058196d180" title="Process map accessor. " alt="" coords="185,193,329,232"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="185,256,329,295"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_dist_array.html#af7f0a051f5aa4b8a01558bb022f15a71" title="Find local or remote tile. " alt="" coords="185,319,329,357"/>
</map>
</div>

</div>
</div>
<a id="a3fe2d157bfac3a81e84b52461e754c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe2d157bfac3a81e84b52461e754c96">&#9670;&nbsp;</a></span>to_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::to_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>dense_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert a dense array into a block sparse array. </p>
<p>If the input array is dense then create a copy by checking the norms of the tiles in the dense array and then cloning the significant tiles into the sparse array. </p>

<p class="definition">Definition at line <a class="el" href="dense__to__sparse_8h_source.html#l00016">16</a> of file <a class="el" href="dense__to__sparse_8h_source.html">dense_to_sparse.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3fe2d157bfac3a81e84b52461e754c96_cgraph.png" border="0" usemap="#namespace_tiled_array_a3fe2d157bfac3a81e84b52461e754c96_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3fe2d157bfac3a81e84b52461e754c96_cgraph" id="namespace_tiled_array_a3fe2d157bfac3a81e84b52461e754c96_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="216,5,360,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a8587157f8ad46d5da4f786b79110d0ab" title="End iterator factory function. " alt="" coords="201,68,374,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_dist_array.html#a8f63920a51f61fd746fef31cc0a0929e" title="Begin iterator factory function. " alt="" coords="216,117,360,156"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a5ab1632ba7a9f67bf9332c521bffff4e" title="Vector 2&#45;norm. " alt="" coords="223,180,352,219"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="216,243,360,281"/>
</map>
</div>

</div>
</div>
<a id="a9f448baf0d9da33c2112d366334c744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f448baf0d9da33c2112d366334c744a">&#9670;&nbsp;</a></span>to_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;<a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::to_sparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sparse_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the array is already sparse return a copy of the array. </p>

<p class="definition">Definition at line <a class="el" href="dense__to__sparse_8h_source.html#l00053">53</a> of file <a class="el" href="dense__to__sparse_8h_source.html">dense_to_sparse.h</a>.</p>

</div>
</div>
<a id="abc763468b96a704d6b4efb628909485f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc763468b96a704d6b4efb628909485f">&#9670;&nbsp;</a></span>truncate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate a dense Array. </p>
<p>This is a no op </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array object to be truncated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="truncate_8h_source.html#l00044">44</a> of file <a class="el" href="truncate_8h_source.html">truncate.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_abc763468b96a704d6b4efb628909485f_icgraph.png" border="0" usemap="#namespace_tiled_array_abc763468b96a704d6b4efb628909485f_icgraph" alt=""/></div>
<map name="namespace_tiled_array_abc763468b96a704d6b4efb628909485f_icgraph" id="namespace_tiled_array_abc763468b96a704d6b4efb628909485f_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#aa4eb781438f1d5ffec3f75b879ead8c0" title="Convert a btas::Tensor object into a TiledArray::DistArray object. " alt="" coords="191,5,349,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#af4b4117223e23851c222abead2667f09" title="Update shape data and remove tiles that are below the zero threshold. " alt="" coords="198,68,342,107"/>
</map>
</div>

</div>
</div>
<a id="a9f42ee8853ef4f42c260f1a22ffc1eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f42ee8853ef4f42c260f1a22ffc1eef">&#9670;&nbsp;</a></span>truncate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Truncate a sparse Array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a></td><td>The tile type of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array</td><td>The array object to be truncated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="truncate_8h_source.html#l00051">51</a> of file <a class="el" href="truncate_8h_source.html">truncate.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a9f42ee8853ef4f42c260f1a22ffc1eef_cgraph.png" border="0" usemap="#namespace_tiled_array_a9f42ee8853ef4f42c260f1a22ffc1eef_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a9f42ee8853ef4f42c260f1a22ffc1eef_cgraph" id="namespace_tiled_array_a9f42ee8853ef4f42c260f1a22ffc1eef_cgraph">
<area shape="rect" id="node2" href="group___tile_interface.html#gaf68ae245fa13091be35fcc8cad8b2ba6" title="Vector 2&#45;norm of a tile. " alt="" coords="191,5,310,31"/>
</map>
</div>

</div>
</div>
<a id="a297fc199c0e4a33cd3d6122b7c71f514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297fc199c0e4a33cd3d6122b7c71f514">&#9670;&nbsp;</a></span>vec_multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::vec_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00081">81</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_cgraph.png" border="0" usemap="#namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_cgraph" id="namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="217,5,359,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="216,68,360,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_icgraph.png" border="0" usemap="#namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_icgraph" id="namespace_tiled_array_a297fc199c0e4a33cd3d6122b7c71f514_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="216,5,417,44"/>
</map>
</div>

</div>
</div>
<a id="a3558ec56f9d00590c35846d8f13c1b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3558ec56f9d00590c35846d8f13c1b76">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tile , typename Policy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; <a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>, Policy &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00063">63</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_cgraph.png" border="0" usemap="#namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_cgraph" alt=""/></div>
<map name="namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_cgraph" id="namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9" title="TiledArray::detail\l::dummy_annotation" alt="" coords="169,5,311,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="168,68,312,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_icgraph.png" border="0" usemap="#namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_icgraph" alt=""/></div>
<map name="namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_icgraph" id="namespace_tiled_array_a3558ec56f9d00590c35846d8f13c1b76_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_d_i_i_s.html#a06b179576a5abf9a2b066cee36269573" title="TiledArray::DIIS::extrapolate" alt="" coords="168,5,357,31"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_bitset.html#aea1cb8c3bbaa37ad3209373c72f2ab89" title="Construct a bitset that contains s bits. " alt="" coords="202,55,323,93"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_bitset.html#af6ac8b2ce6b551e0f13df10c42c74ed1" title="Set all bits. " alt="" coords="202,117,323,156"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1detail_1_1_bitset.html#a19ac1d02d6e0ff46da6d47d2a9ceb7ae" title="TiledArray::detail\l::Bitset::operator\&lt;\&lt;=" alt="" coords="405,55,547,93"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1detail_1_1_bitset.html#ae6babfe6e53e686d7bd4f496b5e76b56" title="TiledArray::detail\l::Bitset::operator\&gt;\&gt;=" alt="" coords="405,117,547,156"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1detail_1_1_bitset.html#a08005e43683b3ee3d2ba855278369974" title="Set a bit value. " alt="" coords="415,180,536,219"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li>
    <li class="footer">Generated on Mon Aug 27 2018 08:19:31 for TiledArray by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
