<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TiledArray: TiledArray::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TiledArray
   &#160;<span id="projectnumber">0.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_tiled_array_1_1detail.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TiledArray::detail Namespace Reference<div class="ingroups"><a class="el" href="group___tile_interface.html">Tile interface for user defined tensor types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> addition operation.  <a href="class_tiled_array_1_1detail_1_1_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper.html">ArgumentHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01_future_3_01_t_01_4_01_4.html">ArgumentHelper&lt; Future&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_argument_helper_3_01std_1_1pair_3_01_future_3_01_t_01_4_00_01_future_3_01_u_01_4_01_4_01_4.html">ArgumentHelper&lt; std::pair&lt; Future&lt; T &gt;, Future&lt; U &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html">ArrayEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator for <code><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">TiledArray::Array</a></code> objects.  <a href="class_tiled_array_1_1detail_1_1_array_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_impl.html">ArrayImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_array_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_array_iterator.html">ArrayIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed tensor iterator.  <a href="class_tiled_array_1_1detail_1_1_array_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html">BinaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary, distributed tensor evaluator.  <a href="class_tiled_array_1_1detail_1_1_binary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_wrapper.html">BinaryWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary tile operation wrapper.  <a href="class_tiled_array_1_1detail_1_1_binary_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed size bitset.  <a href="class_tiled_array_1_1detail_1_1_bitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_blocked_pmap.html">BlockedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A blocked process map.  <a href="class_tiled_array_1_1detail_1_1_blocked_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01_complex_neg_tag_01_4.html">ComplexConjugate&lt; ComplexNegTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of ComplexConjugate&lt;S&gt; for the case of a negative unit/identity factor.  <a href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01_complex_neg_tag_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01void_01_4.html">ComplexConjugate&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of ComplexConjugate&lt;S&gt; for the case of a unit/identity factor.  <a href="class_tiled_array_1_1detail_1_1_complex_conjugate_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce.html">ContractReduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and (sum) reduce operation.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html">ContractReduce&lt; Result, Left, Right, TiledArray::detail::ComplexConjugate&lt; Scalar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and reduce operation.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html">ContractReduce&lt; Result, Left, Right, TiledArray::detail::ComplexConjugate&lt; void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and (sum) reduce operation.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_contract_reduce_base.html">ContractReduceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract and (sum) reduce base.  <a href="class_tiled_array_1_1detail_1_1_contract_reduce_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html">CyclicPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps cyclically a sequence of indices onto a 2-d matrix of processes.  <a href="class_tiled_array_1_1detail_1_1_cyclic_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1default__world.html">default_world</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval.html">DistEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> expression object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html">DistEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed evaluator implementation object.  <a href="class_tiled_array_1_1detail_1_1_dist_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_distributed_storage.html">DistributedStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed storage container.  <a href="class_tiled_array_1_1detail_1_1_distributed_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1eval__trait__base.html">eval_trait_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1eval__trait__base_3_01_t_00_01typename_01std_1_1enable__if_3_01haf03a5632a5411c05658071b9b5c7ffa.html">eval_trait_base&lt; T, typename std::enable_if&lt; has_member_type_eval_type&lt; T &gt;::value &amp;&amp;(detail::is_explicitly_convertible&lt; T, typename T::eval_type &gt;::value||detail::is_explicitly_convertible&lt; T, madness::Future&lt; typename T::eval_type &gt;&gt;::value||detail::is_implicitly_convertible&lt; T, typename T::eval_type &gt;::value||detail::is_implicitly_convertible&lt; T, madness::Future&lt; typename T::eval_type &gt;&gt;::value)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1has__conversion__operator.html">has_conversion_operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1has__conversion__operator_3_01_from_00_01_to_00_01typename_01std8732e964c6c1a9becba684003f3cf24b.html">has_conversion_operator&lt; From, To, typename std::enable_if&lt; is_type&lt; decltype(std::declval&lt; From &gt;().operator To())&gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_hash_pmap.html">HashPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashed process map.  <a href="class_tiled_array_1_1detail_1_1_hash_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array.html">is_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array_3_01_dist_array_3_01_t_00_01_p_01_4_01_4.html">is_array&lt; DistArray&lt; T, P &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile.html">is_array_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect tiles used by <code><a class="el" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html" title="Distributed evaluator for TiledArray::Array objects. ">ArrayEvalImpl</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__array__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__array__tile_3_01_tiled_array_1_1detail_1_1_lazy_array_tile_3_01_t_00_01_op_01_4_01_4.html">is_array_tile&lt; TiledArray::detail::LazyArrayTile&lt; T, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex.html">is_complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__complex_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_complex&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor.html">is_contiguous_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t_01_4.html">is_contiguous_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_contiguous_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor_3_4.html">is_contiguous_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper.html">is_contiguous_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01btas_1_1_tensor_3_01_t_00_01_args_8_8_8_01_4_01_4.html">is_contiguous_tensor_helper&lt; btas::Tensor&lt; T, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_contiguous_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_contiguous_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__contiguous__tensor__helper_3_01_tensor_interface_3_01_t_00_01_range_01_4_01_4.html">is_contiguous_tensor_helper&lt; TensorInterface&lt; T, Range &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__dense.html">is_dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_dense&lt;T&gt; is a true type if <code>T</code> is a dense array  <a href="struct_tiled_array_1_1detail_1_1is__dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__dense_3_01_dist_array_3_01_tile_00_01_dense_policy_01_4_01_4.html">is_dense&lt; DistArray&lt; Tile, DensePolicy &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__explicitly__convertible.html">is_explicitly_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__forward__iterator.html">is_forward_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__implicitly__convertible.html">is_implicitly_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list.html">is_integral_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper.html">is_integral_list_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_01_t_00_01_ts_8_8_8_01_4.html">is_integral_list_helper&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__list__helper_3_4.html">is_integral_list_helper&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair.html">is_integral_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__.html">is_integral_pair_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair___3_01std_1_1pair_3_01_t1_00_01_t2_01_4_00_01929d82b290f47b7b6ae4b08beac9d756.html">is_integral_pair_&lt; std::pair&lt; T1, T2 &gt;, typename std::enable_if&lt; std::is_integral&lt; T1 &gt;::value &amp;&amp;std::is_integral&lt; T2 &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list.html">is_integral_pair_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list__helper.html">is_integral_pair_list_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list__helper_3_01_t_00_01_ts_8_8_8_01_4.html">is_integral_pair_list_helper&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__pair__list__helper_3_4.html">is_integral_pair_list_helper&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__tuple.html">is_integral_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__integral__tuple_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.html">is_integral_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5_00_01void_01_4.html">is_iterator&lt; const T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01const_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; const T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5_00_01void_01_4.html">is_iterator&lt; T *, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_01_5const_00_01void_01_4.html">is_iterator&lt; T *const, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__iterator_3_01_t_00_01typename_01std_1_1enable__if_3_01has__m665d2b3bafc083e46c25939cb2cd2486.html">is_iterator&lt; T, typename std::enable_if&lt; has_member_type_iterator_category&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html">is_non_array_lazy_tile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect a lazy evaluation tile that are not a <code><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html" title="Lazy tile for on-the-fly evaluation of array tiles. ">LazyArrayTile</a></code>.  <a href="struct_tiled_array_1_1detail_1_1is__non__array__lazy__tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric.html">is_numeric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01bool_01_4.html">is_numeric&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01_complex_conjugate_3_01_s_01_4_01_4.html">is_numeric&lt; ComplexConjugate&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__numeric_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_numeric&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__output__iterator.html">is_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__pair.html">is_pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__pair_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html">is_pair&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__random__iterator.html">is_random_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__same__or__derived.html">is_same_or_derived</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar.html">is_scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__scalar_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_scalar&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted.html">is_shifted</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t_01_4.html">is_shifted&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_shifted&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted_3_4.html">is_shifted&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper.html">is_shifted_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__shifted__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_shifted_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered.html">is_strictly_ordered</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__strictly__ordered__helper.html">is_strictly_ordered_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor.html">is_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t_01_4.html">is_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor_3_4.html">is_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper.html">is_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01btas_1_1_tensor_3_01_t_00_01_args_8_8_8_01_4_01_4.html">is_tensor_helper&lt; btas::Tensor&lt; T, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01const_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; const T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__helper_3_01_tensor_interface_3_01_t_00_01_r_01_4_01_4.html">is_tensor_helper&lt; TensorInterface&lt; T, R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor.html">is_tensor_of_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t_01_4.html">is_tensor_of_tensor&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_01_t1_00_01_t2_00_01_ts_8_8_8_01_4.html">is_tensor_of_tensor&lt; T1, T2, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor_3_4.html">is_tensor_of_tensor&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper.html">is_tensor_of_tensor_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_shift_wrapper_3_01_t_01_4_01_4.html">is_tensor_of_tensor_helper&lt; ShiftWrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">is_tensor_of_tensor_helper&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tensor__of__tensor__helper_3_01_tensor_interface_3_01_t_00_01_range_type_01_4_01_4.html">is_tensor_of_tensor_helper&lt; TensorInterface&lt; T, RangeType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__tuple__.html">is_tuple_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1is__type.html">is_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html">LazyArrayTile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy tile for on-the-fly evaluation of array tiles.  <a href="class_tiled_array_1_1detail_1_1_lazy_array_tile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1make__void.html">make_void</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_mult.html">Mult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> multiplication operation.  <a href="class_tiled_array_1_1detail_1_1_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1non__iterator__tag.html">non_iterator_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_noop.html">Noop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> no operation (noop)  <a href="class_tiled_array_1_1detail_1_1_noop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">numeric_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for extracting the numeric type of tensors and arrays.  <a href="struct_tiled_array_1_1detail_1_1numeric__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_eigen_1_1_array_3_01_t_00_01_rows_00_01_cols_2dc1846cf3442651d13911035a045167.html">numeric_type&lt; Eigen::Array&lt; T, Rows, Cols, Opts, MaxRows, MaxCols &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_eigen_1_1_map_3_01_plain_object_type_00_01_madde20a404ff8630b7fe4aeb0d69ce57e.html">numeric_type&lt; Eigen::Map&lt; PlainObjectType, MapOptions, StrideType &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_eigen_1_1_matrix_3_01_t_00_01_rows_00_01_colsa4a4e2b0c5fc859c2d4c3373b5e620d7.html">numeric_type&lt; Eigen::Matrix&lt; T, Rows, Cols, Opts, MaxRows, MaxCols &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01has__193073a9c3aaeb15911aea8512f9cbaf.html">numeric_type&lt; T, typename std::enable_if&lt; has_member_type_value_type&lt; T &gt;::value &amp;&amp;(! is_lazy_tile&lt; T &gt;::value) &amp;&amp;(! is_numeric&lt; T &gt;::value)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__l5f42168e9c8c9d0a5ad9e9f1f13d5a56.html">numeric_type&lt; T, typename std::enable_if&lt; is_lazy_tile&lt; T &gt;::value &amp;&amp;! is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__n993a2ad199e20cd7480cb53864b142bc.html">numeric_type&lt; T, typename std::enable_if&lt; is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type_3_01_tile_3_01_t_01_4_00_01void_01_4.html">numeric_type&lt; Tile&lt; T &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01is__numeric_33ed69f6b1e4f90bd5899462119a67d06.html">param&lt; T, typename std::enable_if&lt; is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__po026251cf0f0a4c03557bdf8a6565693e.html">param&lt; T, typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1param_3_01_t_00_01typename_01std_1_1enable__if_3_01std_1_1is__rece401fa407cc0a1ee19af25268964063.html">param&lt; T, typename std::enable_if&lt; std::is_reference&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_perm_index.html">PermIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor that permutes ordinal indices.  <a href="class_tiled_array_1_1detail_1_1_perm_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_proc_grid.html">ProcGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D processor grid.  <a href="class_tiled_array_1_1detail_1_1_proc_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordinate index iterate.  <a href="class_tiled_array_1_1detail_1_1_range_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html">ReducePairOpWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper that to convert a pair-wise reduction into a standard reduction.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_op_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html">ReducePairTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce pair task.  <a href="class_tiled_array_1_1detail_1_1_reduce_pair_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_reduce_task.html">ReduceTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce task.  <a href="class_tiled_array_1_1detail_1_1_reduce_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1remove__cvr.html">remove_cvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove const, volatile, and reference qualifiers.  <a href="struct_tiled_array_1_1detail_1_1remove__cvr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicated_pmap.html">ReplicatedPmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Replicated process map.  <a href="class_tiled_array_1_1detail_1_1_replicated_pmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_replicator.html">Replicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate a <code>Array</code> object.  <a href="class_tiled_array_1_1detail_1_1_replicator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal.html">Scal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scaling operation.  <a href="class_tiled_array_1_1detail_1_1_scal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_add.html">ScalAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scale-addition operation.  <a href="class_tiled_array_1_1detail_1_1_scal_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait for extracting the scalar type of tensors and arrays.  <a href="struct_tiled_array_1_1detail_1_1scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01std_1_1complex_3_01_t_01_4_00_01void_01_4.html">scalar_type&lt; std::complex&lt; T &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_t_00_01typename_01std_1_1enable__if_3_01is__sc24d3d5b99bdc6dc01f7e80ceeba582ac.html">scalar_type&lt; T, typename std::enable_if&lt; is_scalar&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type_3_01_t_00_01typename_01std_1_1enable__if_3_9is__num344cf82c207f350e6bf7f78b2697c97c.html">scalar_type&lt; T, typename std::enable_if&lt;!is_numeric&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_mult.html">ScalMult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scale-multiplication operation.  <a href="class_tiled_array_1_1detail_1_1_scal_mult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_shift.html">ScalShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> shift operation.  <a href="class_tiled_array_1_1detail_1_1_scal_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_scal_subt.html">ScalSubt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> scale-subtraction operation.  <a href="class_tiled_array_1_1detail_1_1_scal_subt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_shift.html">Shift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> shift operation.  <a href="class_tiled_array_1_1detail_1_1_shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_shift.html" title="Tile shift operation. ">Shift</a> wrapper class.  <a href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array wrapper.  <a href="class_tiled_array_1_1detail_1_1_size_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_subt.html">Subt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tile.html" title="An N-dimensional shallow copy wrapper for tile objects. ">Tile</a> subtraction operation.  <a href="class_tiled_array_1_1detail_1_1_subt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_summa.html">Summa</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed contraction evaluator implementation.  <a href="class_tiled_array_1_1detail_1_1_summa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_const_reference.html">TensorConstReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_impl.html">TensorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> implementation and base for other tensor implementation objects.  <a href="class_tiled_array_1_1detail_1_1_tensor_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_interface.html">TensorInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> interface for external data.  <a href="class_tiled_array_1_1detail_1_1_tensor_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tensor_reference.html">TensorReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> tile reference.  <a href="class_tiled_array_1_1detail_1_1_tile_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1transform.html">transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">customization point transform functionality to tensor class T, useful for nonintrusive extension of T to be usable as tensor type T in Tensor&lt;T&gt;  <a href="struct_tiled_array_1_1detail_1_1transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tiled_array_1_1detail_1_1transform_3_01_tensor_3_01_t_00_01_a_01_4_01_4.html">transform&lt; Tensor&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html">UnaryEvalImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> that is composed from an argument tensor.  <a href="class_tiled_array_1_1detail_1_1_unary_eval_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary transform iterator.  <a href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_wrapper.html">UnaryWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary tile operation wrapper.  <a href="class_tiled_array_1_1detail_1_1_unary_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value array.  <a href="class_tiled_array_1_1detail_1_1_val_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9fec2bd28d7a936780f5c2eb94379ace"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9fec2bd28d7a936780f5c2eb94379ace"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9fec2bd28d7a936780f5c2eb94379ace">void_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1make__void.html">make_void</a>&lt; Ts... &gt;::type</td></tr>
<tr class="separator:a9fec2bd28d7a936780f5c2eb94379ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e783371e091990055d391dc6d2090"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a763e783371e091990055d391dc6d2090"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a763e783371e091990055d391dc6d2090">numeric_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a763e783371e091990055d391dc6d2090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5d3c6ec63959b5ed57e480adf45732d7">scalar_t</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a5d3c6ec63959b5ed57e480adf45732d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="memTemplParams" colspan="2">template&lt;bool B, typename T &gt; </td></tr>
<tr class="memitem:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a> = typename std::conditional&lt; B, const T, T &gt;::type</td></tr>
<tr class="memdesc:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepends <code>const</code> to <code>T</code> if <code>B</code> is <code>true</code>  <a href="#a196b35f7b6b1ccdb872eeca1353bb26b">More...</a><br /></td></tr>
<tr class="separator:a196b35f7b6b1ccdb872eeca1353bb26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">param_type</a> = typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt; U &gt;::type</td></tr>
<tr class="separator:a0d58e523957afcbcb1a47b8d98ab30d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af97c9bf4ef025af9a6a81c86b49d2fad">add_t</a> = decltype(std::declval&lt; Scalar1 &gt;()+std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:af97c9bf4ef025af9a6a81c86b49d2fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb1097bfa2f729cf40656648ed4116a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:abeb1097bfa2f729cf40656648ed4116a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abeb1097bfa2f729cf40656648ed4116a">subt_t</a> = decltype(std::declval&lt; Scalar1 &gt;() - std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:abeb1097bfa2f729cf40656648ed4116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0808e462394d3ca16b63a873448283bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 &gt; </td></tr>
<tr class="memitem:a0808e462394d3ca16b63a873448283bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0808e462394d3ca16b63a873448283bd">mult_t</a> = decltype(std::declval&lt; Scalar1 &gt;() *std::declval&lt; Scalar2 &gt;())</td></tr>
<tr class="separator:a0808e462394d3ca16b63a873448283bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">trange_t</a> = typename T::trange_type</td></tr>
<tr class="separator:a06e12c23ae1ad65ad65ef54b041abb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3199b02c7815c0d03a919fc87807656a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3199b02c7815c0d03a919fc87807656a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3199b02c7815c0d03a919fc87807656a">shape_t</a> = typename T::shape_type</td></tr>
<tr class="separator:a3199b02c7815c0d03a919fc87807656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">pmap_t</a> = typename T::pmap_interface</td></tr>
<tr class="separator:a11981ec4cf6f0e145fe51fa42c93ec10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187720de6c845523407c42fb2ebe0385"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a187720de6c845523407c42fb2ebe0385"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a187720de6c845523407c42fb2ebe0385">policy_t</a> = typename T::policy_type</td></tr>
<tr class="separator:a187720de6c845523407c42fb2ebe0385"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad38f2970e843e56f76822d775d4d52c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad38f2970e843e56f76822d775d4d52c9">dummy_annotation</a> (unsigned int DIM)</td></tr>
<tr class="separator:ad38f2970e843e56f76822d775d4d52c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdeb370801b331554b63c01f4ac402b"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:a2cdeb370801b331554b63c01f4ac402b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2cdeb370801b331554b63c01f4ac402b">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:a2cdeb370801b331554b63c01f4ac402b"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference. ">TileReference</a> objects  <a href="#a2cdeb370801b331554b63c01f4ac402b">More...</a><br /></td></tr>
<tr class="separator:a2cdeb370801b331554b63c01f4ac402b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae8b423b1a3fcf6701ac05c9ce692d208">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference. ">TileReference</a> objects  <a href="#ae8b423b1a3fcf6701ac05c9ce692d208">More...</a><br /></td></tr>
<tr class="separator:ae8b423b1a3fcf6701ac05c9ce692d208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218cac85d033808e795a87a686ce4fb6"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:a218cac85d033808e795a87a686ce4fb6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a218cac85d033808e795a87a686ce4fb6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;a)</td></tr>
<tr class="memdesc:a218cac85d033808e795a87a686ce4fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference. ">TileReference</a> objects  <a href="#a218cac85d033808e795a87a686ce4fb6">More...</a><br /></td></tr>
<tr class="separator:a218cac85d033808e795a87a686ce4fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52461acf45d3505ede569ee1aaa395c"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:aa52461acf45d3505ede569ee1aaa395c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa52461acf45d3505ede569ee1aaa395c">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:aa52461acf45d3505ede569ee1aaa395c"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference. ">TileConstReference</a> objects  <a href="#aa52461acf45d3505ede569ee1aaa395c">More...</a><br /></td></tr>
<tr class="separator:aa52461acf45d3505ede569ee1aaa395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a804792a4a8294fbb2ca9ea04cb8c1da8">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;a, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference. ">TileConstReference</a> objects  <a href="#a804792a4a8294fbb2ca9ea04cb8c1da8">More...</a><br /></td></tr>
<tr class="separator:a804792a4a8294fbb2ca9ea04cb8c1da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="memTemplParams" colspan="2">template&lt;typename Impl &gt; </td></tr>
<tr class="memitem:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aaff7f022aafbfb5bac3eaf2afc31cae6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;a)</td></tr>
<tr class="memdesc:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference. ">TileConstReference</a> objects  <a href="#aaff7f022aafbfb5bac3eaf2afc31cae6">More...</a><br /></td></tr>
<tr class="separator:aaff7f022aafbfb5bac3eaf2afc31cae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1d6fcb450ef829c3ad4e8e1db5be514a">swap</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b0, <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;b1)</td></tr>
<tr class="separator:a1d6fcb450ef829c3ad4e8e1db5be514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bec5b1d1332c33a47755a4f62eaf71"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:ac0bec5b1d1332c33a47755a4f62eaf71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac0bec5b1d1332c33a47755a4f62eaf71">operator &amp;</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:ac0bec5b1d1332c33a47755a4f62eaf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and operator of bitset.  <a href="#ac0bec5b1d1332c33a47755a4f62eaf71">More...</a><br /></td></tr>
<tr class="separator:ac0bec5b1d1332c33a47755a4f62eaf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d0266e20b12eefced1cde7a01d4cdcd">operator|</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or operator of bitset.  <a href="#a0d0266e20b12eefced1cde7a01d4cdcd">More...</a><br /></td></tr>
<tr class="separator:a0d0266e20b12eefced1cde7a01d4cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9c12507ffe191d9e79b32f6687ec46b1">operator^</a> (<a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; left, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;right)</td></tr>
<tr class="memdesc:a9c12507ffe191d9e79b32f6687ec46b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor operator of bitset.  <a href="#a9c12507ffe191d9e79b32f6687ec46b1">More...</a><br /></td></tr>
<tr class="separator:a9c12507ffe191d9e79b32f6687ec46b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplParams" colspan="2">template&lt;typename Block &gt; </td></tr>
<tr class="memitem:aaf888c0b992f597156737f71e2bc6d32"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aaf888c0b992f597156737f71e2bc6d32">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;bitset)</td></tr>
<tr class="separator:aaf888c0b992f597156737f71e2bc6d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aab6018796760c407b5cc53295568ed"><td class="memTemplParams" colspan="2">template&lt;typename DistArray_ , typename BTAS_Tensor_ &gt; </td></tr>
<tr class="memitem:a8aab6018796760c407b5cc53295568ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8aab6018796760c407b5cc53295568ed">counted_btas_subtensor_to_tensor</a> (const BTAS_Tensor_ *src, DistArray_ *dst, const typename DistArray_::size_type i, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:a8aab6018796760c407b5cc53295568ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for converting btas::Tensor subblock to a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a>.  <a href="#a8aab6018796760c407b5cc53295568ed">More...</a><br /></td></tr>
<tr class="separator:a8aab6018796760c407b5cc53295568ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae305e910ce674d71f550e104c354cb5"><td class="memTemplParams" colspan="2">template&lt;typename TA_Tensor_ , typename BTAS_Tensor_ &gt; </td></tr>
<tr class="memitem:aae305e910ce674d71f550e104c354cb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5">counted_tensor_to_btas_subtensor</a> (const TA_Tensor_ &amp;src, BTAS_Tensor_ *dst, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:aae305e910ce674d71f550e104c354cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix.  <a href="#aae305e910ce674d71f550e104c354cb5">More...</a><br /></td></tr>
<tr class="separator:aae305e910ce674d71f550e104c354cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46d9580d4d2230d0e34ee0ccfdafc72"><td class="memTemplParams" colspan="2">template&lt;bool sparse&gt; </td></tr>
<tr class="memitem:ab46d9580d4d2230d0e34ee0ccfdafc72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">make_shape</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;trange)</td></tr>
<tr class="separator:ab46d9580d4d2230d0e34ee0ccfdafc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f1aefd43dea7ce3158f142a57e5994"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a39f1aefd43dea7ce3158f142a57e5994"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a39f1aefd43dea7ce3158f142a57e5994">make_shape&lt; true &gt;</a> (World &amp;world, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;trange)</td></tr>
<tr class="separator:a39f1aefd43dea7ce3158f142a57e5994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2a3fd528183d1884b5f53d1d0d89fa"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2b2a3fd528183d1884b5f53d1d0d89fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2b2a3fd528183d1884b5f53d1d0d89fa">make_shape&lt; false &gt;</a> (World &amp;, const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;)</td></tr>
<tr class="separator:a2b2a3fd528183d1884b5f53d1d0d89fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50d31c15b208288edec33a0129649b0"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Derived &gt; </td></tr>
<tr class="memitem:af50d31c15b208288edec33a0129649b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af50d31c15b208288edec33a0129649b0">counted_eigen_submatrix_to_tensor</a> (const Eigen::MatrixBase&lt; Derived &gt; *matrix, A *array, const typename A::size_type i, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:af50d31c15b208288edec33a0129649b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix to a tensor.  <a href="#af50d31c15b208288edec33a0129649b0">More...</a><br /></td></tr>
<tr class="separator:af50d31c15b208288edec33a0129649b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename T &gt; </td></tr>
<tr class="memitem:afe493525138ef355ba76900e56ae8cf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afe493525138ef355ba76900e56ae8cf2">counted_tensor_to_eigen_submatrix</a> (const T &amp;tensor, Eigen::MatrixBase&lt; Derived &gt; *matrix, madness::AtomicInt *counter)</td></tr>
<tr class="memdesc:afe493525138ef355ba76900e56ae8cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix.  <a href="#afe493525138ef355ba76900e56ae8cf2">More...</a><br /></td></tr>
<tr class="separator:afe493525138ef355ba76900e56ae8cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3277662ac15f21d2648c0401398bc787"><td class="memTemplParams" colspan="2">template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename... ArgTiles&gt; </td></tr>
<tr class="memitem:a3277662ac15f21d2648c0401398bc787"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3277662ac15f21d2648c0401398bc787">foreach</a> (Op &amp;&amp;op, <a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;... args)</td></tr>
<tr class="memdesc:a3277662ac15f21d2648c0401398bc787"><td class="mdescLeft">&#160;</td><td class="mdescRight">base implementation of dense <a class="el" href="namespace_tiled_array.html#a0c9f9298465a3cb1b6e7a10d5c1cb6bc" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a>  <a href="#a3277662ac15f21d2648c0401398bc787">More...</a><br /></td></tr>
<tr class="separator:a3277662ac15f21d2648c0401398bc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc9379f0c1cb1725c489b5e89595665"><td class="memTemplParams" colspan="2">template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename... ArgTiles&gt; </td></tr>
<tr class="memitem:a7fc9379f0c1cb1725c489b5e89595665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ResultTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a7fc9379f0c1cb1725c489b5e89595665">foreach</a> (Op &amp;&amp;op, const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a> shape_reduction, <a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&gt; &amp;arg, const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;... args)</td></tr>
<tr class="memdesc:a7fc9379f0c1cb1725c489b5e89595665"><td class="mdescLeft">&#160;</td><td class="mdescRight">base implementation of sparse <a class="el" href="namespace_tiled_array.html#a0c9f9298465a3cb1b6e7a10d5c1cb6bc" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a>  <a href="#a7fc9379f0c1cb1725c489b5e89595665">More...</a><br /></td></tr>
<tr class="separator:a7fc9379f0c1cb1725c489b5e89595665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45190dfcad5ef2b9af5b4aa000c844b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0">make_ta_range</a> (const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;range)</td></tr>
<tr class="separator:a45190dfcad5ef2b9af5b4aa000c844b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c40422c3621a425739070cf164db1"><td class="memTemplParams" colspan="2">template&lt;CBLAS_ORDER Order, typename... Args&gt; </td></tr>
<tr class="memitem:a763c40422c3621a425739070cf164db1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a763c40422c3621a425739070cf164db1">make_ta_range</a> (const btas::RangeNd&lt; Order, Args... &gt; &amp;range)</td></tr>
<tr class="memdesc:a763c40422c3621a425739070cf164db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">TiledArray::Range</a> from a btas::RangeNd  <a href="#a763c40422c3621a425739070cf164db1">More...</a><br /></td></tr>
<tr class="separator:a763c40422c3621a425739070cf164db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecba5efe7b319458a9f16df0563472b"><td class="memTemplParams" colspan="2">template&lt;typename Perm , typename Arg , typename Result &gt; </td></tr>
<tr class="memitem:a9ecba5efe7b319458a9f16df0563472b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b">permute_array</a> (const Perm &amp;perm, const Arg &amp;arg, Result &amp;result)</td></tr>
<tr class="memdesc:a9ecba5efe7b319458a9f16df0563472b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a permuted copy of an array.  <a href="#a9ecba5efe7b319458a9f16df0563472b">More...</a><br /></td></tr>
<tr class="separator:a9ecba5efe7b319458a9f16df0563472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a48b1ec146fbd546954d72262124a5b74"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a48b1ec146fbd546954d72262124a5b74">operator==</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a48b1ec146fbd546954d72262124a5b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a48b1ec146fbd546954d72262124a5b74">More...</a><br /></td></tr>
<tr class="separator:a48b1ec146fbd546954d72262124a5b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container &gt; </td></tr>
<tr class="memitem:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a3699581fa58aa15f3376c5e6f66f68b3">operator!=</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;left_it, const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;right_it)</td></tr>
<tr class="memdesc:a3699581fa58aa15f3376c5e6f66f68b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#a3699581fa58aa15f3376c5e6f66f68b3">More...</a><br /></td></tr>
<tr class="separator:a3699581fa58aa15f3376c5e6f66f68b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af085e2abd40acbf24fbc80033634097b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af085e2abd40acbf24fbc80033634097b">operator*</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;orig)</td></tr>
<tr class="separator:af085e2abd40acbf24fbc80033634097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a7179e9c73eed3c5738bf4d0c5ebd068d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;size_array)</td></tr>
<tr class="separator:a7179e9c73eed3c5738bf4d0c5ebd068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c7d290f2fb4704eecc33b0894de068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068">diagonal_range</a> (<a class="el" href="class_tiled_array_1_1_range.html">Range</a> const &amp;rng)</td></tr>
<tr class="separator:ae2c7d290f2fb4704eecc33b0894de068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aa537f17e1c4de2e8abf7093e29699"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33aa537f17e1c4de2e8abf7093e29699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699">diagonal_shape</a> (<a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;trange, T val)</td></tr>
<tr class="separator:a33aa537f17e1c4de2e8abf7093e29699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b41f257f8f107174ffbfd3b9e7c0c3"><td class="memTemplParams" colspan="2">template&lt;typename Array , typename T &gt; </td></tr>
<tr class="memitem:a31b41f257f8f107174ffbfd3b9e7c0c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a31b41f257f8f107174ffbfd3b9e7c0c3">write_tiles_to_array</a> (<a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &amp;A, T val)</td></tr>
<tr class="separator:a31b41f257f8f107174ffbfd3b9e7c0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a7abe197b45ae95a4132fc240ed383"><td class="memTemplParams" colspan="2">template&lt;typename R , typename std::enable_if&lt;! is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a32a7abe197b45ae95a4132fc240ed383"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383">conj</a> (const R r)</td></tr>
<tr class="memdesc:a32a7abe197b45ae95a4132fc240ed383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code>std::conj</code>  <a href="#a32a7abe197b45ae95a4132fc240ed383">More...</a><br /></td></tr>
<tr class="separator:a32a7abe197b45ae95a4132fc240ed383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381e9dfb596a18e208171ce358fa6f16"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a381e9dfb596a18e208171ce358fa6f16"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE std::complex&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a381e9dfb596a18e208171ce358fa6f16">conj</a> (const std::complex&lt; R &gt; z)</td></tr>
<tr class="memdesc:a381e9dfb596a18e208171ce358fa6f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for std::conj.  <a href="#a381e9dfb596a18e208171ce358fa6f16">More...</a><br /></td></tr>
<tr class="separator:a381e9dfb596a18e208171ce358fa6f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R , typename std::enable_if&lt;! is_complex&lt; L &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5031b9fe59e7561b395a2ef1c6b5e719">inner_product</a> (const L l, const R r)</td></tr>
<tr class="memdesc:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner product of a real value and a numeric value.  <a href="#a5031b9fe59e7561b395a2ef1c6b5e719">More...</a><br /></td></tr>
<tr class="separator:a5031b9fe59e7561b395a2ef1c6b5e719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af885da1706c23576a28eb38b7afab176"><td class="memTemplParams" colspan="2">template&lt;typename R , typename std::enable_if&lt;! is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af885da1706c23576a28eb38b7afab176"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af885da1706c23576a28eb38b7afab176">norm</a> (const R r)</td></tr>
<tr class="memdesc:af885da1706c23576a28eb38b7afab176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code>std::norm</code>  <a href="#af885da1706c23576a28eb38b7afab176">More...</a><br /></td></tr>
<tr class="separator:af885da1706c23576a28eb38b7afab176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af182bb984874298c8351edad6f03517c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:af182bb984874298c8351edad6f03517c"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af182bb984874298c8351edad6f03517c">norm</a> (const std::complex&lt; R &gt; z)</td></tr>
<tr class="memdesc:af182bb984874298c8351edad6f03517c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm of a complex number <code>z</code>  <a href="#af182bb984874298c8351edad6f03517c">More...</a><br /></td></tr>
<tr class="separator:af182bb984874298c8351edad6f03517c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a78aafa383b1b3e69b6e57b6b78c61306">conj_op</a> (const S factor)</td></tr>
<tr class="memdesc:a78aafa383b1b3e69b6e57b6b78c61306"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function.  <a href="#a78aafa383b1b3e69b6e57b6b78c61306">More...</a><br /></td></tr>
<tr class="separator:a78aafa383b1b3e69b6e57b6b78c61306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c470158b2bbbdb712cbbaf18a55101"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab2c470158b2bbbdb712cbbaf18a55101">conj_op</a> ()</td></tr>
<tr class="memdesc:ab2c470158b2bbbdb712cbbaf18a55101"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function.  <a href="#ab2c470158b2bbbdb712cbbaf18a55101">More...</a><br /></td></tr>
<tr class="separator:ab2c470158b2bbbdb712cbbaf18a55101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02d47cab0fc5866bf2eb5c13acf659b"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ad02d47cab0fc5866bf2eb5c13acf659b"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad02d47cab0fc5866bf2eb5c13acf659b">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt; op)</td></tr>
<tr class="separator:ad02d47cab0fc5866bf2eb5c13acf659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee93af26740ea0ee7c7f67db9a46601"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a8ee93af26740ea0ee7c7f67db9a46601"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8ee93af26740ea0ee7c7f67db9a46601">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;)</td></tr>
<tr class="separator:a8ee93af26740ea0ee7c7f67db9a46601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e797cf6d3cd288a14452f32071b7a93"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a6e797cf6d3cd288a14452f32071b7a93"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a6e797cf6d3cd288a14452f32071b7a93">operator*</a> (const L value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;)</td></tr>
<tr class="separator:a6e797cf6d3cd288a14452f32071b7a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f8563d428af127b0abe38a93863ead"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:a69f8563d428af127b0abe38a93863ead"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a69f8563d428af127b0abe38a93863ead">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; L &gt; op, const R value)</td></tr>
<tr class="separator:a69f8563d428af127b0abe38a93863ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31df1c69fe31afa87b68fb74323ec6a4"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a31df1c69fe31afa87b68fb74323ec6a4"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a31df1c69fe31afa87b68fb74323ec6a4">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;, const R value)</td></tr>
<tr class="separator:a31df1c69fe31afa87b68fb74323ec6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6a9baaee6dc713469802694a8f82d6"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:acc6a9baaee6dc713469802694a8f82d6"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#acc6a9baaee6dc713469802694a8f82d6">operator*</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt;, const R value)</td></tr>
<tr class="separator:acc6a9baaee6dc713469802694a8f82d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea2c5a93d37330153912da87c7c3877"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R , typename std::enable_if&lt;! std::is_void&lt; R &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acea2c5a93d37330153912da87c7c3877"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#acea2c5a93d37330153912da87c7c3877">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt; op)</td></tr>
<tr class="separator:acea2c5a93d37330153912da87c7c3877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa443b57aebf3d340cc65deeeb00c2073"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:aa443b57aebf3d340cc65deeeb00c2073"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa443b57aebf3d340cc65deeeb00c2073">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;)</td></tr>
<tr class="separator:aa443b57aebf3d340cc65deeeb00c2073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memTemplItemLeft" align="right" valign="top">TILEDARRAY_FORCE_INLINE L &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab4bd519fc858458a6bf061c1ef2ef5b3">operator*=</a> (L &amp;value, const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;)</td></tr>
<tr class="separator:ab4bd519fc858458a6bf061c1ef2ef5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61cbefb29ceef11f580804c689464d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af61cbefb29ceef11f580804c689464d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af61cbefb29ceef11f580804c689464d1">abs</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:af61cbefb29ceef11f580804c689464d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bafe4052acf5d99d2ef8010f362648"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a96bafe4052acf5d99d2ef8010f362648">abs</a> (const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;a)</td></tr>
<tr class="separator:a96bafe4052acf5d99d2ef8010f362648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab9d3ac1bd3e7b1b004f489db1b4ce8be">tensor_op</a> (Op &amp;&amp;op, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> operations with contiguous data.  <a href="#ab9d3ac1bd3e7b1b004f489db1b4ce8be">More...</a><br /></td></tr>
<tr class="separator:ab9d3ac1bd3e7b1b004f489db1b4ce8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f0f7c8a549579e118a89827e98726b"><td class="memTemplParams" colspan="2">template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value) &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a82f0f7c8a549579e118a89827e98726b"><td class="memTemplItemLeft" align="right" valign="top">TR&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a82f0f7c8a549579e118a89827e98726b">tensor_op</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a82f0f7c8a549579e118a89827e98726b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> permutation operations with contiguous data.  <a href="#a82f0f7c8a549579e118a89827e98726b">More...</a><br /></td></tr>
<tr class="separator:a82f0f7c8a549579e118a89827e98726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3">inplace_tensor_op</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor operations with contiguous data.  <a href="#ac7c2574bd1506d0e811e2c0eb58fb1e3">More...</a><br /></td></tr>
<tr class="separator:ac7c2574bd1506d0e811e2c0eb58fb1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af174120ffd75a14d13077eff16452d9b"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af174120ffd75a14d13077eff16452d9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b">inplace_tensor_op</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:af174120ffd75a14d13077eff16452d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place tensor permutation operations with contiguous data.  <a href="#af174120ffd75a14d13077eff16452d9b">More...</a><br /></td></tr>
<tr class="separator:af174120ffd75a14d13077eff16452d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa32053a2cef8c73b71763a0e01cd95"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2fa32053a2cef8c73b71763a0e01cd95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a2fa32053a2cef8c73b71763a0e01cd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with contiguous tensor arguments.  <a href="#a2fa32053a2cef8c73b71763a0e01cd95">More...</a><br /></td></tr>
<tr class="separator:a2fa32053a2cef8c73b71763a0e01cd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2788b8e3e27331097aa656a0e6e36b20"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2788b8e3e27331097aa656a0e6e36b20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20">tensor_init</a> (Op &amp;&amp;op, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a2788b8e3e27331097aa656a0e6e36b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with permuted tensor arguments.  <a href="#a2788b8e3e27331097aa656a0e6e36b20">More...</a><br /></td></tr>
<tr class="separator:a2788b8e3e27331097aa656a0e6e36b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="memTemplParams" colspan="2">template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value &amp;&amp;! is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9">tensor_init</a> (Op &amp;&amp;op, TR &amp;result, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize tensor with one or more non-contiguous tensor arguments.  <a href="#ac5132fe4d73d49d24d2dcd60f06849f9">More...</a><br /></td></tr>
<tr class="separator:ac5132fe4d73d49d24d2dcd60f06849f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab957a79bba9735ad3e405dbb8dd53796"><td class="memTemplParams" colspan="2">template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if_t&lt; is_tensor&lt; T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab957a79bba9735ad3e405dbb8dd53796"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796">tensor_reduce</a> (ReduceOp &amp;&amp;reduce_op, JoinOp &amp;&amp;join_op, Scalar identity, const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ab957a79bba9735ad3e405dbb8dd53796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction operation for contiguous tensors.  <a href="#ab957a79bba9735ad3e405dbb8dd53796">More...</a><br /></td></tr>
<tr class="separator:ab957a79bba9735ad3e405dbb8dd53796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f00e852b717ed4084f8fd331d4e6c2"><td class="memTemplParams" colspan="2">template&lt;typename SizeType &gt; </td></tr>
<tr class="memitem:aa3f00e852b717ed4084f8fd331d4e6c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa3f00e852b717ed4084f8fd331d4e6c2">fuse_dimensions</a> (SizeType *MADNESS_RESTRICT const fused_size, SizeType *MADNESS_RESTRICT const fused_weight, const SizeType *MADNESS_RESTRICT const <a class="el" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02">size</a>, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aa3f00e852b717ed4084f8fd331d4e6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the fused dimensions for permutation.  <a href="#aa3f00e852b717ed4084f8fd331d4e6c2">More...</a><br /></td></tr>
<tr class="separator:aa3f00e852b717ed4084f8fd331d4e6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a6955d66acd00dd89cd34669e7fe09"><td class="memTemplParams" colspan="2">template&lt;typename InputOp , typename OutputOp , typename Result , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ae1a6955d66acd00dd89cd34669e7fe09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae1a6955d66acd00dd89cd34669e7fe09">permute</a> (InputOp &amp;&amp;input_op, OutputOp &amp;&amp;output_op, Result &amp;result, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const Arg0 &amp;arg0, const Args &amp;... args)</td></tr>
<tr class="memdesc:ae1a6955d66acd00dd89cd34669e7fe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a permuted tensor copy.  <a href="#ae1a6955d66acd00dd89cd34669e7fe09">More...</a><br /></td></tr>
<tr class="separator:ae1a6955d66acd00dd89cd34669e7fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplParams" colspan="2">template&lt;typename Left , typename Right &gt; </td></tr>
<tr class="memitem:aa49fdad6dffe4694cd2f6568461a409c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c">is_range_congruent</a> (const Left &amp;left, const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;right)</td></tr>
<tr class="memdesc:aa49fdad6dffe4694cd2f6568461a409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for congruent range objects with a shifted tensor.  <a href="#aa49fdad6dffe4694cd2f6568461a409c">More...</a><br /></td></tr>
<tr class="separator:aa49fdad6dffe4694cd2f6568461a409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3099e3f966559b8e09bca8d63327117"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab3099e3f966559b8e09bca8d63327117"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab3099e3f966559b8e09bca8d63327117">clone_range</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:ab3099e3f966559b8e09bca8d63327117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of the range of the tensor.  <a href="#ab3099e3f966559b8e09bca8d63327117">More...</a><br /></td></tr>
<tr class="separator:ab3099e3f966559b8e09bca8d63327117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;! is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afd25794432f3ae654ef616a170280af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_range.html">Range</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#afd25794432f3ae654ef616a170280af3">clone_range</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:afd25794432f3ae654ef616a170280af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a contiguous copy of the range of the tensor.  <a href="#afd25794432f3ae654ef616a170280af3">More...</a><br /></td></tr>
<tr class="separator:afd25794432f3ae654ef616a170280af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37574f8f8dd2104153b755e6e4427528"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a37574f8f8dd2104153b755e6e4427528"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a37574f8f8dd2104153b755e6e4427528">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:a37574f8f8dd2104153b755e6e4427528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the two ranges are congruent.  <a href="#a37574f8f8dd2104153b755e6e4427528">More...</a><br /></td></tr>
<tr class="separator:a37574f8f8dd2104153b755e6e4427528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5c2b7b2f621d6bcff2c6e4e3d8cac0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abf5c2b7b2f621d6bcff2c6e4e3d8cac0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#abf5c2b7b2f621d6bcff2c6e4e3d8cac0">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r2)</td></tr>
<tr class="memdesc:abf5c2b7b2f621d6bcff2c6e4e3d8cac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that two <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> are congruent.  <a href="#abf5c2b7b2f621d6bcff2c6e4e3d8cac0">More...</a><br /></td></tr>
<tr class="separator:abf5c2b7b2f621d6bcff2c6e4e3d8cac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba84b2aab6ffebcfbf549eb997895654"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:aba84b2aab6ffebcfbf549eb997895654"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aba84b2aab6ffebcfbf549eb997895654">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r2)</td></tr>
<tr class="memdesc:aba84b2aab6ffebcfbf549eb997895654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> and <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> are congruent.  <a href="#aba84b2aab6ffebcfbf549eb997895654">More...</a><br /></td></tr>
<tr class="separator:aba84b2aab6ffebcfbf549eb997895654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc0dbda95a57b85aaec2b5d49a15009"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a1bc0dbda95a57b85aaec2b5d49a15009"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1bc0dbda95a57b85aaec2b5d49a15009">is_congruent</a> (const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;r1, const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;r2)</td></tr>
<tr class="memdesc:a1bc0dbda95a57b85aaec2b5d49a15009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> and <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> are congruent.  <a href="#a1bc0dbda95a57b85aaec2b5d49a15009">More...</a><br /></td></tr>
<tr class="separator:a1bc0dbda95a57b85aaec2b5d49a15009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0b9a43dfee2749874d4677ea89ab4188"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0b9a43dfee2749874d4677ea89ab4188">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a0b9a43dfee2749874d4677ea89ab4188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of tensors are congruent.  <a href="#a0b9a43dfee2749874d4677ea89ab4188">More...</a><br /></td></tr>
<tr class="separator:a0b9a43dfee2749874d4677ea89ab4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa35b616db0b6d4da11b862de9570fb93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa35b616db0b6d4da11b862de9570fb93">is_range_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm)</td></tr>
<tr class="memdesc:aa35b616db0b6d4da11b862de9570fb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a pair of permuted tensors are congruent.  <a href="#aa35b616db0b6d4da11b862de9570fb93">More...</a><br /></td></tr>
<tr class="separator:aa35b616db0b6d4da11b862de9570fb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T &amp;tensor)</td></tr>
<tr class="memdesc:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted tensor is congruent with itself.  <a href="#a0d75a0a0d43e9a5d8beec072cdbe678c">More...</a><br /></td></tr>
<tr class="separator:a0d75a0a0d43e9a5d8beec072cdbe678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a42a1f5fb2f3d857ee31e66ba3deabf20">is_range_set_congruent</a> (const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;perm, const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a permuted set of tensors are congruent.  <a href="#a42a1f5fb2f3d857ee31e66ba3deabf20">More...</a><br /></td></tr>
<tr class="separator:a42a1f5fb2f3d857ee31e66ba3deabf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a8d01c42f84f360ae79da4a0c8e5b84a2">is_range_set_congruent</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a tensor is congruent with itself.  <a href="#a8d01c42f84f360ae79da4a0c8e5b84a2">More...</a><br /></td></tr>
<tr class="separator:a8d01c42f84f360ae79da4a0c8e5b84a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81ff970acbf1f37236b31c6d19f8e27"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:af81ff970acbf1f37236b31c6d19f8e27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af81ff970acbf1f37236b31c6d19f8e27">is_range_set_congruent</a> (const T1 &amp;tensor1, const T2 &amp;tensor2, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:af81ff970acbf1f37236b31c6d19f8e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the ranges of a set of tensors are congruent.  <a href="#af81ff970acbf1f37236b31c6d19f8e27">More...</a><br /></td></tr>
<tr class="separator:af81ff970acbf1f37236b31c6d19f8e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85557b284f443993530894acbb158b58"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58">inner_size_helper</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a85557b284f443993530894acbb158b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="#a85557b284f443993530894acbb158b58">More...</a><br /></td></tr>
<tr class="separator:a85557b284f443993530894acbb158b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a227f69a3e3e5de0854bac8e8f2ec6cee">inner_size_helper</a> (const T1 &amp;tensor1, const T2 &amp;tensor2)</td></tr>
<tr class="memdesc:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="#a227f69a3e3e5de0854bac8e8f2ec6cee">More...</a><br /></td></tr>
<tr class="separator:a227f69a3e3e5de0854bac8e8f2ec6cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename std::enable_if&lt;! is_contiguous_tensor&lt; T1 &gt;::value &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memTemplItemLeft" align="right" valign="top">T1::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a">inner_size</a> (const T1 &amp;tensor1, const T2 &amp;)</td></tr>
<tr class="memdesc:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size of two tensors.  <a href="#a91ec4c7e7bd4d19b11f0674903ce630a">More...</a><br /></td></tr>
<tr class="separator:a91ec4c7e7bd4d19b11f0674903ce630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;! is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b57f060bc5b930d00c088dc270cf15b"><td class="memTemplItemLeft" align="right" valign="top">T::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a4b57f060bc5b930d00c088dc270cf15b">inner_size</a> (const T &amp;tensor)</td></tr>
<tr class="memdesc:a4b57f060bc5b930d00c088dc270cf15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the inner size.  <a href="#a4b57f060bc5b930d00c088dc270cf15b">More...</a><br /></td></tr>
<tr class="separator:a4b57f060bc5b930d00c088dc270cf15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b25c9db0387e3327718de2cbc9112c6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6">empty</a> ()</td></tr>
<tr class="memdesc:a2b25c9db0387e3327718de2cbc9112c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors in an empty list.  <a href="#a2b25c9db0387e3327718de2cbc9112c6">More...</a><br /></td></tr>
<tr class="separator:a2b25c9db0387e3327718de2cbc9112c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ad9662eaa03fe6d3cdbe380e9cf5dea3e">empty</a> (const T1 &amp;tensor1, const Ts &amp;... tensors)</td></tr>
<tr class="memdesc:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for empty tensors.  <a href="#ad9662eaa03fe6d3cdbe380e9cf5dea3e">More...</a><br /></td></tr>
<tr class="separator:ad9662eaa03fe6d3cdbe380e9cf5dea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada724a31400bb94f55097560394438de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ada724a31400bb94f55097560394438de">make_tile</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:ada724a31400bb94f55097560394438de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for tiles.  <a href="#ada724a31400bb94f55097560394438de">More...</a><br /></td></tr>
<tr class="separator:ada724a31400bb94f55097560394438de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplParams" colspan="2">template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </td></tr>
<tr class="memitem:a58f2092d8f52e938f74173f7ede0b07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt; Iter1, Iter2, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a58f2092d8f52e938f74173f7ede0b07d">make_tran_it</a> (Iter1 it1, Iter2 it2, Op op)</td></tr>
<tr class="memdesc:a58f2092d8f52e938f74173f7ede0b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary Transform iterator factory.  <a href="#a58f2092d8f52e938f74173f7ede0b07d">More...</a><br /></td></tr>
<tr class="separator:a58f2092d8f52e938f74173f7ede0b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Op &gt; </td></tr>
<tr class="memitem:ab52e422e441d6c6cd06db1812f784e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt; Iter, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ab52e422e441d6c6cd06db1812f784e1c">make_tran_it</a> (Iter it, Op op)</td></tr>
<tr class="memdesc:ab52e422e441d6c6cd06db1812f784e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary Transform iterator factory.  <a href="#ab52e422e441d6c6cd06db1812f784e1c">More...</a><br /></td></tr>
<tr class="separator:ab52e422e441d6c6cd06db1812f784e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d281f943194c67e7b0a491f03d49e02"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5d281f943194c67e7b0a491f03d49e02"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02">size</a> (T(&amp;)[N])</td></tr>
<tr class="memdesc:a5d281f943194c67e7b0a491f03d49e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size accessor.  <a href="#a5d281f943194c67e7b0a491f03d49e02">More...</a><br /></td></tr>
<tr class="separator:a5d281f943194c67e7b0a491f03d49e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3432456d26bf2a1704062cb243f71b5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae3432456d26bf2a1704062cb243f71b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ae3432456d26bf2a1704062cb243f71b5">size</a> (const std::array&lt; T, N &gt; &amp;)</td></tr>
<tr class="memdesc:ae3432456d26bf2a1704062cb243f71b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size accessor.  <a href="#ae3432456d26bf2a1704062cb243f71b5">More...</a><br /></td></tr>
<tr class="separator:ae3432456d26bf2a1704062cb243f71b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3063dba937c6812cf1b4c68bc38018"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;! std::is_array&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1f3063dba937c6812cf1b4c68bc38018"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a1f3063dba937c6812cf1b4c68bc38018">size</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a1f3063dba937c6812cf1b4c68bc38018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size accessor.  <a href="#a1f3063dba937c6812cf1b4c68bc38018">More...</a><br /></td></tr>
<tr class="separator:a1f3063dba937c6812cf1b4c68bc38018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651b76b9b60aafe404bbb49ff767a002"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a651b76b9b60aafe404bbb49ff767a002"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a651b76b9b60aafe404bbb49ff767a002">size</a> (std::initializer_list&lt; T &gt; a)</td></tr>
<tr class="memdesc:a651b76b9b60aafe404bbb49ff767a002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size accessor.  <a href="#a651b76b9b60aafe404bbb49ff767a002">More...</a><br /></td></tr>
<tr class="separator:a651b76b9b60aafe404bbb49ff767a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4feb853354fa321476311df881c874b8"><td class="memTemplParams" colspan="2">template&lt;typename ... Ts&gt; </td></tr>
<tr class="memitem:a4feb853354fa321476311df881c874b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a4feb853354fa321476311df881c874b8">size</a> (const std::tuple&lt; Ts... &gt; &amp;a)</td></tr>
<tr class="memdesc:a4feb853354fa321476311df881c874b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple size accessor.  <a href="#a4feb853354fa321476311df881c874b8">More...</a><br /></td></tr>
<tr class="separator:a4feb853354fa321476311df881c874b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af183b69afaf157592feb750540f764b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;! std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af183b69afaf157592feb750540f764b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6">data</a> (T &amp;t)</td></tr>
<tr class="memdesc:af183b69afaf157592feb750540f764b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container data pointer accessor.  <a href="#af183b69afaf157592feb750540f764b6">More...</a><br /></td></tr>
<tr class="separator:af183b69afaf157592feb750540f764b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1217b48555aa3ccb9d3c798d2a9a325"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;! std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa1217b48555aa3ccb9d3c798d2a9a325"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa1217b48555aa3ccb9d3c798d2a9a325">data</a> (const T &amp;t)</td></tr>
<tr class="memdesc:aa1217b48555aa3ccb9d3c798d2a9a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container data pointer accessor.  <a href="#aa1217b48555aa3ccb9d3c798d2a9a325">More...</a><br /></td></tr>
<tr class="separator:aa1217b48555aa3ccb9d3c798d2a9a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2522fa9dce38df89d59c259234ae97"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:adc2522fa9dce38df89d59c259234ae97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#adc2522fa9dce38df89d59c259234ae97">data</a> (T t)</td></tr>
<tr class="memdesc:adc2522fa9dce38df89d59c259234ae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer data adapter.  <a href="#adc2522fa9dce38df89d59c259234ae97">More...</a><br /></td></tr>
<tr class="separator:adc2522fa9dce38df89d59c259234ae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#af4497aea8e7d4da928677e84dbd9a8d2">data</a> (T(&amp;a)[N])</td></tr>
<tr class="memdesc:af4497aea8e7d4da928677e84dbd9a8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array data pointer accessor.  <a href="#af4497aea8e7d4da928677e84dbd9a8d2">More...</a><br /></td></tr>
<tr class="separator:af4497aea8e7d4da928677e84dbd9a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9089108f04afecf1a84e407e12f6789b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9089108f04afecf1a84e407e12f6789b"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a9089108f04afecf1a84e407e12f6789b">data</a> (const T(&amp;a)[N])</td></tr>
<tr class="memdesc:a9089108f04afecf1a84e407e12f6789b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array data pointer accessor.  <a href="#a9089108f04afecf1a84e407e12f6789b">More...</a><br /></td></tr>
<tr class="separator:a9089108f04afecf1a84e407e12f6789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#ac74aa9708c3bef3b4f6a349fafcc61dd">data</a> (std::initializer_list&lt; T &gt; &amp;l)</td></tr>
<tr class="memdesc:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list data pointer accessor.  <a href="#ac74aa9708c3bef3b4f6a349fafcc61dd">More...</a><br /></td></tr>
<tr class="separator:ac74aa9708c3bef3b4f6a349fafcc61dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca80e64fd39a776342605ae74915df46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca80e64fd39a776342605ae74915df46"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aca80e64fd39a776342605ae74915df46">data</a> (const std::initializer_list&lt; T &gt; &amp;l)</td></tr>
<tr class="memdesc:aca80e64fd39a776342605ae74915df46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list const data pointer accessor.  <a href="#aca80e64fd39a776342605ae74915df46">More...</a><br /></td></tr>
<tr class="separator:aca80e64fd39a776342605ae74915df46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5cd635d089830705f84e08204967760d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d">print_array</a> (std::ostream &amp;out, const A &amp;a, const std::size_t n)</td></tr>
<tr class="memdesc:a5cd635d089830705f84e08204967760d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="#a5cd635d089830705f84e08204967760d">More...</a><br /></td></tr>
<tr class="separator:a5cd635d089830705f84e08204967760d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a2c0a678c425372465314f925b87612ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce">print_array</a> (std::ostream &amp;out, const A &amp;a)</td></tr>
<tr class="memdesc:a2c0a678c425372465314f925b87612ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the content of an array like object.  <a href="#a2c0a678c425372465314f925b87612ce">More...</a><br /></td></tr>
<tr class="separator:a2c0a678c425372465314f925b87612ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_tiled_array_1_1detail.html#aa26bd55f3154ac62a00c6ff633db1d40">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;val_array)</td></tr>
<tr class="separator:aa26bd55f3154ac62a00c6ff633db1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af97c9bf4ef025af9a6a81c86b49d2fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97c9bf4ef025af9a6a81c86b49d2fad">&#9670;&nbsp;</a></span>add_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#af97c9bf4ef025af9a6a81c86b49d2fad">TiledArray::detail::add_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() + std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00741">741</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a196b35f7b6b1ccdb872eeca1353bb26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196b35f7b6b1ccdb872eeca1353bb26b">&#9670;&nbsp;</a></span>const_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">TiledArray::detail::const_if_t</a> = typedef typename std::conditional&lt;B, const T, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepends <code>const</code> to <code>T</code> if <code>B</code> is <code>true</code> </p>

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00653">653</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a0808e462394d3ca16b63a873448283bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0808e462394d3ca16b63a873448283bd">&#9670;&nbsp;</a></span>mult_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a0808e462394d3ca16b63a873448283bd">TiledArray::detail::mult_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() * std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00748">748</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a763e783371e091990055d391dc6d2090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763e783371e091990055d391dc6d2090">&#9670;&nbsp;</a></span>numeric_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a763e783371e091990055d391dc6d2090">TiledArray::detail::numeric_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1numeric__type.html">TiledArray::detail::numeric_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00525">525</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a0d58e523957afcbcb1a47b8d98ab30d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d58e523957afcbcb1a47b8d98ab30d5">&#9670;&nbsp;</a></span>param_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a0d58e523957afcbcb1a47b8d98ab30d5">TiledArray::detail::param_type</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1param.html">param</a>&lt;U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00677">677</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a11981ec4cf6f0e145fe51fa42c93ec10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11981ec4cf6f0e145fe51fa42c93ec10">&#9670;&nbsp;</a></span>pmap_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a11981ec4cf6f0e145fe51fa42c93ec10">TiledArray::detail::pmap_t</a> = typedef typename T::pmap_interface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00770">770</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a187720de6c845523407c42fb2ebe0385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187720de6c845523407c42fb2ebe0385">&#9670;&nbsp;</a></span>policy_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a187720de6c845523407c42fb2ebe0385">TiledArray::detail::policy_t</a> = typedef typename T::policy_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00773">773</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a5d3c6ec63959b5ed57e480adf45732d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3c6ec63959b5ed57e480adf45732d7">&#9670;&nbsp;</a></span>scalar_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a5d3c6ec63959b5ed57e480adf45732d7">TiledArray::detail::scalar_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1scalar__type.html">TiledArray::detail::scalar_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00555">555</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a3199b02c7815c0d03a919fc87807656a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3199b02c7815c0d03a919fc87807656a">&#9670;&nbsp;</a></span>shape_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a3199b02c7815c0d03a919fc87807656a">TiledArray::detail::shape_t</a> = typedef typename T::shape_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00767">767</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="abeb1097bfa2f729cf40656648ed4116a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb1097bfa2f729cf40656648ed4116a">&#9670;&nbsp;</a></span>subt_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar1 , typename Scalar2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#abeb1097bfa2f729cf40656648ed4116a">TiledArray::detail::subt_t</a> = typedef decltype(std::declval&lt;Scalar1&gt;() - std::declval&lt;Scalar2&gt;())</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00745">745</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a06e12c23ae1ad65ad65ef54b041abb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e12c23ae1ad65ad65ef54b041abb37">&#9670;&nbsp;</a></span>trange_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a06e12c23ae1ad65ad65ef54b041abb37">TiledArray::detail::trange_t</a> = typedef typename T::trange_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00764">764</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<a id="a9fec2bd28d7a936780f5c2eb94379ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fec2bd28d7a936780f5c2eb94379ace">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_tiled_array_1_1detail.html#a9fec2bd28d7a936780f5c2eb94379ace">TiledArray::detail::void_t</a> = typedef typename <a class="el" href="struct_tiled_array_1_1detail_1_1make__void.html">make_void</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="type__traits_8h_source.html#l00282">282</a> of file <a class="el" href="type__traits_8h_source.html">type_traits.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af61cbefb29ceef11f580804c689464d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61cbefb29ceef11f580804c689464d1">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00247">247</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph" id="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a96bafe4052acf5d99d2ef8010f362648" title="TiledArray::detail::abs" alt="" coords="203,5,353,31"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title="TiledArray::detail\l::ComplexConjugate::\lfactor" alt="" coords="203,55,353,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph" id="namespace_tiled_array_1_1detail_af61cbefb29ceef11f580804c689464d1_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_d_i_i_s.html#adba4b9aeb0b361453aeb9c48c1dd992a" title="TiledArray::DIIS::compute\l_extrapolation_parameters" alt="" coords="213,5,393,44"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_sparse_shape.html#a6e638781d0d2ec4347947b7ed627b9e5" title="TiledArray::SparseShape::add" alt="" coords="203,68,403,93"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tensor.html#ae6914ca99f535592a4477df637511b58" title="Absolute minimum element. " alt="" coords="220,117,386,156"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_tensor.html#a5f7a6a051f5d87261a8b71a078d68624" title="Absolute maximum element. " alt="" coords="218,180,388,219"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a904224147ac9f4987473e6edc87d5607" title="Absolute minimum element. " alt="" coords="214,243,392,281"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad398d3bad05eb83e635b316984e31994" title="Absolute maximum element. " alt="" coords="212,305,394,344"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1_abs_min_reduction.html#acf3f9d18d0be4c35a32cf796ed015391" title="TiledArray::AbsMinReduction\l::operator()" alt="" coords="206,368,400,407"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1_abs_max_reduction.html#ab05cf71172dd6761932d3053d5be99bb" title="TiledArray::AbsMaxReduction\l::operator()" alt="" coords="204,431,401,469"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_d_i_i_s.html#a6fd568abd2246acbc0f6ea1ee6e20905" title="TiledArray::DIIS::extrapolate" alt="" coords="451,12,639,37"/>
<area shape="rect" id="node4" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="687,5,888,44"/>
</map>
</div>

</div>
</div>
<a id="a96bafe4052acf5d99d2ef8010f362648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bafe4052acf5d99d2ef8010f362648">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TiledArray::detail::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00251">251</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph" id="namespace_tiled_array_1_1detail_a96bafe4052acf5d99d2ef8010f362648_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af61cbefb29ceef11f580804c689464d1" title="TiledArray::detail::abs" alt="" coords="203,219,353,244"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_d_i_i_s.html#adba4b9aeb0b361453aeb9c48c1dd992a" title="TiledArray::DIIS::compute\l_extrapolation_parameters" alt="" coords="411,5,591,44"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_sparse_shape.html#a6e638781d0d2ec4347947b7ed627b9e5" title="TiledArray::SparseShape::add" alt="" coords="401,68,600,93"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_tensor.html#ae6914ca99f535592a4477df637511b58" title="Absolute minimum element. " alt="" coords="417,117,584,156"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_tensor.html#a5f7a6a051f5d87261a8b71a078d68624" title="Absolute maximum element. " alt="" coords="415,180,586,219"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a904224147ac9f4987473e6edc87d5607" title="Absolute minimum element. " alt="" coords="411,243,590,281"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad398d3bad05eb83e635b316984e31994" title="Absolute maximum element. " alt="" coords="410,305,592,344"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1_abs_min_reduction.html#acf3f9d18d0be4c35a32cf796ed015391" title="TiledArray::AbsMinReduction\l::operator()" alt="" coords="404,368,597,407"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1_abs_max_reduction.html#ab05cf71172dd6761932d3053d5be99bb" title="TiledArray::AbsMaxReduction\l::operator()" alt="" coords="402,431,599,469"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_d_i_i_s.html#a6fd568abd2246acbc0f6ea1ee6e20905" title="TiledArray::DIIS::extrapolate" alt="" coords="648,12,837,37"/>
<area shape="rect" id="node5" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="885,5,1086,44"/>
</map>
</div>

</div>
</div>
<a id="ab3099e3f966559b8e09bca8d63327117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3099e3f966559b8e09bca8d63327117">&#9670;&nbsp;</a></span>clone_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00046">46</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="afd25794432f3ae654ef616a170280af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd25794432f3ae654ef616a170280af3">&#9670;&nbsp;</a></span>clone_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;! is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::detail::clone_range </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a contiguous copy of the range of the tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor with the range to be cloned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous range with the same lower and upper bounds as the range of <code>tensor</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00057">57</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="a32a7abe197b45ae95a4132fc240ed383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a7abe197b45ae95a4132fc240ed383">&#9670;&nbsp;</a></span>conj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename std::enable_if&lt;! is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::conj </td>
          <td>(</td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for <code>std::conj</code> </p>
<p>This function disables the call to <code>std::conj</code> for real values to prevent the result from being converted into a complex value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A real scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The real scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00044">44</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph" id="namespace_tiled_array_1_1detail_a32a7abe197b45ae95a4132fc240ed383_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1expressions.html#ae722690ae817f2c2c146501b91571b63" title="Conjugated addition expression factor. " alt="" coords="185,5,345,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#ad02d47cab0fc5866bf2eb5c13acf659b" title="TiledArray::detail\l::operator*" alt="" coords="204,68,325,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#acea2c5a93d37330153912da87c7c3877" title="TiledArray::detail\l::operator*=" alt="" coords="204,131,325,169"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#a1d62bd1335311d0dbe8238448ec6d588" title="Post processing step. " alt="" coords="174,193,356,272"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a45a9acd171ceb8dc827b91bd9274eccd" title="Post processing step. " alt="" coords="174,296,356,375"/>
</map>
</div>

</div>
</div>
<a id="a381e9dfb596a18e208171ce358fa6f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381e9dfb596a18e208171ce358fa6f16">&#9670;&nbsp;</a></span>conj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE std::complex&lt;R&gt; TiledArray::detail::conj </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; R &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for std::conj. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The complex scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of <code>z</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00054">54</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a id="a78aafa383b1b3e69b6e57b6b78c61306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aafa383b1b3e69b6e57b6b78c61306">&#9670;&nbsp;</a></span>conj_op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt;S&gt; TiledArray::detail::conj_op </td>
          <td>(</td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaling complex conjugate operator </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00181">181</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph" id="namespace_tiled_array_1_1detail_a78aafa383b1b3e69b6e57b6b78c61306_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1expressions.html#a2f6eaac7474c21d2dcf7011c9482d451" title="Conjugated addition expression factory. " alt="" coords="181,5,341,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1expressions.html#adcbec0b860ce069ce48c75a3e0557e1b" title="Scaled&#45;conjugated addition expression factor. " alt="" coords="181,68,341,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1expressions.html#aaebd5a10232ff66a66c441743ca395a8" title="Negated&#45;conjugated addition expression factor. " alt="" coords="181,131,341,169"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr.html#a11b87883dd26561d3ac7a252ccd37f42" title="Conjugated block tensor expression factory. " alt="" coords="181,193,341,232"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_3_01const_01_array_00_01true_01_4.html#ab72ba1e9a6126fe2b2e45bddaf1e08ab" title="Conjugated block tensor expression factory. " alt="" coords="174,256,348,308"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1expressions_1_1_tsr_expr.html#a4a4bbfbd8b479f439045e28b747a9eee" title="Conjugated&#45;tensor expression factor. " alt="" coords="181,332,341,371"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1expressions_1_1_tsr_expr_3_01const_01_array_00_01true_01_4.html#a67dd7bde45b64a4376abf5b7e1d51885" title="Conjugated&#45;tensor expression factor. " alt="" coords="181,395,341,447"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_tensor.html#a78bda38f32136cd4fea2d438e13ca7ab" title="Create a complex conjugated copy of this tensor. " alt="" coords="191,471,331,509"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1_tensor.html#af3ada2b7db72107f273a04394bdccac5" title="Complex conjugate this tensor. " alt="" coords="181,533,341,572"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a67a1c4a647b8047719f9665f17f04039" title="Create a complex conjugated copy of this tensor. " alt="" coords="185,596,337,635"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae72e40cb8cf82a93f9162297deb644e5" title="Complex conjugate this tensor. " alt="" coords="175,659,346,697"/>
</map>
</div>

</div>
</div>
<a id="ab2c470158b2bbbdb712cbbaf18a55101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c470158b2bbbdb712cbbaf18a55101">&#9670;&nbsp;</a></span>conj_op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt;void&gt; TiledArray::detail::conj_op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a> operator factory function. </p>
<dl class="section return"><dt>Returns</dt><dd>A complex conjugate operator </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00188">188</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a id="a8aab6018796760c407b5cc53295568ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aab6018796760c407b5cc53295568ed">&#9670;&nbsp;</a></span>counted_btas_subtensor_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DistArray_ , typename BTAS_Tensor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_btas_subtensor_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const BTAS_Tensor_ *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistArray_ *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DistArray_::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for converting btas::Tensor subblock to a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DistArray_</td><td>a <a class="el" href="class_tiled_array_1_1_dist_array.html" title="Forward declarations. ">TiledArray::DistArray</a> type </td></tr>
    <tr><td class="paramname">TArgs</td><td>the type pack in btas::Tensor&lt;TArgs...&gt; type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The btas::Tensor object whose block will be copied </td></tr>
    <tr><td class="paramname">dst</td><td>The array that will hold the result </td></tr>
    <tr><td class="paramname">i</td><td>The index of the tile to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00099">99</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a8aab6018796760c407b5cc53295568ed_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a8aab6018796760c407b5cc53295568ed_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a8aab6018796760c407b5cc53295568ed_cgraph" id="namespace_tiled_array_1_1detail_a8aab6018796760c407b5cc53295568ed_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#aeefa8ea4cb95ebb8c9d9b3809f12dc4d" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="228,131,408,169"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="489,5,618,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title="TiledArray::detail\l::make_ta_range" alt="" coords="493,68,614,107"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="486,131,621,169"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="706,216,827,255"/>
<area shape="rect" id="node8" href="namespace_tiled_array.html#ada3e7bc14ca6d99904ada555922fc391" title="TiledArray::make_const_map" alt="" coords="456,245,651,271"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="699,131,834,169"/>
</map>
</div>

</div>
</div>
<a id="af50d31c15b208288edec33a0129649b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50d31c15b208288edec33a0129649b0">&#9670;&nbsp;</a></span>counted_eigen_submatrix_to_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_eigen_submatrix_to_tensor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename A::size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for converting <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix to a tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>Array type </td></tr>
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix that will be copied </td></tr>
    <tr><td class="paramname">array</td><td>The array that will hold the result </td></tr>
    <tr><td class="paramname">i</td><td>The index of the tile to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00296">296</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af50d31c15b208288edec33a0129649b0_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af50d31c15b208288edec33a0129649b0_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af50d31c15b208288edec33a0129649b0_cgraph" id="namespace_tiled_array_1_1detail_af50d31c15b208288edec33a0129649b0_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#add789e43efcee8db349c7ec5c6218664" title="Copy a block of an Eigen matrix into a tensor. " alt="" coords="235,33,422,72"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="483,5,612,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="470,68,625,93"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="673,29,802,68"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="673,92,802,131"/>
</map>
</div>

</div>
</div>
<a id="aae305e910ce674d71f550e104c354cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae305e910ce674d71f550e104c354cb5">&#9670;&nbsp;</a></span>counted_tensor_to_btas_subtensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA_Tensor_ , typename BTAS_Tensor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_tensor_to_btas_subtensor </td>
          <td>(</td>
          <td class="paramtype">const TA_Tensor_ &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BTAS_Tensor_ *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tensor_</td><td>a <a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">TiledArray::Tensor</a> type </td></tr>
    <tr><td class="paramname">TArgs</td><td>the type pack in btas::Tensor&lt;TArgs...&gt; type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source tensor </td></tr>
    <tr><td class="paramname">dst</td><td>The destination tensor </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00116">116</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph" id="namespace_tiled_array_1_1detail_aae305e910ce674d71f550e104c354cb5_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#ae862097c5ca7e7a8affa6275af008f63" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="193,131,331,169"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="392,5,521,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a45190dfcad5ef2b9af5b4aa000c844b0" title="TiledArray::detail\l::make_ta_range" alt="" coords="396,68,517,107"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="389,131,524,169"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1detail.html#af183b69afaf157592feb750540f764b6" title="Container data pointer accessor. " alt="" coords="589,216,710,255"/>
<area shape="rect" id="node8" href="namespace_tiled_array.html#a4b3f6231b75b996d3fa766849f952eef" title="TiledArray::make_map" alt="" coords="379,245,534,271"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="582,131,718,169"/>
</map>
</div>

</div>
</div>
<a id="afe493525138ef355ba76900e56ae8cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe493525138ef355ba76900e56ae8cf2">&#9670;&nbsp;</a></span>counted_tensor_to_eigen_submatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::counted_tensor_to_eigen_submatrix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">madness::AtomicInt *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function for assigning a tensor to an <a class="el" href="namespace_eigen.html" title="Forward declarations. ">Eigen</a> submatrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>The matrix type </td></tr>
    <tr><td class="paramname">T</td><td><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be assigned </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be copied </td></tr>
    <tr><td class="paramname">counter</td><td>The task counter </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conversions_2eigen_8h_source.html#l00313">313</a> of file <a class="el" href="conversions_2eigen_8h_source.html">eigen.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph" id="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a6a1e016346f447dcd7b5b4d7f29246b6" title="Copy the content of a tensor into an Eigen matrix block. " alt="" coords="193,33,338,72"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#ac6cab4cebeee61ec14aaf83ecc4b9952" title="Tensor range object accessor. " alt="" coords="399,5,528,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array.html#af872c21673f2fd74250d0257fb80f2bb" title="Construct a const Eigen::Map object for a given Tensor object. " alt="" coords="386,68,541,93"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a7a5d51ad92926e508e76204156847964" title="Tensor dimension size accessor. " alt="" coords="589,29,718,68"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tensor.html#a9270d658412efce71cde14a4e9488664" title="Data direct access. " alt="" coords="589,92,718,131"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph" id="namespace_tiled_array_1_1detail_afe493525138ef355ba76900e56ae8cf2_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#ad4ffc6de9b633a34e7d724191cd11f3f" title="Convert an Array object into an Eigen matrix object. " alt="" coords="193,12,330,51"/>
</map>
</div>

</div>
</div>
<a id="af183b69afaf157592feb750540f764b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af183b69afaf157592feb750540f764b6">&#9670;&nbsp;</a></span>data() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;! std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A container object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the container, <code>v</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00089">89</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af183b69afaf157592feb750540f764b6_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af183b69afaf157592feb750540f764b6_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af183b69afaf157592feb750540f764b6_icgraph" id="namespace_tiled_array_1_1detail_af183b69afaf157592feb750540f764b6_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_d_i_i_s.html#a2d6a73c95db1be7695858a254fa6acb1" title="TiledArray::DIIS::reinitialize" alt="" coords="181,5,362,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#aeefa8ea4cb95ebb8c9d9b3809f12dc4d" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="416,83,597,121"/>
<area shape="rect" id="node5" href="namespace_tiled_array.html#ae862097c5ca7e7a8affa6275af008f63" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="437,168,576,207"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_range.html#a8e43ff7ba296a6c6fb589d2af5221b3c" title="Shift the lower and upper bound of this range. " alt="" coords="203,257,339,296"/>
<area shape="rect" id="node9" href="namespace_tiled_array.html#a4b3f6231b75b996d3fa766849f952eef" title="TiledArray::make_map" alt="" coords="194,208,349,233"/>
<area shape="rect" id="node10" href="namespace_tiled_array.html#ada3e7bc14ca6d99904ada555922fc391" title="TiledArray::make_const_map" alt="" coords="174,107,368,132"/>
<area shape="rect" id="node11" href="namespace_tiled_array.html#af647aa352f5f2099f6c4ee3ca8c1ba39" title="For reusing map without allocating new ranges . . . maybe. " alt="" coords="208,320,335,345"/>
<area shape="rect" id="node12" href="namespace_tiled_array.html#a2b1fa4c93060bc503429e3527f2993ad" title="TiledRange permutation operator. " alt="" coords="199,369,343,395"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a8aab6018796760c407b5cc53295568ed" title="Task function for converting btas::Tensor subblock to a TiledArray::DistArray. " alt="" coords="645,76,819,128"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix. " alt="" coords="662,161,802,213"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_range.html#af3d2ada3894c8cd4661734a8d3e6b6be" title="Shift the lower and upper bound of this range. " alt="" coords="439,257,574,296"/>
</map>
</div>

</div>
</div>
<a id="aa1217b48555aa3ccb9d3c798d2a9a325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1217b48555aa3ccb9d3c798d2a9a325">&#9670;&nbsp;</a></span>data() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;! std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A container object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the container, <code>v</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00101">101</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="adc2522fa9dce38df89d59c259234ae97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2522fa9dce38df89d59c259234ae97">&#9670;&nbsp;</a></span>data() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_pointer&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer data adapter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>t</code> (pass through) </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00111">111</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="af4497aea8e7d4da928677e84dbd9a8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4497aea8e7d4da928677e84dbd9a8d2">&#9670;&nbsp;</a></span>data() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The c-style array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00119">119</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="a9089108f04afecf1a84e407e12f6789b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9089108f04afecf1a84e407e12f6789b">&#9670;&nbsp;</a></span>data() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>a</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The c-style array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the array </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00127">127</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="ac74aa9708c3bef3b4f6a349fafcc61dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74aa9708c3bef3b4f6a349fafcc61dd">&#9670;&nbsp;</a></span>data() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The initializer list element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer list object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element of the initializer list, <code>l</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00136">136</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="aca80e64fd39a776342605ae74915df46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca80e64fd39a776342605ae74915df46">&#9670;&nbsp;</a></span>data() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* TiledArray::detail::data </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer list const data pointer accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The initializer list element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>An initializer list object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the first element of the initializer list, <code>l</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00144">144</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="ae2c7d290f2fb4704eecc33b0894de068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c7d290f2fb4704eecc33b0894de068">&#9670;&nbsp;</a></span>diagonal_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> TiledArray::detail::diagonal_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_range.html">Range</a> const &amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00040">40</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph" id="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="174,5,310,44"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_range.html#ad59f6239bab9c89dac6fcccd6dbf8505" title="Range upper bound accessor. " alt="" coords="174,68,310,107"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="358,5,494,44"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#af38569cb05cfd8691647b1be6c702a4b" title="Range upper bound data accessor. " alt="" coords="358,68,494,107"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph" id="namespace_tiled_array_1_1detail_ae2c7d290f2fb4704eecc33b0894de068_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a33aa537f17e1c4de2e8abf7093e29699" title="TiledArray::detail\l::diagonal_shape" alt="" coords="185,5,308,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a31b41f257f8f107174ffbfd3b9e7c0c3" title="TiledArray::detail\l::write_tiles_to_array" alt="" coords="174,68,319,107"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#ae8fd6c6add8ea900d7d2350fbe652390" title="TiledArray::sparse\l_diagonal_array" alt="" coords="394,5,523,44"/>
<area shape="rect" id="node5" href="namespace_tiled_array.html#a1ddaca49af12c55a7e2087ad77aa8035" title="TiledArray::dense_diagonal\l_array" alt="" coords="367,68,550,107"/>
</map>
</div>

</div>
</div>
<a id="a33aa537f17e1c4de2e8abf7093e29699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33aa537f17e1c4de2e8abf7093e29699">&#9670;&nbsp;</a></span>diagonal_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tensor.html">Tensor</a>&lt;float&gt; TiledArray::detail::diagonal_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledRange</a> const &amp;&#160;</td>
          <td class="paramname"><em>trange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00058">58</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph" id="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tiled_range.html#a1980b233eaa1fc559b62cc8affc2bd34" title="Access the tile range. " alt="" coords="383,41,540,80"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tiled_range.html#a968fbd936a1606e7885e0912a739f331" title="Access the element range. " alt="" coords="176,38,333,77"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_range.html#adc6eb6d7ffa9defd3c7e6aae88080b2b" title="Range extent accessor. " alt="" coords="187,164,322,202"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tiled_range.html#ac8c1d53822fd3da51824e4d97a11dd2a" title="The rank accessor. " alt="" coords="383,224,540,262"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_tiled_range.html#a86b5cfd5057656694062f4498d548be8" title="Convert an element index to a tile index. " alt="" coords="176,278,333,317"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_tiled_range.html#a7d6579a946eb52c648b440a5f7d087d8" title="Construct a range for the tile indexed by the given ordinal index. " alt="" coords="176,101,333,140"/>
<area shape="rect" id="node10" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="TiledArray::detail\l::diagonal_range" alt="" coords="194,341,315,380"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#afd7dd885ff139cc535b8f1e42a4442f3" title="Range extent data accessor. " alt="" coords="394,161,530,200"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="381,286,543,312"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="394,338,530,377"/>
<area shape="rect" id="node13" href="class_tiled_array_1_1_range.html#ad59f6239bab9c89dac6fcccd6dbf8505" title="Range upper bound accessor. " alt="" coords="394,401,530,440"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="591,338,726,377"/>
<area shape="rect" id="node14" href="class_tiled_array_1_1_range.html#af38569cb05cfd8691647b1be6c702a4b" title="Range upper bound data accessor. " alt="" coords="591,401,726,440"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph" id="namespace_tiled_array_1_1detail_a33aa537f17e1c4de2e8abf7093e29699_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#ae8fd6c6add8ea900d7d2350fbe652390" title="TiledArray::sparse\l_diagonal_array" alt="" coords="176,5,305,44"/>
</map>
</div>

</div>
</div>
<a id="ad38f2970e843e56f76822d775d4d52c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38f2970e843e56f76822d775d4d52c9">&#9670;&nbsp;</a></span>dummy_annotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TiledArray::detail::dummy_annotation </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>DIM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00038">38</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ad38f2970e843e56f76822d775d4d52c9_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ad38f2970e843e56f76822d775d4d52c9_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ad38f2970e843e56f76822d775d4d52c9_icgraph" id="namespace_tiled_array_1_1detail_ad38f2970e843e56f76822d775d4d52c9_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a3558ec56f9d00590c35846d8f13c1b76" title="TiledArray::zero" alt="" coords="219,140,334,165"/>
<area shape="rect" id="node9" href="namespace_tiled_array.html#afc4078d3b132757efef1b74e42575149" title="TiledArray::minabs\l_value" alt="" coords="679,193,811,232"/>
<area shape="rect" id="node11" href="namespace_tiled_array.html#a8553a88a5735149954d4d04e491e7358" title="TiledArray::maxabs\l_value" alt="" coords="209,251,345,289"/>
<area shape="rect" id="node12" href="namespace_tiled_array.html#a297fc199c0e4a33cd3d6122b7c71f514" title="TiledArray::vec_multiply" alt="" coords="195,313,358,339"/>
<area shape="rect" id="node13" href="namespace_tiled_array.html#abc0b1ca917df616d05128c35276462fd" title="TiledArray::dot_product" alt="" coords="197,363,356,388"/>
<area shape="rect" id="node16" href="namespace_tiled_array.html#a90e2f4b420375c45a2c21049e27377aa" title="TiledArray::scale" alt="" coords="217,756,337,781"/>
<area shape="rect" id="node23" href="namespace_tiled_array.html#a299983d3798619c4de88f351bbe369ae" title="TiledArray::axpy" alt="" coords="446,437,563,463"/>
<area shape="rect" id="node25" href="namespace_tiled_array.html#ad096df7fd3592ff4515f97a0fc3f98ef" title="TiledArray::norm2" alt="" coords="213,528,340,553"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_d_i_i_s.html#a06b179576a5abf9a2b066cee36269573" title="TiledArray::DIIS::extrapolate" alt="" coords="410,144,598,169"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_bitset.html#aea1cb8c3bbaa37ad3209373c72f2ab89" title="Construct a bitset that contains s bits. " alt="" coords="444,19,565,57"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1detail_1_1_bitset.html#af6ac8b2ce6b551e0f13df10c42c74ed1" title="Set all bits. " alt="" coords="444,81,565,120"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1detail_1_1_bitset.html#a19ac1d02d6e0ff46da6d47d2a9ceb7ae" title="TiledArray::detail\l::Bitset::operator\&lt;\&lt;=" alt="" coords="673,131,816,169"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1detail_1_1_bitset.html#ae6babfe6e53e686d7bd4f496b5e76b56" title="TiledArray::detail\l::Bitset::operator\&gt;\&gt;=" alt="" coords="673,5,816,44"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1detail_1_1_bitset.html#a08005e43683b3ee3d2ba855278369974" title="Set a bit value. " alt="" coords="684,68,805,107"/>
<area shape="rect" id="node10" href="struct_tiled_array_1_1_conjugate_gradient_solver.html#ae3a281e82d2974cdb9decefcd69dff73" title="TiledArray::ConjugateGradient\lSolver::operator()" alt="" coords="887,377,1088,416"/>
<area shape="rect" id="node14" href="class_tiled_array_1_1_d_i_i_s.html#adba4b9aeb0b361453aeb9c48c1dd992a" title="TiledArray::DIIS::compute\l_extrapolation_parameters" alt="" coords="414,496,594,535"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1_d_i_i_s.html#a6fd568abd2246acbc0f6ea1ee6e20905" title="TiledArray::DIIS::extrapolate" alt="" coords="650,509,839,535"/>
<area shape="rect" id="node17" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc" title="Scalar the tile argument. " alt="" coords="444,841,564,867"/>
<area shape="rect" id="node18" href="group___tile_interface.html#gad452632b571bcbcc3be78b202e8a0a75" title="Scale tile operator. " alt="" coords="432,891,576,916"/>
<area shape="rect" id="node19" href="class_tiled_array_1_1tile__interface_1_1_scale.html#a6399e0a5c2048cfcbd4332b0d8bf2f42" title="TiledArray::tile_interface\l::Scale\&lt; Result, Arg, Scalar\l \&gt;::operator()" alt="" coords="412,940,596,992"/>
<area shape="rect" id="node20" href="class_tiled_array_1_1tile__interface_1_1_scale_3_01_result_00_01_arg_00_01_scalar_00_01typename_fbbb6b916c02e7c08977e87d208f321e.html#abcea4ac4ba21d246fade20533a526e70" title="TiledArray::tile_interface\l::Scale\&lt; Result, Arg, Scalar,\l typename std::enable_if\&lt; !\l std::is_same\&lt; Result, result\l_of_scale_t\&lt; Arg, Scalar \&gt; \&gt;::\lvalue \&gt;::type \&gt;::operator()" alt="" coords="406,611,602,703"/>
<area shape="rect" id="node21" href="class_tiled_array_1_1detail_1_1_scal_shift.html#a47e1706841cce77ac84f234c6f80312c" title="TiledArray::detail\l::ScalShift::eval" alt="" coords="444,779,565,817"/>
<area shape="rect" id="node22" href="class_tiled_array_1_1detail_1_1_scal_shift.html#ad1bc34cea69e4271db8b2bb42a966959" title="Shift and permute operator. " alt="" coords="671,779,818,817"/>
<area shape="rect" id="node24" href="namespacebtas.html#aafe8c6db2e1b1dc51b57424a46b21b27" title="result[i] += arg[i] " alt="" coords="697,460,792,485"/>
</map>
</div>

</div>
</div>
<a id="a2b25c9db0387e3327718de2cbc9112c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b25c9db0387e3327718de2cbc9112c6">&#9670;&nbsp;</a></span>empty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors in an empty list. </p>
<p>This function is used as the termination step for the recursive <a class="el" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. ">empty()</a> function. It also handles the case where there are no tensors in the list. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00374">374</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph" id="namespace_tiled_array_1_1detail_a2b25c9db0387e3327718de2cbc9112c6_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1detail_1_1transform.html#ae00da3d0d2f66eecc0bd866b737d1008" title="creates a result tensor in which element i is obtained by op(tensor[i], tensors[i]...) " alt="" coords="201,207,352,245"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3" title="In&#45;place tensor operations with contiguous data. " alt="" coords="208,269,346,308"/>
<area shape="rect" id="node19" href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95" title="Initialize tensor with contiguous tensor arguments. " alt="" coords="217,471,337,509"/>
<area shape="rect" id="node21" href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796" title="Reduction operation for contiguous tensors. " alt="" coords="217,533,337,572"/>
<area shape="rect" id="node33" href="namespace_tiled_array_1_1detail.html#ad9662eaa03fe6d3cdbe380e9cf5dea3e" title="Test for empty tensors. " alt="" coords="217,596,337,635"/>
<area shape="rect" id="node34" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step. " alt="" coords="174,659,380,777"/>
<area shape="rect" id="node35" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#a1d62bd1335311d0dbe8238448ec6d588" title="Post processing step. " alt="" coords="186,801,368,880"/>
<area shape="rect" id="node36" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a45a9acd171ceb8dc827b91bd9274eccd" title="Post processing step. " alt="" coords="186,904,368,983"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a6f2e00b7e50f7ba5858e3fa472d3e917" title="Assignment operator. " alt="" coords="448,5,619,44"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title="TiledArray::Tensor\l\&lt; value_type \&gt;::operator=" alt="" coords="446,68,620,107"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61" title="Use a binary, element wise operation to modify this tensor. " alt="" coords="454,131,613,183"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a" title="Use a unary, element wise operation to modify this tensor. " alt="" coords="434,207,633,245"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a83acf090e9a7de9165981577d80fe54d" title="TiledArray::detail\l::TensorInterface::operator=" alt="" coords="441,269,626,308"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a46a945ea3c88f00a52de46e667ce9ee0" title="Use a binary, element wise operation to modify this tensor. " alt="" coords="448,332,618,384"/>
<area shape="rect" id="node14" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8647a75373e134bca3a70713c5498562" title="Use a unary, element wise operation to modify this tensor. " alt="" coords="428,408,639,447"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae2d0943dc0d6a8b208e0a48424401c6b" title="Add other to this tensor. " alt="" coords="709,213,878,252"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aac121bc0cd56e31321951667ba39dc37" title="Subtract right from this tensor. " alt="" coords="708,276,880,315"/>
<area shape="rect" id="node13" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7669954a348702b2cf4f6f25b26f7369" title="Multiply this tensor by right. " alt="" coords="708,339,880,377"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a20530f66b536a7941cb23a55dd898d15" title="Subtract a constant from this tensor. " alt="" coords="949,213,1121,252"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2cd0a563ba38d684f2fa124fcc182d75" title="Scale this tensor. " alt="" coords="705,401,883,440"/>
<area shape="rect" id="node17" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7137f78d0b44663c90b7d8170f0aba9f" title="Add a constant to this tensor. " alt="" coords="709,464,878,503"/>
<area shape="rect" id="node18" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ab908e6e24c3bfc6f16949cf913741d8e" title="Negate elements of this tensor. " alt="" coords="709,527,878,565"/>
<area shape="rect" id="node16" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae72e40cb8cf82a93f9162297deb644e5" title="Complex conjugate this tensor. " alt="" coords="949,401,1120,440"/>
<area shape="rect" id="node20" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value. " alt="" coords="455,471,611,509"/>
<area shape="rect" id="node22" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794" title="Unary reduction operation. " alt="" coords="455,533,612,572"/>
<area shape="rect" id="node23" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0fc743f7d979b7282cfd211ade959643" title="Unary reduction operation. " alt="" coords="449,777,618,816"/>
<area shape="rect" id="node24" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a081774a07ad844f21135bc9cb248b41b" title="Sum of elements. " alt="" coords="717,589,870,628"/>
<area shape="rect" id="node25" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7798b8a0dd74454df7253bc8c9fc43dc" title="Product of elements. " alt="" coords="708,652,880,691"/>
<area shape="rect" id="node26" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf8ff6dede6f80fcef6c48eeffa30f5" title="Square of vector 2&#45;norm. " alt="" coords="687,715,901,753"/>
<area shape="rect" id="node28" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad4261a44ff666309159d6bbd4332c67a" title="Minimum element. " alt="" coords="719,777,869,816"/>
<area shape="rect" id="node29" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a323ce82713ac209600ae5a47e6f858ae" title="Maximum element. " alt="" coords="717,840,870,879"/>
<area shape="rect" id="node30" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a904224147ac9f4987473e6edc87d5607" title="Absolute minimum element. " alt="" coords="705,903,883,941"/>
<area shape="rect" id="node31" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad398d3bad05eb83e635b316984e31994" title="Absolute maximum element. " alt="" coords="703,965,885,1004"/>
<area shape="rect" id="node32" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a342be68250ef09785f8d08ed2c951e6e" title="Vector dot product. " alt="" coords="721,1028,867,1067"/>
<area shape="rect" id="node27" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a3da3d7e2c563c86416219238880bc3f7" title="Vector 2&#45;norm. " alt="" coords="956,715,1114,753"/>
</map>
</div>

</div>
</div>
<a id="ad9662eaa03fe6d3cdbe380e9cf5dea3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9662eaa03fe6d3cdbe380e9cf5dea3e">&#9670;&nbsp;</a></span>empty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::empty </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for empty tensors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to test </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensors to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if one or more tensors are empty </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00384">384</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph" id="namespace_tiled_array_1_1detail_ad9662eaa03fe6d3cdbe380e9cf5dea3e_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="a3277662ac15f21d2648c0401398bc787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3277662ac15f21d2648c0401398bc787">&#9670;&nbsp;</a></span>foreach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename... ArgTiles&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a>&gt; TiledArray::detail::foreach </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, <a class="el" href="class_tiled_array_1_1_dense_policy.html">DensePolicy</a> &gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>base implementation of dense <a class="el" href="namespace_tiled_array.html#a0c9f9298465a3cb1b6e7a10d5c1cb6bc" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a> </p>
<dl class="section note"><dt>Note</dt><dd>can't autodeduce <code>ResultTile</code> from <code>void</code> <code>Op(ResultTile,ArgTile)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00135">135</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a3277662ac15f21d2648c0401398bc787_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a3277662ac15f21d2648c0401398bc787_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a3277662ac15f21d2648c0401398bc787_cgraph" id="namespace_tiled_array_1_1detail_a3277662ac15f21d2648c0401398bc787_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="174,5,318,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#af7f0a051f5aa4b8a01558bb022f15a71" title="Find local or remote tile. " alt="" coords="174,68,318,107"/>
</map>
</div>

</div>
</div>
<a id="a7fc9379f0c1cb1725c489b5e89595665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc9379f0c1cb1725c489b5e89595665">&#9670;&nbsp;</a></span>foreach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool inplace = false, typename Op , typename ResultTile , typename ArgTile , typename... ArgTiles&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt;ResultTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a>&gt; TiledArray::detail::foreach </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_tiled_array.html#aa1333af3bbdd6ac34ec64a4eef6e9e07">ShapeReductionMethod</a>&#160;</td>
          <td class="paramname"><em>shape_reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array_1_1detail.html#a196b35f7b6b1ccdb872eeca1353bb26b">const_if_t</a>&lt; not inplace, <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTile, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_dist_array.html">DistArray</a>&lt; ArgTiles, <a class="el" href="class_tiled_array_1_1_sparse_policy.html">SparsePolicy</a> &gt; &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>base implementation of sparse <a class="el" href="namespace_tiled_array.html#a0c9f9298465a3cb1b6e7a10d5c1cb6bc" title="Apply a function to each tile of a dense Array. ">TiledArray::foreach</a> </p>
<dl class="section note"><dt>Note</dt><dd>can't autodeduce <code>ResultTile</code> from <code>void</code> <code>Op(ResultTile,ArgTile)</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="foreach_8h_source.html#l00174">174</a> of file <a class="el" href="foreach_8h_source.html">foreach.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a7fc9379f0c1cb1725c489b5e89595665_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a7fc9379f0c1cb1725c489b5e89595665_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a7fc9379f0c1cb1725c489b5e89595665_cgraph" id="namespace_tiled_array_1_1detail_a7fc9379f0c1cb1725c489b5e89595665_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="174,5,318,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_dist_array.html#af7f0a051f5aa4b8a01558bb022f15a71" title="Find local or remote tile. " alt="" coords="174,68,318,107"/>
</map>
</div>

</div>
</div>
<a id="aa3f00e852b717ed4084f8fd331d4e6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f00e852b717ed4084f8fd331d4e6c2">&#9670;&nbsp;</a></span>fuse_dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::fuse_dimensions </td>
          <td>(</td>
          <td class="paramtype">SizeType *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>fused_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>fused_weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SizeType *MADNESS_RESTRICT const&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the fused dimensions for permutation. </p>
<p>This function will compute the fused dimensions of a tensor for use in permutation algorithms. The idea is to partition the stride 1 dimensions in both the input and output tensor, which yields a forth-order tensor (second- and third-order tensors have size of 1 and stride of 0 in the unused dimensions). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SizeType</td><td>An unsigned integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_size</td><td>An array for the fused size output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fused_weight</td><td>An array for the fused weight output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>An array that holds the unfused size information of the argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to the argument tensor(s). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2permute_8h_source.html#l00051">51</a> of file <a class="el" href="tensor_2permute_8h_source.html">permute.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_cgraph" id="namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="182,5,372,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="217,55,337,93"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_icgraph" id="namespace_tiled_array_1_1detail_aa3f00e852b717ed4084f8fd331d4e6c2_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ae1a6955d66acd00dd89cd34669e7fe09" title="Construct a permuted tensor copy. " alt="" coords="182,68,303,107"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data. " alt="" coords="385,5,523,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20" title="Initialize tensor with permuted tensor arguments. " alt="" coords="393,68,514,107"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step. " alt="" coords="351,131,557,249"/>
</map>
</div>

</div>
</div>
<a id="a5031b9fe59e7561b395a2ef1c6b5e719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5031b9fe59e7561b395a2ef1c6b5e719">&#9670;&nbsp;</a></span>inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R , typename std::enable_if&lt;! is_complex&lt; L &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::inner_product </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inner product of a real value and a numeric value. </p>
<p>Inner product of a complex value and a numeric value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>A real scalar type </td></tr>
    <tr><td class="paramname">R</td><td>A numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>A complex type </td></tr>
    <tr><td class="paramname">R</td><td>A numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00065">65</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph" id="namespace_tiled_array_1_1detail_a5031b9fe59e7561b395a2ef1c6b5e719_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#a82161c441a1caca56cb1a894c6ebc7b0" title="Vector inner product. " alt="" coords="174,5,320,57"/>
</map>
</div>

</div>
</div>
<a id="a91ec4c7e7bd4d19b11f0674903ce630a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ec4c7e7bd4d19b11f0674903ce630a">&#9670;&nbsp;</a></span>inner_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;! is_contiguous_tensor&lt; T1 &gt;::value &amp;&amp;is_contiguous_tensor&lt; T2 &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size.</dd></dl>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest common, contiguous inner-dimension size of the two tensors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00313">313</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph" id="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size. " alt="" coords="174,5,308,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="356,5,477,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph" id="namespace_tiled_array_1_1detail_a91ec4c7e7bd4d19b11f0674903ce630a_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9" title="Initialize tensor with one or more non&#45;contiguous tensor arguments. " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="a4b57f060bc5b930d00c088dc270cf15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b57f060bc5b930d00c088dc270cf15b">&#9670;&nbsp;</a></span>inner_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;! is_contiguous_tensor&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00363">363</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph" id="namespace_tiled_array_1_1detail_a4b57f060bc5b930d00c088dc270cf15b_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size. " alt="" coords="174,5,308,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="356,5,477,44"/>
</map>
</div>

</div>
</div>
<a id="a85557b284f443993530894acbb158b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85557b284f443993530894acbb158b58">&#9670;&nbsp;</a></span>inner_size_helper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size. </p>
<p>This function searches of the largest contiguous size in the range of a non-contiguous tensor. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00244">244</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph" id="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="187,5,308,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph" id="namespace_tiled_array_1_1detail_a85557b284f443993530894acbb158b58_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a" title="Get the inner size of two tensors. " alt="" coords="187,5,308,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9" title="Initialize tensor with one or more non&#45;contiguous tensor arguments. " alt="" coords="356,5,477,44"/>
</map>
</div>

</div>
</div>
<a id="a227f69a3e3e5de0854bac8e8f2ec6cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227f69a3e3e5de0854bac8e8f2ec6cee">&#9670;&nbsp;</a></span>inner_size_helper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1::size_type TiledArray::detail::inner_size_helper </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the inner size of two tensors. </p>
<p>This function searches of the largest, common contiguous size in the ranges of two non-contiguous tensors. At a minimum, this is equal to the size of the stride-one dimension. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The secont tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be tested </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest contiguous, inner-dimension size of the two tensors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00275">275</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph" id="namespace_tiled_array_1_1detail_a227f69a3e3e5de0854bac8e8f2ec6cee_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor. " alt="" coords="187,5,334,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator. " alt="" coords="382,5,530,44"/>
</map>
</div>

</div>
</div>
<a id="ac7c2574bd1506d0e811e2c0eb58fb1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c2574bd1506d0e811e2c0eb58fb1e3">&#9670;&nbsp;</a></span>inplace_tensor_op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor operations with contiguous data. </p>
<p>In-place tensor of tensors operations with non-contiguous data.</p>
<p>In-place tensor operations with non-contiguous data.</p>
<p>In-place tensor of tensors operations with contiguous data.</p>
<p>This function sets the elements of <code>result</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the <code>i</code> -th element of <code>result</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00163">163</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph" id="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. " alt="" coords="217,5,337,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="191,68,363,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1math.html#af3538be07513fbf1cb420e6ff0631e52" title="TiledArray::math::inplace\l_vector_op" alt="" coords="193,131,361,169"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1math.html#a3fd6348022ed6ff4698c20bc8ec1a759" title="TiledArray::math::inplace\l_vector_op_serial" alt="" coords="411,131,579,169"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title="TiledArray::math::for\l_each_block" alt="" coords="627,99,769,137"/>
<area shape="rect" id="node8" href="namespace_tiled_array_1_1math.html#a75bfae8d964e10120d677654383c2d3b" title="TiledArray::math::for\l_each_block_n" alt="" coords="627,161,769,200"/>
<area shape="rect" id="node7" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a7588c344a42c08298668d265cf82b607" title="TiledArray::math::Vector\lOpUnwind::for_each" alt="" coords="817,99,981,137"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph" id="namespace_tiled_array_1_1detail_ac7c2574bd1506d0e811e2c0eb58fb1e3_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a6f2e00b7e50f7ba5858e3fa472d3e917" title="Assignment operator. " alt="" coords="211,5,382,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title="TiledArray::Tensor\l\&lt; value_type \&gt;::operator=" alt="" coords="210,68,383,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61" title="Use a binary, element wise operation to modify this tensor. " alt="" coords="217,131,376,183"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a" title="Use a unary, element wise operation to modify this tensor. " alt="" coords="197,207,396,245"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a83acf090e9a7de9165981577d80fe54d" title="TiledArray::detail\l::TensorInterface::operator=" alt="" coords="204,269,389,308"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a46a945ea3c88f00a52de46e667ce9ee0" title="Use a binary, element wise operation to modify this tensor. " alt="" coords="211,332,382,384"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8647a75373e134bca3a70713c5498562" title="Use a unary, element wise operation to modify this tensor. " alt="" coords="191,436,402,475"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae2d0943dc0d6a8b208e0a48424401c6b" title="Add other to this tensor. " alt="" coords="455,231,623,269"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aac121bc0cd56e31321951667ba39dc37" title="Subtract right from this tensor. " alt="" coords="453,293,625,332"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7669954a348702b2cf4f6f25b26f7369" title="Multiply this tensor by right. " alt="" coords="453,356,625,395"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a20530f66b536a7941cb23a55dd898d15" title="Subtract a constant from this tensor. " alt="" coords="676,231,848,269"/>
<area shape="rect" id="node13" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2cd0a563ba38d684f2fa124fcc182d75" title="Scale this tensor. " alt="" coords="450,419,628,457"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7137f78d0b44663c90b7d8170f0aba9f" title="Add a constant to this tensor. " alt="" coords="455,481,623,520"/>
<area shape="rect" id="node16" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ab908e6e24c3bfc6f16949cf913741d8e" title="Negate elements of this tensor. " alt="" coords="455,544,623,583"/>
<area shape="rect" id="node14" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae72e40cb8cf82a93f9162297deb644e5" title="Complex conjugate this tensor. " alt="" coords="676,419,847,457"/>
</map>
</div>

</div>
</div>
<a id="af174120ffd75a14d13077eff16452d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af174120ffd75a14d13077eff16452d9b">&#9670;&nbsp;</a></span>inplace_tensor_op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::inplace_tensor_op </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place tensor permutation operations with contiguous data. </p>
<p>In-place tensor of tensors permutation operations with contiguous data.</p>
<p>This function sets the <code>i</code> -th element of <code>result</code> with the result of <code>op</code>(tensor1[i],tensors[i]...) The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type, <span class="keyword">const</span> Ts::value_type...)</div></div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(TR::value_type*, <span class="keyword">const</span> TR::value_type)</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the <code>i</code> -th element of <code>result</code> with the result of <code>op</code>(tensor1[i], tensors[i]...) The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type op(<span class="keyword">const</span> T1::value_type::value_type, <span class="keyword">const</span> Ts::value_type::value_type...)</div></div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> op(TR::value_type::value_type*, <span class="keyword">const</span> TR::value_type::value_type)</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00225">225</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph" id="namespace_tiled_array_1_1detail_af174120ffd75a14d13077eff16452d9b_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. " alt="" coords="217,5,337,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor. " alt="" coords="204,68,350,107"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="191,131,363,169"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="643,195,833,220"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1detail.html#ae1a6955d66acd00dd89cd34669e7fe09" title="Construct a permuted tensor copy. " alt="" coords="217,276,337,315"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator. " alt="" coords="429,68,577,107"/>
<area shape="rect" id="node8" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title="TiledArray::math::vector\l_ptr_op" alt="" coords="422,308,584,347"/>
<area shape="rect" id="node13" href="namespace_tiled_array_1_1detail.html#aa3f00e852b717ed4084f8fd331d4e6c2" title="Compute the fused dimensions for permutation. " alt="" coords="439,245,568,284"/>
<area shape="rect" id="node15" href="namespace_tiled_array_1_1math.html#a0734d99af5ce0b09816a2934366c9071" title="Matrix transpose and initialization. " alt="" coords="411,373,595,399"/>
<area shape="rect" id="node9" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title="TiledArray::math::vector\l_ptr_op_serial" alt="" coords="657,308,820,347"/>
<area shape="rect" id="node10" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title="TiledArray::math::for\l_each_block_ptr" alt="" coords="1126,339,1268,377"/>
<area shape="rect" id="node12" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title="TiledArray::math::for\l_each_block_ptr_n" alt="" coords="905,308,1046,347"/>
<area shape="rect" id="node11" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#affa1c31a72285787675d68a07476d942" title="TiledArray::math::Vector\lOpUnwind::for_each_ptr" alt="" coords="1325,339,1490,377"/>
<area shape="rect" id="node14" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="678,245,799,284"/>
<area shape="rect" id="node16" href="namespace_tiled_array_1_1math.html#abb08079140fa4ea486e8d6e77baf7158" title="TiledArray::math::transpose\l_block" alt="" coords="646,371,831,409"/>
<area shape="rect" id="node17" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#a4f8998233c204a3e00403d3533a96137" title="TiledArray::math::Transpose\lUnwind::gather_trans" alt="" coords="881,433,1070,472"/>
<area shape="rect" id="node24" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#af2a30045172f690528b7854f863f3c23" title="TiledArray::math::Transpose\lUnwind::block_scatter" alt="" coords="881,371,1070,409"/>
<area shape="rect" id="node18" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title="TiledArray::math::for\l_each_block" alt="" coords="1126,401,1268,440"/>
<area shape="rect" id="node20" href="class_tiled_array_1_1math_1_1_block.html#a5b8fd799fcafd39809f7f7a5dcc2493f" title="TiledArray::math::Block\l::scatter_to" alt="" coords="1118,464,1276,503"/>
<area shape="rect" id="node19" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a7588c344a42c08298668d265cf82b607" title="TiledArray::math::Vector\lOpUnwind::for_each" alt="" coords="1326,401,1489,440"/>
<area shape="rect" id="node21" href="namespace_tiled_array_1_1math.html#a6137a96c445b26d23187018efa876aa5" title="TiledArray::math::scatter\l_block" alt="" coords="1324,464,1491,503"/>
<area shape="rect" id="node23" href="class_tiled_array_1_1math_1_1_block.html#a8541624decd7fa535c52f85c9499a0e1" title="TiledArray::math::Block\l::data" alt="" coords="1328,527,1487,565"/>
<area shape="rect" id="node22" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#ad76cb4c4568102c1faaefb5fab603a3c" title="TiledArray::math::Vector\lOpUnwind::scatter" alt="" coords="1539,464,1702,503"/>
</map>
</div>

</div>
</div>
<a id="a37574f8f8dd2104153b755e6e4427528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37574f8f8dd2104153b755e6e4427528">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test the two ranges are congruent. </p>
<p>This function tests that the rank, lower bound, and upper bound of <code>r1</code> is equal to that of <code>r2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a></td><td>The range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The second <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00069">69</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a37574f8f8dd2104153b755e6e4427528_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a37574f8f8dd2104153b755e6e4427528_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a37574f8f8dd2104153b755e6e4427528_icgraph" id="namespace_tiled_array_1_1detail_a37574f8f8dd2104153b755e6e4427528_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a1bc0dbda95a57b85aaec2b5d49a15009" title="Test that Range and BlockRange are congruent. " alt="" coords="187,5,308,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a0b9a43dfee2749874d4677ea89ab4188" title="Test that the ranges of a pair of tensors are congruent. " alt="" coords="174,68,321,107"/>
</map>
</div>

</div>
</div>
<a id="abf5c2b7b2f621d6bcff2c6e4e3d8cac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5c2b7b2f621d6bcff2c6e4e3d8cac0">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that two <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> are congruent. </p>
<p>This function tests that the rank, extent of <code>r1</code> is equal to that of <code>r2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The first <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The second <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00079">79</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_abf5c2b7b2f621d6bcff2c6e4e3d8cac0_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_abf5c2b7b2f621d6bcff2c6e4e3d8cac0_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_abf5c2b7b2f621d6bcff2c6e4e3d8cac0_cgraph" id="namespace_tiled_array_1_1detail_abf5c2b7b2f621d6bcff2c6e4e3d8cac0_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="174,5,336,31"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#afd7dd885ff139cc535b8f1e42a4442f3" title="Range extent data accessor. " alt="" coords="187,55,323,93"/>
</map>
</div>

</div>
</div>
<a id="aba84b2aab6ffebcfbf549eb997895654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba84b2aab6ffebcfbf549eb997895654">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> and <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> are congruent. </p>
<p>This function tests that the rank, extent of <code>r1</code> is equal to that of <code>r2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a></td><td>The range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00092">92</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aba84b2aab6ffebcfbf549eb997895654_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aba84b2aab6ffebcfbf549eb997895654_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aba84b2aab6ffebcfbf549eb997895654_cgraph" id="namespace_tiled_array_1_1detail_aba84b2aab6ffebcfbf549eb997895654_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_range.html#a491195742ae543d2e53d2234bbd0b631" title="Rank accessor. " alt="" coords="174,5,336,31"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1_range.html#afd7dd885ff139cc535b8f1e42a4442f3" title="Range extent data accessor. " alt="" coords="187,55,323,93"/>
</map>
</div>

</div>
</div>
<a id="a1bc0dbda95a57b85aaec2b5d49a15009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc0dbda95a57b85aaec2b5d49a15009">&#9670;&nbsp;</a></span>is_congruent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_block_range.html">BlockRange</a> &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> and <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> are congruent. </p>
<p>This function tests that the rank, extent of <code>r1</code> is equal to that of <code>r2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a></td><td>The range type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>The <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">Range</a> to compare </td></tr>
    <tr><td class="paramname">r2</td><td>The <a class="el" href="class_tiled_array_1_1_block_range.html" title="Range that references a subblock of another range. ">BlockRange</a> to compare </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00105">105</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a1bc0dbda95a57b85aaec2b5d49a15009_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a1bc0dbda95a57b85aaec2b5d49a15009_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a1bc0dbda95a57b85aaec2b5d49a15009_cgraph" id="namespace_tiled_array_1_1detail_a1bc0dbda95a57b85aaec2b5d49a15009_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a37574f8f8dd2104153b755e6e4427528" title="Test the two ranges are congruent. " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="a0b9a43dfee2749874d4677ea89ab4188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9a43dfee2749874d4677ea89ab4188">&#9670;&nbsp;</a></span>is_range_congruent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of tensors are congruent. </p>
<p>Test that the ranges of a pair of shifted tensors are congruent.</p>
<p>This function tests that the rank, lower bound, and upper bound of <code>tensor1</code> is equal to that of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>.</dd></dl>
<p>This function tests that the extents of the two tensors are equal. One or both of the tensors may be shifted. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00122">122</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph" id="namespace_tiled_array_1_1detail_a0b9a43dfee2749874d4677ea89ab4188_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a37574f8f8dd2104153b755e6e4427528" title="Test the two ranges are congruent. " alt="" coords="200,5,321,44"/>
</map>
</div>

</div>
</div>
<a id="aa49fdad6dffe4694cd2f6568461a409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49fdad6dffe4694cd2f6568461a409c">&#9670;&nbsp;</a></span>is_range_congruent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Left , typename Right &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const Left &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html">ShiftWrapper</a>&lt; Right &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check for congruent range objects with a shifted tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Left</td><td>The left-hand tensor type </td></tr>
    <tr><td class="paramname">Right</td><td>The right-hand tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand tensor </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lower and upper bounds of the left- and right-hand tensor ranges are equal, otherwise <code>false</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="shift__wrapper_8h_source.html#l00122">122</a> of file <a class="el" href="shift__wrapper_8h_source.html">shift_wrapper.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph" id="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator. " alt="" coords="200,5,348,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph" id="namespace_tiled_array_1_1detail_aa49fdad6dffe4694cd2f6568461a409c_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1detail_1_1transform.html#a1324736ab88c1fc8ec58d57b35b2b504" title="TiledArray::detail\l::transform::operator()" alt="" coords="210,5,361,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data. " alt="" coords="217,68,355,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a42a1f5fb2f3d857ee31e66ba3deabf20" title="Test that the ranges of a permuted set of tensors are congruent. " alt="" coords="200,131,372,169"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1detail.html#a227f69a3e3e5de0854bac8e8f2ec6cee" title="Get the inner size of two tensors. " alt="" coords="219,193,353,232"/>
</map>
</div>

</div>
</div>
<a id="aa35b616db0b6d4da11b862de9570fb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35b616db0b6d4da11b862de9570fb93">&#9670;&nbsp;</a></span>is_range_congruent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename std::enable_if&lt;!(is_shifted&lt; T1 &gt;::value||is_shifted&lt; T2 &gt;::value)&gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a pair of permuted tensors are congruent. </p>
<p>This function tests that the rank, lower bound, and upper bound of <code>tensor1</code> is equal to that of the permuted range of <code>tensor2</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rank and extents of the two tensors equal, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00140">140</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph" id="namespace_tiled_array_1_1detail_aa35b616db0b6d4da11b862de9570fb93_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a37574f8f8dd2104153b755e6e4427528" title="Test the two ranges are congruent. " alt="" coords="200,5,321,44"/>
</map>
</div>

</div>
</div>
<a id="a0d75a0a0d43e9a5d8beec072cdbe678c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d75a0a0d43e9a5d8beec072cdbe678c">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. ">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00179">179</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph" id="namespace_tiled_array_1_1detail_a0d75a0a0d43e9a5d8beec072cdbe678c_icgraph">
<area shape="rect" id="node2" href="struct_tiled_array_1_1detail_1_1transform.html#ae00da3d0d2f66eecc0bd866b737d1008" title="creates a result tensor in which element i is obtained by op(tensor[i], tensors[i]...) " alt="" coords="236,207,387,245"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#ac7c2574bd1506d0e811e2c0eb58fb1e3" title="In&#45;place tensor operations with contiguous data. " alt="" coords="242,269,380,308"/>
<area shape="rect" id="node19" href="namespace_tiled_array_1_1detail.html#a2fa32053a2cef8c73b71763a0e01cd95" title="Initialize tensor with contiguous tensor arguments. " alt="" coords="251,471,371,509"/>
<area shape="rect" id="node21" href="namespace_tiled_array_1_1detail.html#ab957a79bba9735ad3e405dbb8dd53796" title="Reduction operation for contiguous tensors. " alt="" coords="251,533,371,572"/>
<area shape="rect" id="node33" href="namespace_tiled_array_1_1detail.html#a42a1f5fb2f3d857ee31e66ba3deabf20" title="Test that the ranges of a permuted set of tensors are congruent. " alt="" coords="225,596,397,635"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a6f2e00b7e50f7ba5858e3fa472d3e917" title="Assignment operator. " alt="" coords="465,5,636,44"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_tensor.html#a864d3eed3caa265526a36b1e042aaeb9" title="TiledArray::Tensor\l\&lt; value_type \&gt;::operator=" alt="" coords="464,68,637,107"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tensor.html#a272585651b1233bb8f90d23c88a12c61" title="Use a binary, element wise operation to modify this tensor. " alt="" coords="471,131,630,183"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_tensor.html#af23df0d855cd33e6e977bd39e780ca9a" title="Use a unary, element wise operation to modify this tensor. " alt="" coords="451,207,650,245"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a83acf090e9a7de9165981577d80fe54d" title="TiledArray::detail\l::TensorInterface::operator=" alt="" coords="458,269,643,308"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a46a945ea3c88f00a52de46e667ce9ee0" title="Use a binary, element wise operation to modify this tensor. " alt="" coords="465,332,636,384"/>
<area shape="rect" id="node14" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a8647a75373e134bca3a70713c5498562" title="Use a unary, element wise operation to modify this tensor. " alt="" coords="445,408,656,447"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae2d0943dc0d6a8b208e0a48424401c6b" title="Add other to this tensor. " alt="" coords="727,213,895,252"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#aac121bc0cd56e31321951667ba39dc37" title="Subtract right from this tensor. " alt="" coords="725,276,897,315"/>
<area shape="rect" id="node13" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7669954a348702b2cf4f6f25b26f7369" title="Multiply this tensor by right. " alt="" coords="725,339,897,377"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a20530f66b536a7941cb23a55dd898d15" title="Subtract a constant from this tensor. " alt="" coords="966,213,1138,252"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a2cd0a563ba38d684f2fa124fcc182d75" title="Scale this tensor. " alt="" coords="722,401,900,440"/>
<area shape="rect" id="node17" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7137f78d0b44663c90b7d8170f0aba9f" title="Add a constant to this tensor. " alt="" coords="727,464,895,503"/>
<area shape="rect" id="node18" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ab908e6e24c3bfc6f16949cf913741d8e" title="Negate elements of this tensor. " alt="" coords="727,527,895,565"/>
<area shape="rect" id="node16" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ae72e40cb8cf82a93f9162297deb644e5" title="Complex conjugate this tensor. " alt="" coords="966,401,1137,440"/>
<area shape="rect" id="node20" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value. " alt="" coords="472,471,629,509"/>
<area shape="rect" id="node22" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794" title="Unary reduction operation. " alt="" coords="472,533,629,572"/>
<area shape="rect" id="node23" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0fc743f7d979b7282cfd211ade959643" title="Unary reduction operation. " alt="" coords="466,777,635,816"/>
<area shape="rect" id="node24" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a081774a07ad844f21135bc9cb248b41b" title="Sum of elements. " alt="" coords="734,589,888,628"/>
<area shape="rect" id="node25" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7798b8a0dd74454df7253bc8c9fc43dc" title="Product of elements. " alt="" coords="725,652,897,691"/>
<area shape="rect" id="node26" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf8ff6dede6f80fcef6c48eeffa30f5" title="Square of vector 2&#45;norm. " alt="" coords="704,715,918,753"/>
<area shape="rect" id="node28" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad4261a44ff666309159d6bbd4332c67a" title="Minimum element. " alt="" coords="736,777,886,816"/>
<area shape="rect" id="node29" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a323ce82713ac209600ae5a47e6f858ae" title="Maximum element. " alt="" coords="734,840,888,879"/>
<area shape="rect" id="node30" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a904224147ac9f4987473e6edc87d5607" title="Absolute minimum element. " alt="" coords="722,903,900,941"/>
<area shape="rect" id="node31" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad398d3bad05eb83e635b316984e31994" title="Absolute maximum element. " alt="" coords="720,965,902,1004"/>
<area shape="rect" id="node32" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a342be68250ef09785f8d08ed2c951e6e" title="Vector dot product. " alt="" coords="738,1028,884,1067"/>
<area shape="rect" id="node27" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a3da3d7e2c563c86416219238880bc3f7" title="Vector 2&#45;norm. " alt="" coords="973,715,1131,753"/>
</map>
</div>

</div>
</div>
<a id="a42a1f5fb2f3d857ee31e66ba3deabf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a1f5fb2f3d857ee31e66ba3deabf20">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a permuted set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation to be applied to <code>tensor2</code> and <code>tensors</code>... </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all permuted tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00195">195</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph" id="namespace_tiled_array_1_1detail_a42a1f5fb2f3d857ee31e66ba3deabf20_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor. " alt="" coords="238,5,384,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="225,68,397,107"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator. " alt="" coords="445,5,593,44"/>
</map>
</div>

</div>
</div>
<a id="a8d01c42f84f360ae79da4a0c8e5b84a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d01c42f84f360ae79da4a0c8e5b84a2">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a tensor is congruent with itself. </p>
<p>This function is used as the termination step for the recursive <code><a class="el" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. ">is_range_set_congruent()</a></code> function, and to handle the case of a single tensor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00212">212</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="af81ff970acbf1f37236b31c6d19f8e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81ff970acbf1f37236b31c6d19f8e27">&#9670;&nbsp;</a></span>is_range_set_congruent() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::is_range_set_congruent </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>tensor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the ranges of a set of tensors are congruent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The first tensor type </td></tr>
    <tr><td class="paramname">T2</td><td>The second tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensor1</td><td>The first tensor to be compared </td></tr>
    <tr><td class="paramname">tensor2</td><td>The second tensor to be compared </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining tensor to be compared in recursive steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tensors in the list are congruent with the first tensor in the set, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_2utility_8h_source.html#l00227">227</a> of file <a class="el" href="tensor_2utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph" id="namespace_tiled_array_1_1detail_af81ff970acbf1f37236b31c6d19f8e27_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#aa49fdad6dffe4694cd2f6568461a409c" title="Check for congruent range objects with a shifted tensor. " alt="" coords="238,5,384,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="225,68,397,107"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_shift_wrapper.html#a1d098067185016b50f5f7670e9a29bc4" title="Tensor type conversion operator. " alt="" coords="445,5,593,44"/>
</map>
</div>

</div>
</div>
<a id="ab46d9580d4d2230d0e34ee0ccfdafc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46d9580d4d2230d0e34ee0ccfdafc72">&#9670;&nbsp;</a></span>make_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool sparse&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::make_shape </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b2a3fd528183d1884b5f53d1d0d89fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2a3fd528183d1884b5f53d1d0d89fa">&#9670;&nbsp;</a></span>make_shape&lt; false &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">TiledArray::detail::make_shape</a>&lt; false &gt; </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00133">133</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>

</div>
</div>
<a id="a39f1aefd43dea7ce3158f142a57e5994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f1aefd43dea7ce3158f142a57e5994">&#9670;&nbsp;</a></span>make_shape&lt; true &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="namespace_tiled_array_1_1detail.html#ab46d9580d4d2230d0e34ee0ccfdafc72">TiledArray::detail::make_shape</a>&lt; true &gt; </td>
          <td>(</td>
          <td class="paramtype">World &amp;&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_tiled_range.html">TiledArray::TiledRange</a> &amp;&#160;</td>
          <td class="paramname"><em>trange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="conversions_2btas_8h_source.html#l00127">127</a> of file <a class="el" href="conversions_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph" id="namespace_tiled_array_1_1detail_a39f1aefd43dea7ce3158f142a57e5994_cgraph">
<area shape="rect" id="node2" href="kronecker__delta_8h.html#a08a5e38335a5bd02f089294968dfc391" title="max" alt="" coords="204,12,251,37"/>
</map>
</div>

</div>
</div>
<a id="a45190dfcad5ef2b9af5b4aa000c844b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45190dfcad5ef2b9af5b4aa000c844b0">&#9670;&nbsp;</a></span>make_ta_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a>&amp; TiledArray::detail::make_ta_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00043">43</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph" id="namespace_tiled_array_1_1detail_a45190dfcad5ef2b9af5b4aa000c844b0_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#aeefa8ea4cb95ebb8c9d9b3809f12dc4d" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="179,19,359,57"/>
<area shape="rect" id="node4" href="namespace_tiled_array.html#ae862097c5ca7e7a8affa6275af008f63" title="Copy a block of a btas::Tensor into a TiledArray::Tensor. " alt="" coords="199,84,338,123"/>
<area shape="rect" id="node6" href="struct_tiled_array_1_1_cast_3_01_tiled_array_1_1_tensor_3_01_t_00_01_allocator_01_4_00_01btas_1_4609707baf645f507ebd5df14a7b8d69.html#af778f0942560d12842d5d00ce970abc4" title="TiledArray::Cast\&lt; TiledArray\l::Tensor\&lt; T, Allocator \&gt;,\l btas::Tensor\&lt; T, Range_,\l Storage \&gt; \&gt;::operator()" alt="" coords="175,147,363,212"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a8aab6018796760c407b5cc53295568ed" title="Task function for converting btas::Tensor subblock to a TiledArray::DistArray. " alt="" coords="411,5,585,57"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1detail.html#aae305e910ce674d71f550e104c354cb5" title="Task function for assigning a tensor to an Eigen submatrix. " alt="" coords="428,81,568,133"/>
</map>
</div>

</div>
</div>
<a id="a763c40422c3621a425739070cf164db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c40422c3621a425739070cf164db1">&#9670;&nbsp;</a></span>make_ta_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;CBLAS_ORDER Order, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_range.html">TiledArray::Range</a> TiledArray::detail::make_ta_range </td>
          <td>(</td>
          <td class="paramtype">const btas::RangeNd&lt; Order, Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes <a class="el" href="class_tiled_array_1_1_range.html" title="A (hyperrectangular) interval on , space of integer n-indices. ">TiledArray::Range</a> from a btas::RangeNd </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">range</td><td>a btas::RangeNd object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_tiled_array_1_1_exception.html">TiledArray::Exception</a></td><td>if <code>range</code> is non-row-major </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="external_2btas_8h_source.html#l00052">52</a> of file <a class="el" href="external_2btas_8h_source.html">btas.h</a>.</p>

</div>
</div>
<a id="ada724a31400bb94f55097560394438de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada724a31400bb94f55097560394438de">&#9670;&nbsp;</a></span>make_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1_tile.html">Tile</a>&lt;T&gt; TiledArray::detail::make_tile </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for tiles. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A tensor object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tile that wraps a copy of t. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tile_8h_source.html#l00279">279</a> of file <a class="el" href="tile_8h_source.html">tile.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph" id="namespace_tiled_array_1_1detail_ada724a31400bb94f55097560394438de_icgraph">
<area shape="rect" id="node2" href="group___tile_interface.html#ga91b9ad4c6f5c4ce7928e61669c37844a" title="Shift the range of arg. " alt="" coords="181,232,294,257"/>
<area shape="rect" id="node3" href="group___tile_interface.html#ga4f9977ff8130c6b95fc646e6a968f7a6" title="Add tile arguments. " alt="" coords="182,281,293,307"/>
<area shape="rect" id="node10" href="group___tile_interface.html#ga58d10685bc8b980fed30a5e64db19caa" title="Subtract tile arguments. " alt="" coords="180,617,294,643"/>
<area shape="rect" id="node13" href="group___tile_interface.html#gaf465d9c7b7f7d31918a6150c9d51ca40" title="Multiplication tile arguments. " alt="" coords="180,667,294,692"/>
<area shape="rect" id="node16" href="group___tile_interface.html#gaebe37fcda193946fcc4501b42796e9cc" title="Scalar the tile argument. " alt="" coords="177,716,297,741"/>
<area shape="rect" id="node17" href="group___tile_interface.html#ga6bd5665b8e247cd53460501c3f672751" title="Negate the tile argument. " alt="" coords="182,765,293,791"/>
<area shape="rect" id="node20" href="group___tile_interface.html#ga4d7a9a1250ba51b27addd91171a1c77f" title="Create a complex conjugated copy of a tile. " alt="" coords="181,901,294,927"/>
<area shape="rect" id="node24" href="group___tile_interface.html#ga1f3a08fa940b7d1c314327430c604238" title="Contract and scale tile arguments. " alt="" coords="174,1215,300,1240"/>
<area shape="rect" id="node4" href="group___tile_interface.html#gac080bac89fc26e28adc8ce434f7098bd" title="Add and scale tile arguments. " alt="" coords="405,5,517,31"/>
<area shape="rect" id="node5" href="group___tile_interface.html#ga3dfbc65d2ed3c0ed3358380eba985255" title="Add tiles operator. " alt="" coords="388,55,534,80"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1tile__interface_1_1_add.html#abd9b9d12c93b9077f05d2f08f50338b5" title="TiledArray::tile_interface\l::Add\&lt; Result, Left, Right\l \&gt;::operator()" alt="" coords="376,104,546,156"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1tile__interface_1_1_add_3_01_result_00_01_left_00_01_right_00_01typename_0150e3899b283ab62cc85b36801b0d8fa4.html#ace7bf715e17d7b0ceddf1a82bf0287da" title="TiledArray::tile_interface\l::Add\&lt; Result, Left, Right,\l typename std::enable_if\&lt;\l !(std::is_same\&lt; Result, result\l_of_add_t\&lt; Left, Right \&gt; \&gt;::value\l &amp;&amp;std::is_same\&lt; Result, result_of\l_add_t\&lt; Left, Right, Permutation \&gt;\l \&gt;::value) \&gt;::type \&gt;::operator()" alt="" coords="348,180,574,299"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1tile__interface_1_1_scal_add.html#a80794fddc1ee2c30e54deb5f6ae1c761" title="TiledArray::tile_interface\l::ScalAdd\&lt; Result, Left,\l Right, Scalar \&gt;::operator()" alt="" coords="372,323,550,375"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1tile__interface_1_1_scal_add_3_01_result_00_01_left_00_01_right_00_01_scala78b20006f3597ac59e10fb238a5e1984.html#a1fcb96fcfc5b3d2aea119b6f02b9bd5c" title="TiledArray::tile_interface\l::ScalAdd\&lt; Result, Left,\l Right, Scalar, typename\l std::enable_if\&lt; !(std::is\l_same\&lt; Result, result_of_add\l_t\&lt; Left, Right, Scalar \&gt; \&gt;::\lvalue &amp;&amp;std::is_same\&lt; Result,\l result_of_add_t\&lt; Left, Right,\l Scalar, Permutation \&gt; \&gt;::value)\l \&gt;::type \&gt;::operator()" alt="" coords="357,399,565,544"/>
<area shape="rect" id="node11" href="group___tile_interface.html#gad477a9e151bd7d6bb29dacda947c83aa" title="Subtract and scale tile arguments. " alt="" coords="404,568,518,593"/>
<area shape="rect" id="node12" href="group___tile_interface.html#ga3d64e9ef0fbeb7c776f5ce6a2d74d3e9" title="Subtract tiles operator. " alt="" coords="389,617,533,643"/>
<area shape="rect" id="node14" href="group___tile_interface.html#ga27e2e80dcf97b3ad64e8797e2226a432" title="Multiplication and scale tile arguments. " alt="" coords="404,667,518,692"/>
<area shape="rect" id="node15" href="group___tile_interface.html#gacafac66355a32046043fc0d55da53486" title="Product tiles operator. " alt="" coords="389,716,533,741"/>
<area shape="rect" id="node18" href="group___tile_interface.html#ga58ae23d7dae957803f4d65404e15fc6a" title="Negate and permute tile argument. " alt="" coords="405,765,517,791"/>
<area shape="rect" id="node19" href="group___tile_interface.html#gaebf4c181f142aaa5adb2057bfb8b6027" title="Negate tile operator. " alt="" coords="389,815,533,840"/>
<area shape="rect" id="node21" href="group___tile_interface.html#gac18ac642dbdbed016061d5cc969ffa2a" title="Create a complex conjugated and scaled copy of a tile. " alt="" coords="404,864,518,889"/>
<area shape="rect" id="node22" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#a1d62bd1335311d0dbe8238448ec6d588" title="Post processing step. " alt="" coords="370,913,552,992"/>
<area shape="rect" id="node23" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a45a9acd171ceb8dc827b91bd9274eccd" title="Post processing step. " alt="" coords="370,1016,552,1095"/>
<area shape="rect" id="node25" href="group___tile_interface.html#ga5cd5e3e8121313e9684e91cfa6230fd6" title="Contract and scale tile arguments to the result tile. " alt="" coords="398,1119,524,1144"/>
<area shape="rect" id="node26" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a5b919cfba2055a419a657bdf07827d9e" title="Contract a pair of tiles and add to a target tile. " alt="" coords="358,1168,564,1287"/>
<area shape="rect" id="node27" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_a9a56f685ff213c256976617604736135.html#a8a5c94fe891f98a4a2954f264f4ed338" title="Contract a pair of tiles and add to a target tile. " alt="" coords="370,1311,552,1389"/>
<area shape="rect" id="node28" href="class_tiled_array_1_1detail_1_1_contract_reduce_3_01_result_00_01_left_00_01_right_00_01_tiled_ac747358d5737d2beb853a2e1d5509b1f.html#a4689b7f04da0ed1e64d6a7e0f23199e4" title="Contract a pair of tiles and add to a target tile. " alt="" coords="370,1413,552,1492"/>
</map>
</div>

</div>
</div>
<a id="a58f2092d8f52e938f74173f7ede0b07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f2092d8f52e938f74173f7ede0b07d">&#9670;&nbsp;</a></span>make_tran_it() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter1 , typename Iter2 , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_binary_transform_iterator.html">BinaryTransformIterator</a>&lt;Iter1, Iter2, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter1&#160;</td>
          <td class="paramname"><em>it1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter2&#160;</td>
          <td class="paramname"><em>it2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter1</td><td>First iterator type </td></tr>
    <tr><td class="paramname">Iter2</td><td>Second iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it1</td><td>First iterator </td></tr>
    <tr><td class="paramname">it2</td><td>Second iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A binary transform iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="transform__iterator_8h_source.html#l00424">424</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a id="ab52e422e441d6c6cd06db1812f784e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52e422e441d6c6cd06db1812f784e1c">&#9670;&nbsp;</a></span>make_tran_it() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_unary_transform_iterator.html">UnaryTransformIterator</a>&lt;Iter, Op&gt; TiledArray::detail::make_tran_it </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary Transform iterator factory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>The iterator type </td></tr>
    <tr><td class="paramname">Op</td><td>The binary transform type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator </td></tr>
    <tr><td class="paramname">op</td><td>The binary transform object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unary transform iterator </dd></dl>

<p class="definition">Definition at line <a class="el" href="transform__iterator_8h_source.html#l00436">436</a> of file <a class="el" href="transform__iterator_8h_source.html">transform_iterator.h</a>.</p>

</div>
</div>
<a id="af885da1706c23576a28eb38b7afab176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af885da1706c23576a28eb38b7afab176">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename std::enable_if&lt;! is_complex&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::norm </td>
          <td>(</td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function for <code>std::norm</code> </p>
<p>This function disables the call to <code>std::conj</code> for real values to prevent the result from being converted into a complex value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A real scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The real scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00089">89</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph" id="namespace_tiled_array_1_1detail_af885da1706c23576a28eb38b7afab176_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#a47757d8cd5015280a09ee20f453c86c2" title="Square of vector 2&#45;norm. " alt="" coords="180,5,382,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf8ff6dede6f80fcef6c48eeffa30f5" title="Square of vector 2&#45;norm. " alt="" coords="174,68,388,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a3da3d7e2c563c86416219238880bc3f7" title="Vector 2&#45;norm. " alt="" coords="436,68,595,107"/>
</map>
</div>

</div>
</div>
<a id="af182bb984874298c8351edad6f03517c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af182bb984874298c8351edad6f03517c">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE R TiledArray::detail::norm </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; R &gt;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the norm of a complex number <code>z</code> </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\rm norm}(z) = zz^* = {\rm Re}(z)^2 + {\rm Im}(z)^2 \]" src="form_87.png"/>
</p>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The complex scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The complex conjugate of <code>z</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00102">102</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>

</div>
</div>
<a id="ac0bec5b1d1332c33a47755a4f62eaf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bec5b1d1332c33a47755a4f62eaf71">&#9670;&nbsp;</a></span>operator &amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise and operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The a intersection of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00615">615</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a id="ae8b423b1a3fcf6701ac05c9ce692d208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b423b1a3fcf6701ac05c9ce692d208">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference. ">TileReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00129">129</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>

</div>
</div>
<a id="a3699581fa58aa15f3376c5e6f66f68b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3699581fa58aa15f3376c5e6f66f68b3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Compares the iterators for inequality. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value or container are not equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__iterator_8h_source.html#l00173">173</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>

</div>
</div>
<a id="a804792a4a8294fbb2ca9ea04cb8c1da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804792a4a8294fbb2ca9ea04cb8c1da8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inequality operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference. ">TileConstReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00195">195</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>

</div>
</div>
<a id="ad02d47cab0fc5866bf2eb5c13acf659b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02d47cab0fc5866bf2eb5c13acf659b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00194">194</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph" id="namespace_tiled_array_1_1detail_ad02d47cab0fc5866bf2eb5c13acf659b_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="189,5,309,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title="TiledArray::detail\l::ComplexConjugate::\lfactor" alt="" coords="174,68,324,120"/>
</map>
</div>

</div>
</div>
<a id="a8ee93af26740ea0ee7c7f67db9a46601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee93af26740ea0ee7c7f67db9a46601">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00199">199</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph" id="namespace_tiled_array_1_1detail_a8ee93af26740ea0ee7c7f67db9a46601_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="a6e797cf6d3cd288a14452f32071b7a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e797cf6d3cd288a14452f32071b7a93">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00204">204</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph" id="namespace_tiled_array_1_1detail_a6e797cf6d3cd288a14452f32071b7a93_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="a69f8563d428af127b0abe38a93863ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f8563d428af127b0abe38a93863ead">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; L &gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00210">210</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph" id="namespace_tiled_array_1_1detail_a69f8563d428af127b0abe38a93863ead_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="189,5,309,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title="TiledArray::detail\l::ComplexConjugate::\lfactor" alt="" coords="174,68,324,120"/>
</map>
</div>

</div>
</div>
<a id="a31df1c69fe31afa87b68fb74323ec6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31df1c69fe31afa87b68fb74323ec6a4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00215">215</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph" id="namespace_tiled_array_1_1detail_a31df1c69fe31afa87b68fb74323ec6a4_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="acc6a9baaee6dc713469802694a8f82d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6a9baaee6dc713469802694a8f82d6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE auto TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00220">220</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph" id="namespace_tiled_array_1_1detail_acc6a9baaee6dc713469802694a8f82d6_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="af085e2abd40acbf24fbc80033634097b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af085e2abd40acbf24fbc80033634097b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; TiledArray::detail::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="size__array_8h_source.html#l00437">437</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph" id="namespace_tiled_array_1_1detail_af085e2abd40acbf24fbc80033634097b_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_size_array.html#acca3c890ec0aeacf730d251a54105ac4" title="TiledArray::detail\l::SizeArray::size" alt="" coords="174,5,295,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b" title="Create a permuted copy of an array. " alt="" coords="174,68,295,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="343,68,464,107"/>
</map>
</div>

</div>
</div>
<a id="acea2c5a93d37330153912da87c7c3877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea2c5a93d37330153912da87c7c3877">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R , typename std::enable_if&lt;! std::is_void&lt; R &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; R &gt;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00227">227</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph" id="namespace_tiled_array_1_1detail_acea2c5a93d37330153912da87c7c3877_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="189,5,309,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html#a941fc6f3a110343828055a79096748ec" title="TiledArray::detail\l::ComplexConjugate::\lfactor" alt="" coords="174,68,324,120"/>
</map>
</div>

</div>
</div>
<a id="aa443b57aebf3d340cc65deeeb00c2073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa443b57aebf3d340cc65deeeb00c2073">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00234">234</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph" id="namespace_tiled_array_1_1detail_aa443b57aebf3d340cc65deeeb00c2073_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="ab4bd519fc858458a6bf061c1ef2ef5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bd519fc858458a6bf061c1ef2ef5b3">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TILEDARRAY_FORCE_INLINE L&amp; TiledArray::detail::operator*= </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_complex_conjugate.html">ComplexConjugate</a>&lt; <a class="el" href="struct_tiled_array_1_1detail_1_1_complex_neg_tag.html">ComplexNegTag</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="complex_8h_source.html#l00241">241</a> of file <a class="el" href="complex_8h_source.html">complex.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph" id="namespace_tiled_array_1_1detail_ab4bd519fc858458a6bf061c1ef2ef5b3_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a32a7abe197b45ae95a4132fc240ed383" title="Wrapper function for std::conj " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="a218cac85d033808e795a87a686ce4fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218cac85d033808e795a87a686ce4fb6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference. ">TileReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00136">136</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>

</div>
</div>
<a id="aaff7f022aafbfb5bac3eaf2afc31cae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff7f022aafbfb5bac3eaf2afc31cae6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>redirect operator to std::ostream for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference. ">TileConstReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00202">202</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>

</div>
</div>
<a id="a7179e9c73eed3c5738bf4d0c5ebd068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7179e9c73eed3c5738bf4d0c5ebd068d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_size_array.html">SizeArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="size__array_8h_source.html#l00444">444</a> of file <a class="el" href="size__array_8h_source.html">size_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph" id="namespace_tiled_array_1_1detail_a7179e9c73eed3c5738bf4d0c5ebd068d_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object. " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="aa26bd55f3154ac62a00c6ff633db1d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26bd55f3154ac62a00c6ff633db1d40">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_val_array.html">ValArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="val__array_8h_source.html#l00456">456</a> of file <a class="el" href="val__array_8h_source.html">val_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph" id="namespace_tiled_array_1_1detail_aa26bd55f3154ac62a00c6ff633db1d40_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object. " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="aaf888c0b992f597156737f71e2bc6d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf888c0b992f597156737f71e2bc6d32">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; TiledArray::detail::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>bitset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00646">646</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph" id="namespace_tiled_array_1_1detail_aaf888c0b992f597156737f71e2bc6d32_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_bitset.html#a88d8120017304c4545b6dd93254fcdf0" title="Data pointer accessor. " alt="" coords="174,5,295,44"/>
</map>
</div>

</div>
</div>
<a id="a2cdeb370801b331554b63c01f4ac402b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdeb370801b331554b63c01f4ac402b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html">TileReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_reference.html" title="Tensor tile reference. ">TileReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00122">122</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph" id="namespace_tiled_array_1_1detail_a2cdeb370801b331554b63c01f4ac402b_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_tile_reference.html#a5849258d39efbcd976336a8e4f43568c" title="TiledArray::detail\l::TileReference::get" alt="" coords="174,5,311,44"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_tile_reference.html#ac58f5674fda99ca7e17b5ec5485b5dbb" title="TiledArray::detail\l::TileReference::future" alt="" coords="359,5,512,44"/>
</map>
</div>

</div>
</div>
<a id="a48b1ec146fbd546954d72262124a5b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b1ec146fbd546954d72262124a5b74">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_range_iterator.html">RangeIterator</a>&lt; T, Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Compares the iterators for equality. They must reference the same range object to be considered equal. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the iterator </td></tr>
    <tr><td class="paramname">Container</td><td>The container that the iterator references </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_it</td><td>The left-hand iterator to be compared </td></tr>
    <tr><td class="paramname">right_it</td><td>The right-hand iterator to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value and container are equal for the <code>left_it</code> and <code>right_it</code> , otherwise <code>false</code> . </dd></dl>

<p class="definition">Definition at line <a class="el" href="range__iterator_8h_source.html#l00156">156</a> of file <a class="el" href="range__iterator_8h_source.html">range_iterator.h</a>.</p>

</div>
</div>
<a id="aa52461acf45d3505ede569ee1aaa395c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52461acf45d3505ede569ee1aaa395c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Impl &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool TiledArray::detail::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html">TileConstReference</a>&lt; Impl &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comparison operator for <a class="el" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html" title="Tensor tile reference. ">TileConstReference</a> objects </p>

<p class="definition">Definition at line <a class="el" href="array__impl_8h_source.html#l00188">188</a> of file <a class="el" href="array__impl_8h_source.html">array_impl.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph" id="namespace_tiled_array_1_1detail_aa52461acf45d3505ede569ee1aaa395c_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#a4a03aa8339e239d655767e750b7d295e" title="TiledArray::detail\l::TileConstReference::get" alt="" coords="174,12,346,51"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_tile_const_reference.html#a3555a80759ee33348071903b0873e646" title="TiledArray::detail\l::TileConstReference\l::future" alt="" coords="394,5,540,57"/>
</map>
</div>

</div>
</div>
<a id="a9c12507ffe191d9e79b32f6687ec46b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c12507ffe191d9e79b32f6687ec46b1">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator^ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise xor operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00640">640</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a id="a0d0266e20b12eefced1cde7a01d4cdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0266e20b12eefced1cde7a01d4cdcd">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Block &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt;Block&gt; TiledArray::detail::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; Block &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise or operator of bitset. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Block</td><td>The bitset block type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left-hand bitset </td></tr>
    <tr><td class="paramname">right</td><td>The right-hand bitset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The union of the <code>left</code> and <code>right</code> bitsets </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00627">627</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>

</div>
</div>
<a id="ae1a6955d66acd00dd89cd34669e7fe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a6955d66acd00dd89cd34669e7fe09">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputOp , typename OutputOp , typename Result , typename Arg0 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute </td>
          <td>(</td>
          <td class="paramtype">InputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>input_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>output_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a permuted tensor copy. </p>
<p>The expected signature of the input operations is: </p><div class="fragment"><div class="line">Result::value_type input_op(<span class="keyword">const</span> Arg0::value_type, <span class="keyword">const</span> Args::value_type...)</div></div><!-- fragment --><p> The expected signature of the output operations is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> output_op(Result::value_type*, <span class="keyword">const</span> Result::value_type)</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputOp</td><td>The input operation type </td></tr>
    <tr><td class="paramname">OutputOp</td><td>The output operation type </td></tr>
    <tr><td class="paramname">Result</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Arg0</td><td>The first tensor argument type </td></tr>
    <tr><td class="paramname">Args</td><td>The remaining tensor argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_op</td><td>The operation that is used to generate the output value from the input arguments </td></tr>
    <tr><td class="paramname">output_op</td><td>The operation that is used to set the value of the result tensor given the element pointer and the result value </td></tr>
    <tr><td class="paramname">args</td><td>The data pointers of the tensors to be permuted </td></tr>
    <tr><td class="paramname">perm</td><td>The permutation that will be applied to the copy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_2permute_8h_source.html#l00122">122</a> of file <a class="el" href="tensor_2permute_8h_source.html">permute.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_cgraph" id="namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title="TiledArray::math::vector\l_ptr_op" alt="" coords="185,19,348,57"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1detail.html#aa3f00e852b717ed4084f8fd331d4e6c2" title="Compute the fused dimensions for permutation. " alt="" coords="202,105,331,144"/>
<area shape="rect" id="node10" href="namespace_tiled_array_1_1math.html#a0734d99af5ce0b09816a2934366c9071" title="Matrix transpose and initialization. " alt="" coords="174,171,359,196"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title="TiledArray::math::vector\l_ptr_op_serial" alt="" coords="421,5,583,44"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title="TiledArray::math::for\l_each_block_ptr" alt="" coords="890,89,1031,128"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title="TiledArray::math::for\l_each_block_ptr_n" alt="" coords="668,59,810,97"/>
<area shape="rect" id="node5" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#affa1c31a72285787675d68a07476d942" title="TiledArray::math::Vector\lOpUnwind::for_each_ptr" alt="" coords="1088,89,1254,128"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="407,68,597,93"/>
<area shape="rect" id="node9" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="441,117,562,156"/>
<area shape="rect" id="node11" href="namespace_tiled_array_1_1math.html#abb08079140fa4ea486e8d6e77baf7158" title="TiledArray::math::transpose\l_block" alt="" coords="409,180,594,219"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#a4f8998233c204a3e00403d3533a96137" title="TiledArray::math::Transpose\lUnwind::gather_trans" alt="" coords="645,184,833,223"/>
<area shape="rect" id="node19" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#af2a30045172f690528b7854f863f3c23" title="TiledArray::math::Transpose\lUnwind::block_scatter" alt="" coords="645,121,833,160"/>
<area shape="rect" id="node13" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title="TiledArray::math::for\l_each_block" alt="" coords="890,152,1031,191"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1math_1_1_block.html#a5b8fd799fcafd39809f7f7a5dcc2493f" title="TiledArray::math::Block\l::scatter_to" alt="" coords="881,215,1040,253"/>
<area shape="rect" id="node14" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a7588c344a42c08298668d265cf82b607" title="TiledArray::math::Vector\lOpUnwind::for_each" alt="" coords="1089,152,1253,191"/>
<area shape="rect" id="node16" href="namespace_tiled_array_1_1math.html#a6137a96c445b26d23187018efa876aa5" title="TiledArray::math::scatter\l_block" alt="" coords="1088,215,1254,253"/>
<area shape="rect" id="node18" href="class_tiled_array_1_1math_1_1_block.html#a8541624decd7fa535c52f85c9499a0e1" title="TiledArray::math::Block\l::data" alt="" coords="1092,277,1250,316"/>
<area shape="rect" id="node17" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#ad76cb4c4568102c1faaefb5fab603a3c" title="TiledArray::math::Vector\lOpUnwind::scatter" alt="" coords="1302,215,1466,253"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_icgraph" id="namespace_tiled_array_1_1detail_ae1a6955d66acd00dd89cd34669e7fe09_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data. " alt="" coords="208,5,346,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20" title="Initialize tensor with permuted tensor arguments. " alt="" coords="217,68,337,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step. " alt="" coords="174,131,380,249"/>
</map>
</div>

</div>
</div>
<a id="a9ecba5efe7b319458a9f16df0563472b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecba5efe7b319458a9f16df0563472b">&#9670;&nbsp;</a></span>permute_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Perm , typename Arg , typename Result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::permute_array </td>
          <td>(</td>
          <td class="paramtype">const Perm &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a permuted copy of an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Perm</td><td>The permutation type </td></tr>
    <tr><td class="paramname">Arg</td><td>The input array type </td></tr>
    <tr><td class="paramname">Result</td><td>The output array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The input array to be permuted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The output array that will hold the permuted array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="permutation_8h_source.html#l00057">57</a> of file <a class="el" href="permutation_8h_source.html">permutation.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_cgraph" id="namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="174,5,295,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_icgraph" id="namespace_tiled_array_1_1detail_a9ecba5efe7b319458a9f16df0563472b_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a586be997af3bd421583c8fd36c4e95f2" title="Permute a std::array. " alt="" coords="178,5,322,31"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#ae84ce21d711a462da4a1b44a811a5a94" title="In&#45;place permute a std::array. " alt="" coords="174,55,326,80"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#af085e2abd40acbf24fbc80033634097b" title="TiledArray::detail\l::operator*" alt="" coords="190,104,310,143"/>
</map>
</div>

</div>
</div>
<a id="a5cd635d089830705f84e08204967760d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd635d089830705f84e08204967760d">&#9670;&nbsp;</a></span>print_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00153">153</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph" id="namespace_tiled_array_1_1detail_a5cd635d089830705f84e08204967760d_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1expressions_1_1_blk_tsr_engine_base.html#a800a904556b489c3d7490375bbaf38b4" title="Expression identification tag. " alt="" coords="174,5,385,71"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#a00568c34aef7e5f9b2802cbdd4382ea5" title="Range output operator. " alt="" coords="202,95,357,120"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a7179e9c73eed3c5738bf4d0c5ebd068d" title="TiledArray::detail\l::operator\&lt;\&lt;" alt="" coords="219,144,340,183"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce" title="Print the content of an array like object. " alt="" coords="219,207,340,245"/>
<area shape="rect" id="node6" href="utility_8h.html#a833006a9a700e7ab8713ebf56771de82" title="Vector output stream operator. " alt="" coords="224,269,335,295"/>
</map>
</div>

</div>
</div>
<a id="a2c0a678c425372465314f925b87612ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0a678c425372465314f925b87612ce">&#9670;&nbsp;</a></span>print_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::print_array </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the content of an array like object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The array container type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>A standard output stream </td></tr>
    <tr><td class="paramname">a</td><td>The array-like container to be printed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00169">169</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph" id="namespace_tiled_array_1_1detail_a2c0a678c425372465314f925b87612ce_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a5cd635d089830705f84e08204967760d" title="Print the content of an array like object. " alt="" coords="174,5,295,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="174,68,295,107"/>
</map>
</div>

</div>
</div>
<a id="a5d281f943194c67e7b0a491f03d49e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d281f943194c67e7b0a491f03d49e02">&#9670;&nbsp;</a></span>size() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname">[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of c-stype array </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00047">47</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a5d281f943194c67e7b0a491f03d49e02_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a5d281f943194c67e7b0a491f03d49e02_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a5d281f943194c67e7b0a491f03d49e02_icgraph" id="namespace_tiled_array_1_1detail_a5d281f943194c67e7b0a491f03d49e02_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1expressions_1_1_blk_tsr_expr_base.html#a4233158dc2d8f961fbe420397cdc715c" title="TiledArray::expressions\l::BlkTsrExprBase\&lt; ScalBlkTsr\lExpr\&lt; Array, Scalar \&gt; \&gt;::check_valid" alt="" coords="174,5,410,57"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_perm_index.html#ab54930056c8997aa0c41fbb37fc4175e" title="Construct permuting functor. " alt="" coords="209,81,375,120"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a9ecba5efe7b319458a9f16df0563472b" title="Create a permuted copy of an array. " alt="" coords="232,144,352,183"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_range.html#a32702ed414515a5784dbd6c3f775f443" title="Construct range defined by upper and lower bound sequences. " alt="" coords="224,231,360,269"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_range.html#a5a4793ce1597fbfd2bd9d7330d1e035d" title="Check the coordinate to make sure it is within the range. " alt="" coords="224,293,360,332"/>
<area shape="rect" id="node18" href="class_tiled_array_1_1_range.html#ac0a937ca9bed0960b6fef005f787fcca" title="Resize range to a new upper and lower bound. " alt="" coords="224,356,360,395"/>
<area shape="rect" id="node19" href="class_tiled_array_1_1_range.html#a8e43ff7ba296a6c6fb589d2af5221b3c" title="Shift the lower and upper bound of this range. " alt="" coords="224,419,360,457"/>
<area shape="rect" id="node21" href="class_tiled_array_1_1_range.html#a5ff9afe0f1eaa7e83de7790436fd1c01" title="calculate the ordinal index of index " alt="" coords="224,481,360,520"/>
<area shape="rect" id="node22" href="namespace_tiled_array_1_1detail.html#aa3f00e852b717ed4084f8fd331d4e6c2" title="Compute the fused dimensions for permutation. " alt="" coords="228,544,356,583"/>
<area shape="rect" id="node27" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size. " alt="" coords="225,607,359,645"/>
<area shape="rect" id="node30" href="namespace_tiled_array_1_1detail.html#a2c0a678c425372465314f925b87612ce" title="Print the content of an array like object. " alt="" coords="232,669,352,708"/>
<area shape="rect" id="node5" href="namespace_tiled_array.html#a586be997af3bd421583c8fd36c4e95f2" title="Permute a std::array. " alt="" coords="466,20,610,45"/>
<area shape="rect" id="node6" href="namespace_tiled_array.html#ae84ce21d711a462da4a1b44a811a5a94" title="In&#45;place permute a std::array. " alt="" coords="462,69,614,95"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1detail.html#af085e2abd40acbf24fbc80033634097b" title="TiledArray::detail\l::operator*" alt="" coords="478,119,599,157"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1_block_range.html#a05bebb6ba9b6cfbbc3c1215b45d6a102" title="calculate the coordinate index of the ordinal index, index. " alt="" coords="458,181,619,220"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1_range.html#af240bc957eebee5bbda425e7968e720b" title="TiledArray::Range::\lincludes" alt="" coords="470,244,606,283"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1_range.html#ab9c09b84ef48f256ae09c542a4f9e1e3" title="calculate the ordinal index of i " alt="" coords="470,307,606,345"/>
<area shape="rect" id="node16" href="class_tiled_array_1_1_range.html#ae5e7eefde499cee60bc2bd63c47f63bb" title="calculate the coordinate index of the ordinal index, index. " alt="" coords="462,369,615,395"/>
<area shape="rect" id="node17" href="class_tiled_array_1_1_tiled_range.html#aea9985043bdcb81536ee8b4d00fd6bb3" title="Construct a range for the tile indexed by the given index. " alt="" coords="460,419,617,457"/>
<area shape="rect" id="node13" href="class_tiled_array_1_1_block_range.html#a8215e3f01c9dd1d5942b34aced36207c" title="calculate the ordinal index of i " alt="" coords="689,263,850,301"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1_range.html#a82dccff0336cf7facf11d434f7b165bf" title="calculate the ordinal index of index " alt="" coords="702,325,837,364"/>
<area shape="rect" id="node14" href="class_tiled_array_1_1detail_1_1_array_eval_impl.html#a91bbe0e35b96349f94b938376c882135" title="Get tile at index i. " alt="" coords="920,263,1082,301"/>
<area shape="rect" id="node20" href="class_tiled_array_1_1_range.html#af3d2ada3894c8cd4661734a8d3e6b6be" title="Shift the lower and upper bound of this range. " alt="" coords="470,481,606,520"/>
<area shape="rect" id="node23" href="namespace_tiled_array_1_1detail.html#ae1a6955d66acd00dd89cd34669e7fe09" title="Construct a permuted tensor copy. " alt="" coords="478,544,599,583"/>
<area shape="rect" id="node24" href="namespace_tiled_array_1_1detail.html#af174120ffd75a14d13077eff16452d9b" title="In&#45;place tensor permutation operations with contiguous data. " alt="" coords="701,405,838,444"/>
<area shape="rect" id="node25" href="namespace_tiled_array_1_1detail.html#a2788b8e3e27331097aa656a0e6e36b20" title="Initialize tensor with permuted tensor arguments. " alt="" coords="709,468,830,507"/>
<area shape="rect" id="node26" href="class_tiled_array_1_1detail_1_1_contract_reduce.html#a3edb113a3e4524ffa21985587b0b7311" title="Post processing step. " alt="" coords="667,531,872,649"/>
<area shape="rect" id="node28" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a" title="Get the inner size of two tensors. " alt="" coords="478,640,599,679"/>
<area shape="rect" id="node29" href="namespace_tiled_array_1_1detail.html#ac5132fe4d73d49d24d2dcd60f06849f9" title="Initialize tensor with one or more non&#45;contiguous tensor arguments. " alt="" coords="709,673,830,712"/>
</map>
</div>

</div>
</div>
<a id="ae3432456d26bf2a1704062cb243f71b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3432456d26bf2a1704062cb243f71b5">&#9670;&nbsp;</a></span>size() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of c-stype array </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00055">55</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="a1f3063dba937c6812cf1b4c68bc38018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3063dba937c6812cf1b4c68bc38018">&#9670;&nbsp;</a></span>size() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;! std::is_array&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An array object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of array <code>a</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00064">64</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="a651b76b9b60aafe404bbb49ff767a002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651b76b9b60aafe404bbb49ff767a002">&#9670;&nbsp;</a></span>size() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The initializer list element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An initializer_list object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of initializer_list <code>a</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00072">72</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="a4feb853354fa321476311df881c874b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4feb853354fa321476311df881c874b8">&#9670;&nbsp;</a></span>size() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto TiledArray::detail::size </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tuple size accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>The tuple element types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A tuple object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of tuple <code>a</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utility_8h_source.html#l00080">80</a> of file <a class="el" href="utility_8h_source.html">utility.h</a>.</p>

</div>
</div>
<a id="a1d6fcb450ef829c3ad4e8e1db5be514a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6fcb450ef829c3ad4e8e1db5be514a">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_tiled_array_1_1detail_1_1_bitset.html">Bitset</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bitset_8h_source.html#l00593">593</a> of file <a class="el" href="bitset_8h_source.html">bitset.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph" id="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_bitset.html#a2209fb744965af00ca19f67a95dd5ea5" title="TiledArray::detail\l::Bitset::swap" alt="" coords="174,5,295,44"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph" id="namespace_tiled_array_1_1detail_a1d6fcb450ef829c3ad4e8e1db5be514a_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1detail_1_1_bitset.html#a2209fb744965af00ca19f67a95dd5ea5" title="TiledArray::detail\l::Bitset::swap" alt="" coords="194,5,315,44"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_block_range.html#aa8e883ff57e15866ee27e8e07dc60b90" title="TiledArray::BlockRange\l::swap" alt="" coords="174,68,335,107"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_dist_array.html#a3c483d946734a44bcac9febd0cd2a48d" title="Swap this array with other. " alt="" coords="183,131,327,169"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_tensor.html#ab7f33f8afac53cb621c12cac5e1d256a" title="Swap tensor data. " alt="" coords="181,193,328,232"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a69707db3c305f30eb32199b3b8572880" title="Swap tensor views. " alt="" coords="175,256,334,295"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1detail_1_1_val_array.html#afdff76007156bea6e89eadd6468f5a7c" title="TiledArray::detail\l::ValArray::swap" alt="" coords="194,319,315,357"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_bitset.html#a74e819d5ddaaf4e60dd9b106181d1d60" title="Assignment operator. " alt="" coords="383,5,510,44"/>
</map>
</div>

</div>
</div>
<a id="a2fa32053a2cef8c73b71763a0e01cd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa32053a2cef8c73b71763a0e01cd95">&#9670;&nbsp;</a></span>tensor_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with contiguous tensor arguments. </p>
<p>Initialize tensor of tensors with contiguous tensor arguments.</p>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op</code>(tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00366">366</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph" id="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. " alt="" coords="200,5,321,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="174,68,346,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title="TiledArray::math::vector\l_ptr_op" alt="" coords="179,131,341,169"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title="TiledArray::math::vector\l_ptr_op_serial" alt="" coords="394,131,556,169"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title="TiledArray::math::for\l_each_block_ptr" alt="" coords="604,99,746,137"/>
<area shape="rect" id="node8" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title="TiledArray::math::for\l_each_block_ptr_n" alt="" coords="604,161,746,200"/>
<area shape="rect" id="node7" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#affa1c31a72285787675d68a07476d942" title="TiledArray::math::Vector\lOpUnwind::for_each_ptr" alt="" coords="794,99,960,137"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph" id="namespace_tiled_array_1_1detail_a2fa32053a2cef8c73b71763a0e01cd95_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ad06d56e445f36d572109abbafc1a32e5" title="Construct a tensor with a fill value. " alt="" coords="174,5,330,44"/>
</map>
</div>

</div>
</div>
<a id="a2788b8e3e27331097aa656a0e6e36b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2788b8e3e27331097aa656a0e6e36b20">&#9670;&nbsp;</a></span>tensor_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with permuted tensor arguments. </p>
<p>Initialize tensor of tensors with permuted tensor arguments.</p>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op</code>(tensor1[i], tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>result</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">TR</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation that will be applied to tensor2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00423">423</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph" id="namespace_tiled_array_1_1detail_a2788b8e3e27331097aa656a0e6e36b20_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. " alt="" coords="200,5,321,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="174,68,346,107"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_permutation.html#adcbda98293f80a06b9fe773ac9d33c7e" title="Domain size accessor. " alt="" coords="627,132,816,157"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1detail.html#ae1a6955d66acd00dd89cd34669e7fe09" title="Construct a permuted tensor copy. " alt="" coords="200,213,321,252"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title="TiledArray::math::vector\l_ptr_op" alt="" coords="405,245,568,284"/>
<area shape="rect" id="node11" href="namespace_tiled_array_1_1detail.html#aa3f00e852b717ed4084f8fd331d4e6c2" title="Compute the fused dimensions for permutation. " alt="" coords="422,183,551,221"/>
<area shape="rect" id="node13" href="namespace_tiled_array_1_1math.html#a0734d99af5ce0b09816a2934366c9071" title="Matrix transpose and initialization. " alt="" coords="394,311,579,336"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title="TiledArray::math::vector\l_ptr_op_serial" alt="" coords="640,245,803,284"/>
<area shape="rect" id="node8" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title="TiledArray::math::for\l_each_block_ptr" alt="" coords="1110,276,1251,315"/>
<area shape="rect" id="node10" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title="TiledArray::math::for\l_each_block_ptr_n" alt="" coords="888,245,1030,284"/>
<area shape="rect" id="node9" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#affa1c31a72285787675d68a07476d942" title="TiledArray::math::Vector\lOpUnwind::for_each_ptr" alt="" coords="1308,276,1474,315"/>
<area shape="rect" id="node12" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="661,183,782,221"/>
<area shape="rect" id="node14" href="namespace_tiled_array_1_1math.html#abb08079140fa4ea486e8d6e77baf7158" title="TiledArray::math::transpose\l_block" alt="" coords="629,308,814,347"/>
<area shape="rect" id="node15" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#a4f8998233c204a3e00403d3533a96137" title="TiledArray::math::Transpose\lUnwind::gather_trans" alt="" coords="864,371,1053,409"/>
<area shape="rect" id="node22" href="class_tiled_array_1_1math_1_1_transpose_unwind.html#af2a30045172f690528b7854f863f3c23" title="TiledArray::math::Transpose\lUnwind::block_scatter" alt="" coords="864,308,1053,347"/>
<area shape="rect" id="node16" href="namespace_tiled_array_1_1math.html#a9a5d7ed52ec58b94cc8c9532624a45ad" title="TiledArray::math::for\l_each_block" alt="" coords="1110,339,1251,377"/>
<area shape="rect" id="node18" href="class_tiled_array_1_1math_1_1_block.html#a5b8fd799fcafd39809f7f7a5dcc2493f" title="TiledArray::math::Block\l::scatter_to" alt="" coords="1101,401,1260,440"/>
<area shape="rect" id="node17" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a7588c344a42c08298668d265cf82b607" title="TiledArray::math::Vector\lOpUnwind::for_each" alt="" coords="1309,339,1473,377"/>
<area shape="rect" id="node19" href="namespace_tiled_array_1_1math.html#a6137a96c445b26d23187018efa876aa5" title="TiledArray::math::scatter\l_block" alt="" coords="1308,401,1474,440"/>
<area shape="rect" id="node21" href="class_tiled_array_1_1math_1_1_block.html#a8541624decd7fa535c52f85c9499a0e1" title="TiledArray::math::Block\l::data" alt="" coords="1311,464,1470,503"/>
<area shape="rect" id="node20" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#ad76cb4c4568102c1faaefb5fab603a3c" title="TiledArray::math::Vector\lOpUnwind::scatter" alt="" coords="1522,401,1686,440"/>
</map>
</div>

</div>
</div>
<a id="ac5132fe4d73d49d24d2dcd60f06849f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5132fe4d73d49d24d2dcd60f06849f9">&#9670;&nbsp;</a></span>tensor_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op , typename TR , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; TR &gt;::value &amp;&amp;! is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::tensor_init </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TR &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize tensor with one or more non-contiguous tensor arguments. </p>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op</code>(tensor1[i], tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes the <code>i</code> -th element of <code>result</code> with the result of <code>op</code>(tensor1[i],tensors[i]...) </p><dl class="section pre"><dt>Precondition</dt><dd>The memory of <code>tensor1</code> has been allocated but not initialized. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The element initialization operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The result tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00492">492</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph" id="namespace_tiled_array_1_1detail_ac5132fe4d73d49d24d2dcd60f06849f9_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. " alt="" coords="200,5,321,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="174,68,346,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1detail.html#a91ec4c7e7bd4d19b11f0674903ce630a" title="Get the inner size of two tensors. " alt="" coords="200,131,321,169"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1math.html#a27697ba2d56b48030427ed8996104fda" title="TiledArray::math::vector\l_ptr_op" alt="" coords="179,193,341,232"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1detail.html#a85557b284f443993530894acbb158b58" title="Get the inner size. " alt="" coords="408,131,542,169"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1detail.html#a5d281f943194c67e7b0a491f03d49e02" title="Array size accessor. " alt="" coords="615,131,736,169"/>
<area shape="rect" id="node8" href="namespace_tiled_array_1_1math.html#a814ebc5ab1105e95a4f1047cad8e598a" title="TiledArray::math::vector\l_ptr_op_serial" alt="" coords="394,193,556,232"/>
<area shape="rect" id="node9" href="namespace_tiled_array_1_1math.html#a91290718834db1912be15860e26759ba" title="TiledArray::math::for\l_each_block_ptr" alt="" coords="604,193,746,232"/>
<area shape="rect" id="node11" href="namespace_tiled_array_1_1math.html#a91a501b77b43ce96e37799f22096012b" title="TiledArray::math::for\l_each_block_ptr_n" alt="" coords="604,256,746,295"/>
<area shape="rect" id="node10" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#affa1c31a72285787675d68a07476d942" title="TiledArray::math::Vector\lOpUnwind::for_each_ptr" alt="" coords="794,193,960,232"/>
</map>
</div>

</div>
</div>
<a id="ab9d3ac1bd3e7b1b004f489db1b4ce8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d3ac1bd3e7b1b004f489db1b4ce8be">&#9670;&nbsp;</a></span>tensor_op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt; is_tensor&lt; TR, T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> operations with contiguous data. </p>
<p>This function sets the elements of the result tensor with <code>op</code>(tensor1[i], tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>The element-wise operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The remaining argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The result tensor element initialization operation </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00060">60</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a id="a82f0f7c8a549579e118a89827e98726b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f0f7c8a549579e118a89827e98726b">&#9670;&nbsp;</a></span>tensor_op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TR , typename Op , typename T1 , typename... Ts, typename std::enable_if&lt;(is_tensor&lt; T1, Ts... &gt;::value||is_tensor_of_tensor&lt; TR, T1, Ts... &gt;::value) &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TR TiledArray::detail::tensor_op </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_tiled_array_1_1_permutation.html">Permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_tiled_array_1_1_tensor.html" title="An N-dimensional tensor object. ">Tensor</a> permutation operations with contiguous data. </p>
<p>This function sets the elements of the result tensor with <code>op</code>(tensor1[i],tensors[i]...) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>The tensor result type </td></tr>
    <tr><td class="paramname">Op</td><td>The element-wise operation type </td></tr>
    <tr><td class="paramname">T1</td><td>The result tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>The operation that is used to compute the result value from the input arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The permutation applied to the argument tensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor1</td><td>The first argument tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensors</td><td>The remaining argument tensors </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00082">82</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>

</div>
</div>
<a id="ab957a79bba9735ad3e405dbb8dd53796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab957a79bba9735ad3e405dbb8dd53796">&#9670;&nbsp;</a></span>tensor_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReduceOp , typename JoinOp , typename Scalar , typename T1 , typename... Ts, typename std::enable_if_t&lt; is_tensor&lt; T1, Ts... &gt;::value &amp;&amp;is_contiguous_tensor&lt; T1, Ts... &gt;::value &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar TiledArray::detail::tensor_reduce </td>
          <td>(</td>
          <td class="paramtype">ReduceOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>reduce_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JoinOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>join_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>tensor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduction operation for contiguous tensors. </p>
<p>Reduction operation for non-contiguous tensors of tensors.</p>
<p>Reduction operation for non-contiguous tensors.</p>
<p>Reduction operation for contiguous tensors of tensors.</p>
<p>Perform an element-wise reduction of the tensors by executing <code>join_op(result, reduce_op(result, &amp;tensor1[i], &amp;tensors[i]...))</code> for each <code>i</code> in the index range of <code>tensor1</code> . <code>result</code> is initialized to <code>identity</code> . If HAVE_INTEL_TBB is defined, the reduction will be executed in an undefined order, otherwise will execute in the order of increasing <code>i</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s)</dd></dl>
<p>Perform an element-wise reduction of the tensors by executing <code>join_op(result, reduce_op(tensor1[i], tensors[i]...))</code> for each <code>i</code> in the index range of <code>tensor1</code> . <code>result</code> is initialized to <code>identity</code> . This will execute serially, in the order of increasing <code>i</code> (each element-wise reduction can however be executed in parallel, depending on the element type). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReduceOp</td><td>The element-wise reduction operation type </td></tr>
    <tr><td class="paramname">JoinOp</td><td>The result operation type </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type </td></tr>
    <tr><td class="paramname">T1</td><td>The first argument tensor type </td></tr>
    <tr><td class="paramname">Ts</td><td>The argument tensor types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce_op</td><td>The element-wise reduction operation </td></tr>
    <tr><td class="paramname">join_op</td><td>The result join operation </td></tr>
    <tr><td class="paramname">identity</td><td>The initial value for the reduction and the result </td></tr>
    <tr><td class="paramname">tensor1</td><td>The first tensor to be reduced </td></tr>
    <tr><td class="paramname">tensors</td><td>The other tensors to be reduced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reduced value of the tensor(s) </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernels_8h_source.html#l00579">579</a> of file <a class="el" href="kernels_8h_source.html">kernels.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph" id="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_cgraph">
<area shape="rect" id="node2" href="namespace_tiled_array_1_1detail.html#a2b25c9db0387e3327718de2cbc9112c6" title="Test for empty tensors in an empty list. " alt="" coords="208,5,329,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#a0d75a0a0d43e9a5d8beec072cdbe678c" title="Test that the ranges of a permuted tensor is congruent with itself. " alt="" coords="183,68,355,107"/>
<area shape="rect" id="node4" href="namespace_tiled_array_1_1math.html#a31eade2ac2d813846fc814cdc9238a10" title="TiledArray::math::reduce_op" alt="" coords="174,183,363,208"/>
<area shape="rect" id="node5" href="namespace_tiled_array_1_1symmetry.html#ab88cc83a558d388cedeec00d2457827d" title="identity for group of objects of type T " alt="" coords="421,125,568,164"/>
<area shape="rect" id="node6" href="namespace_tiled_array_1_1math.html#ad9f624a1f3753b2b2f03c88c80eec453" title="TiledArray::math::reduce\l_op_serial" alt="" coords="411,188,578,227"/>
<area shape="rect" id="node7" href="namespace_tiled_array_1_1math.html#aadfeae00d061d08d80824c75f5c1855c" title="TiledArray::math::reduce\l_block" alt="" coords="626,156,793,195"/>
<area shape="rect" id="node9" href="namespace_tiled_array_1_1math.html#ad4c48eda75480eb3d3d267635eed78bb" title="TiledArray::math::reduce\l_block_n" alt="" coords="626,219,793,257"/>
<area shape="rect" id="node8" href="struct_tiled_array_1_1math_1_1_vector_op_unwind.html#a7dbbd437980c5ccbd2680aedf70f1357" title="TiledArray::math::Vector\lOpUnwind::reduce" alt="" coords="841,156,1005,195"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph" id="namespace_tiled_array_1_1detail_ab957a79bba9735ad3e405dbb8dd53796_icgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_tensor.html#ac7e2825494e7578e27becf11d2a6b794" title="Unary reduction operation. " alt="" coords="180,163,337,201"/>
<area shape="rect" id="node3" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a0fc743f7d979b7282cfd211ade959643" title="Unary reduction operation. " alt="" coords="174,225,343,264"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a081774a07ad844f21135bc9cb248b41b" title="Sum of elements. " alt="" coords="421,5,575,44"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a7798b8a0dd74454df7253bc8c9fc43dc" title="Product of elements. " alt="" coords="412,68,584,107"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#afdf8ff6dede6f80fcef6c48eeffa30f5" title="Square of vector 2&#45;norm. " alt="" coords="391,131,605,169"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad4261a44ff666309159d6bbd4332c67a" title="Minimum element. " alt="" coords="423,193,573,232"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a323ce82713ac209600ae5a47e6f858ae" title="Maximum element. " alt="" coords="421,256,575,295"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a904224147ac9f4987473e6edc87d5607" title="Absolute minimum element. " alt="" coords="409,319,587,357"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#ad398d3bad05eb83e635b316984e31994" title="Absolute maximum element. " alt="" coords="407,381,589,420"/>
<area shape="rect" id="node12" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a342be68250ef09785f8d08ed2c951e6e" title="Vector dot product. " alt="" coords="425,444,571,483"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1detail_1_1_tensor_interface.html#a3da3d7e2c563c86416219238880bc3f7" title="Vector 2&#45;norm. " alt="" coords="653,131,811,169"/>
</map>
</div>

</div>
</div>
<a id="a31b41f257f8f107174ffbfd3b9e7c0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b41f257f8f107174ffbfd3b9e7c0c3">&#9670;&nbsp;</a></span>write_tiles_to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Array , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TiledArray::detail::write_tiles_to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_tiled_array.html#adf28ccfd580f62de5342a9a1510e22e9">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="diagonal__array_8h_source.html#l00090">90</a> of file <a class="el" href="diagonal__array_8h_source.html">diagonal_array.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_cgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_cgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_cgraph" id="namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_cgraph">
<area shape="rect" id="node2" href="class_tiled_array_1_1_dist_array.html#a973ef7e8f216f744271ea4a8cd5ae8ae" title="Tiled range accessor. " alt="" coords="210,5,354,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array_1_1detail.html#ae2c7d290f2fb4704eecc33b0894de068" title="TiledArray::detail\l::diagonal_range" alt="" coords="222,68,343,107"/>
<area shape="rect" id="node8" href="class_tiled_array_1_1_dist_array.html#a70e45de02ea9820e6546dc06521c76f0" title="Check if the tile at index i is stored locally. " alt="" coords="210,131,354,169"/>
<area shape="rect" id="node9" href="class_tiled_array_1_1_dist_array.html#abd232f343c1f54cfca752298ea9aafd9" title="Check for zero tiles. " alt="" coords="210,193,354,232"/>
<area shape="rect" id="node10" href="class_tiled_array_1_1_dist_array.html#a1464487f0736a9c87b365ca2de8dab29" title="World accessor. " alt="" coords="210,256,354,295"/>
<area shape="rect" id="node11" href="class_tiled_array_1_1_dist_array.html#a791c7bfbb29bc9e7ebe2963125e5b2d9" title="Set a tile and fill it using a sequence. " alt="" coords="198,319,367,344"/>
<area shape="rect" id="node4" href="class_tiled_array_1_1_range.html#aae1d5994bf2507954a2b460197757149" title="Range lower bound accessor. " alt="" coords="415,37,550,76"/>
<area shape="rect" id="node6" href="class_tiled_array_1_1_range.html#ad59f6239bab9c89dac6fcccd6dbf8505" title="Range upper bound accessor. " alt="" coords="415,100,550,139"/>
<area shape="rect" id="node5" href="class_tiled_array_1_1_range.html#a0ab053bea46aaf1bf24a6eeab4600e3e" title="Range lower bound data accessor. " alt="" coords="598,37,734,76"/>
<area shape="rect" id="node7" href="class_tiled_array_1_1_range.html#af38569cb05cfd8691647b1be6c702a4b" title="Range upper bound data accessor. " alt="" coords="598,100,734,139"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_icgraph.png" border="0" usemap="#namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_icgraph" alt=""/></div>
<map name="namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_icgraph" id="namespace_tiled_array_1_1detail_a31b41f257f8f107174ffbfd3b9e7c0c3_icgraph">
<area shape="rect" id="node2" href="namespace_tiled_array.html#a1ddaca49af12c55a7e2087ad77aa8035" title="TiledArray::dense_diagonal\l_array" alt="" coords="198,5,381,44"/>
<area shape="rect" id="node3" href="namespace_tiled_array.html#ae8fd6c6add8ea900d7d2350fbe652390" title="TiledArray::sparse\l_diagonal_array" alt="" coords="225,68,354,107"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_tiled_array.html">TiledArray</a></li><li class="navelem"><a class="el" href="namespace_tiled_array_1_1detail.html">detail</a></li>
    <li class="footer">Generated on Mon Aug 27 2018 08:19:32 for TiledArray by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
